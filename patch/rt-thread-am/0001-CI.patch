From 293c623937bde088594d236d1fd6e76e5c11341d Mon Sep 17 00:00:00 2001
From: 202518023426015-Hu xinwei <huxinwei22@mails.ucas.ac.cn>
Date: Sat, 20 Dec 2025 11:36:57 +0800
Subject: [PATCH 1/3] CI

---
 bsp/abstract-machine/Makefile      |  7 +++-
 bsp/abstract-machine/extra.ld      |  2 +-
 bsp/abstract-machine/src/context.c | 64 +++++++++++++++++++++++++-----
 bsp/abstract-machine/src/init.c    |  4 ++
 bsp/abstract-machine/src/uart.c    | 33 +++++++++++++--
 5 files changed, 94 insertions(+), 16 deletions(-)

diff --git a/bsp/abstract-machine/Makefile b/bsp/abstract-machine/Makefile
index 8d70f310b..625ed140d 100644
--- a/bsp/abstract-machine/Makefile
+++ b/bsp/abstract-machine/Makefile
@@ -8,7 +8,12 @@ NAME = rtthread
 SRCS = $(shell find src -name "*.c")
 CFLAGS += -DHAVE_CCONFIG_H -D__RTTHREAD__
 CFLAGS += -Wno-nonnull-compare
-LDFLAGS += -T extra.ld
+
+ #rtt自己的链接脚本,在SoC里跑(将数据转移到sdram)，不需要链接这个脚本
+ifneq ($(ARCH), riscv32e-ysyxsoc)
+	LDFLAGS += -T extra.ld 
+endif
+
 -include $(FILE_MK)
 -include $(AM_APPS_MK)
 include $(AM_HOME)/Makefile
diff --git a/bsp/abstract-machine/extra.ld b/bsp/abstract-machine/extra.ld
index 5cdc65670..c7b2da835 100644
--- a/bsp/abstract-machine/extra.ld
+++ b/bsp/abstract-machine/extra.ld
@@ -27,7 +27,7 @@ SECTIONS {
     *(__am_apps.sdata*)
     __am_apps_data_end = .;
     . = ALIGN(8);
-  }
+  } 
 }
 INSERT BEFORE .data;
 
diff --git a/bsp/abstract-machine/src/context.c b/bsp/abstract-machine/src/context.c
index ee38829ae..8fb052250 100644
--- a/bsp/abstract-machine/src/context.c
+++ b/bsp/abstract-machine/src/context.c
@@ -2,11 +2,21 @@
 #include <klib.h>
 #include <rtthread.h>
 
+
 static Context* ev_handler(Event e, Context *c) {
-  switch (e.event) {
-    default: printf("Unhandled event ID = %d\n", e.event); assert(0);
-  }
-  return c;
+	switch (e.event) {
+        case EVENT_YIELD:{
+            rt_thread_t current = rt_thread_self(); 
+			c = *(Context**)current->user_data;//切换到新的上下文	
+            break;
+		}
+        case EVENT_IRQ_TIMER: return c;//识别出时钟中断事件:直接返回相应的上下文结构.
+		default: printf("Unhandled event ID = %d\n", e.event); assert(0);
+	}
+//   switch (e.event) {
+// 	default: printf("Unhandled event ID = %d\n", e.event); assert(0);
+//   }
+	return c;
 }
 
 void __am_cte_init() {
@@ -14,18 +24,52 @@ void __am_cte_init() {
 }
 
 void rt_hw_context_switch_to(rt_ubase_t to) {
-  assert(0);
+	rt_thread_t current = rt_thread_self(); 
+	current->user_data = to; //切换到to指向的上下文指针变量所指向的上下文,
+	yield();
 }
 
-void rt_hw_context_switch(rt_ubase_t from, rt_ubase_t to) {
-  assert(0);
+void rt_hw_context_switch(rt_ubase_t from, rt_ubase_t to) {	
+	rt_thread_t current = rt_thread_self(); 
+    *(Context**)from = current->sp;//额外将当前上下文的指针写入from指向的上下文指针变量中
+	current->user_data = to; //切换到to指向的上下文指针变量所指向的上下文,
+	yield();
 }
 
+
 void rt_hw_context_switch_interrupt(void *context, rt_ubase_t from, rt_ubase_t to, struct rt_thread *to_thread) {
-  assert(0);
+	assert(0);
+}
+
+
+typedef struct {
+    void (*tentry)(void*);
+    void* parameter;
+    void (*texit)(void);
+} rt_ubase_args;
+
+
+static void kcontext_schedule(rt_ubase_args* arg) { //包裹函数
+	if (arg->tentry) {arg->tentry(arg->parameter);  } // 调用线程入口函数tentry
+	if (arg->texit) {arg->texit();   } //在tentry返回后调用texit
+    else {
+		printf("=== RT-Thread/context/kcontext_schedule failed ===\n");
+		assert(0);// 线程结束后应该永远不会到达这里
+	}
 }
 
 rt_uint8_t *rt_hw_stack_init(void *tentry, void *parameter, rt_uint8_t *stack_addr, void *texit) {
-  assert(0);
-  return NULL;
+
+	stack_addr = (rt_uint8_t*)( ((uintptr_t)stack_addr + sizeof(uintptr_t) - 1) & ~(sizeof(uintptr_t) - 1));//向上对齐
+	stack_addr -= sizeof(rt_ubase_args); // 在栈上分配参数结构体空间
+	
+	//设置参数
+	rt_ubase_args* args = (rt_ubase_args*)stack_addr; //将tentry, parameter和texit这三个参数传给包裹函数
+    args->tentry = (void (*)(void*))tentry;  //入口
+    args->parameter = parameter;             //参数
+    args->texit = (void (*)(void))texit;     //返回
+
+	Context *cp =  kcontext((Area) {.end = (rt_uint8_t*)stack_addr}, (void*)kcontext_schedule, args);
+	return (rt_uint8_t *)cp;
 }
+
diff --git a/bsp/abstract-machine/src/init.c b/bsp/abstract-machine/src/init.c
index 93e271154..45899dcd8 100644
--- a/bsp/abstract-machine/src/init.c
+++ b/bsp/abstract-machine/src/init.c
@@ -52,7 +52,11 @@ void rt_hw_board_init() {
 #endif
 }
 
+
+
+
 int main() {
+  printf("===  RT-Thread Start ===\n");
   ioe_init();
 #ifdef __ISA_NATIVE__
   // trigger the real initialization of IOE to
diff --git a/bsp/abstract-machine/src/uart.c b/bsp/abstract-machine/src/uart.c
index e4eb86689..596c383ae 100644
--- a/bsp/abstract-machine/src/uart.c
+++ b/bsp/abstract-machine/src/uart.c
@@ -38,7 +38,32 @@ static int _uart_putc(struct rt_serial_device *serial, char c) {
 
 static int _uart_getc(struct rt_serial_device *serial) {
   static const char *p = "help\ndate\nversion\nfree\nps\npwd\nls\nmemtrace\nmemcheck\nutest_list\n";
-  return (*p != '\0' ? *(p ++) : -1);
+  
+#ifdef ARCH_RISCV32E_YSYXSOC
+  	static int builtin_commands_sent = 0;
+  
+  	// 第一阶段：发送内置命令字符串
+    if (!builtin_commands_sent) {
+    	if (*p != '\0') {
+      		return *(p++);
+    	} else {
+      		builtin_commands_sent = 1;  // 标记内置命令已发送完毕
+      		return -1;  // 暂时返回-1，等待真正的UART输入
+    	}
+  	}
+  	// 第二阶段：从UART RX获取真实输入
+  	AM_UART_RX_T rx_data;
+  	ioe_read(AM_UART_RX, &rx_data);
+    return (uint8_t)rx_data.data;
+	
+#else
+
+    return (*p != '\0' ? *(p ++) : -1); // 简单模式：直接返回预设命令
+
+#endif
+
+
+
 }
 
 const struct rt_uart_ops _uart_ops = {
@@ -67,9 +92,9 @@ int rt_hw_uart_init(void) {
   uart->irqno = 0x0a;
 
   rt_hw_serial_register(serial,
-      RT_CONSOLE_DEVICE_NAME,
-      RT_DEVICE_FLAG_STREAM | RT_DEVICE_FLAG_RDWR | RT_DEVICE_FLAG_INT_RX,
-      uart);
+	  RT_CONSOLE_DEVICE_NAME,
+	  RT_DEVICE_FLAG_STREAM | RT_DEVICE_FLAG_RDWR | RT_DEVICE_FLAG_INT_RX,
+	  uart);
   return 0;
 }
 
-- 
2.34.1

