From 822e2ef51983f51a004622edccf93641f10084aa Mon Sep 17 00:00:00 2001
From: kuikuikuizzZ <kimmmywu@gmail.com>
Date: Mon, 20 Oct 2025 18:03:36 +0800
Subject: [PATCH 23/23] feat(soc): update vga and keyboard

---
 src/amba/APBDelayer.scala  |   3 +-
 src/amba/AXI4Delayer.scala |   4 +-
 src/device/Keyboard.scala  | 176 ++++++++++++++++++++-----------------
 src/device/VGA.scala       | 167 +++++++++++++++++++++++------------
 4 files changed, 211 insertions(+), 139 deletions(-)

diff --git a/src/amba/APBDelayer.scala b/src/amba/APBDelayer.scala
index d75c7e7..6c1ded3 100644
--- a/src/amba/APBDelayer.scala
+++ b/src/amba/APBDelayer.scala
@@ -27,7 +27,8 @@ class APBDelayerChisel extends Module {
   val state = RegInit(s_idle)
   // B2 freq 350MHz, device typical 100MHz
   // s = 2^16, r= 3.5 , s_r = 229376
-  val s_r = 229376.U(32.W)
+  // s = 2^16, r= 7 , s_r = 458752
+  val s_r = 458752.U(32.W)
   val cnt = RegInit(0.U(32.W))
   val apb_start = io.in.penable && io.in.psel 
 
diff --git a/src/amba/AXI4Delayer.scala b/src/amba/AXI4Delayer.scala
index 1e87615..b537b4f 100644
--- a/src/amba/AXI4Delayer.scala
+++ b/src/amba/AXI4Delayer.scala
@@ -28,8 +28,8 @@ class AXI4DelayerChisel extends Module {
   val state = RegInit(s_idle)
   // B2 freq 350 MHz, device typical 100MHz
   // B4 freq 550 MHz, device typical 100MHz  
-  // s = 2^16, r= 3.5 , s_r = 229376
-  val s_r = 229376.U(32.W)
+  // s = 2^16, r= 7 , s_r = 458752
+  val s_r = 458752.U(32.W)
   val cnt = RegInit(0.U(32.W))
   val axi_start = (io.in.ar.valid && io.in.ar.ready) || (io.in.aw.valid && io.in.aw.ready)
   val axi_finsh = (io.out.r.valid &&  io.out.r.ready) || (io.out.b.valid && io.out.b.ready)
diff --git a/src/device/Keyboard.scala b/src/device/Keyboard.scala
index 269f735..7b1bf8b 100644
--- a/src/device/Keyboard.scala
+++ b/src/device/Keyboard.scala
@@ -25,98 +25,112 @@ class ps2_top_apb extends BlackBox {
 }
 
 
-
-class PS2Keyboard extends Module {
-  val io = IO(new Bundle {
-    val nextdata_n  = Input(Bool())       // 读请求（低有效）
-    val data        = Output(UInt(8.W))
-    val ready       = Output(Bool())      // FIFO数据就绪
-    // val overflow    = Output(Bool())      // FIFO溢出标志
-    val ps2         = new PS2IO
-  })
-
-    // 寄存器声明
-    val buffer      = RegInit(0.U(10.W))    // PS/2数据缓冲
-    val fifo        = Reg(Vec(8, UInt(8.W))) // 8字节FIFO
-    val w_ptr       = RegInit(0.U(3.W))     // 写指针
-    val r_ptr       = RegInit(0.U(3.W))     // 读指针
-    val count       = RegInit(0.U(4.W))     // 位计数器
-    val ready       = RegInit(false.B)      // FIFO就绪标志
-    val overflow    = RegInit(false.B)      // 溢出标志
-  
-    // 3级同步器检测PS/2时钟下降沿[6](@ref)
-    val ps2_clk_sync = RegInit(VecInit(Seq.fill(3)(true.B)))
-    ps2_clk_sync(0) := io.ps2.clk
-    for (i <- 1 until 3) {
-      ps2_clk_sync(i) := ps2_clk_sync(i-1)
-    }
-    val sampling = ps2_clk_sync(2) && !ps2_clk_sync(1)  // 下降沿检测
-
-    // FIFO读取逻辑
-    when(ready && !io.nextdata_n) {
-      r_ptr := r_ptr + 1.U
-      when(w_ptr === (r_ptr + 1.U)) {  // FIFO变空
-        ready := false.B
-      }
-    }
-
-    // PS/2数据采样逻辑[7](@ref)
-    when(sampling) {
-      when(count === 10.U) {
-        val startBit  = !buffer(0)        // 起始位应为0
-        val stopBit   = io.ps2.data       // 停止位应为1
-        val parity    = buffer(9,1).xorR  // 奇校验位
-        
-        // 帧校验通过
-        when(startBit && stopBit && parity) {
-          fifo(w_ptr) := buffer(8,1)     // 存储8位数据
-          w_ptr := w_ptr + 1.U
-          ready := true.B
-          // 溢出检测：写指针赶上读指针[3](@ref)
-          // overflow := overflow || (r_ptr === (w_ptr + 1.U))
-        }
-        count := 0.U
-      }.otherwise {
-        buffer := (buffer << 1) | io.ps2.data  // 移位存储数据位
-        count := count + 1.U
-      }
-    }
-  
-
-    // 输出连接[2](@ref)
-    io.data     := fifo(r_ptr)
-    io.ready    := ready
-    // io.overflow := overflow
-}
-
 class ps2Chisel extends Module {
   val io = IO(new PS2CtrlIO)
   io.in  := DontCare
 
-  val ps2Ctrl = Module(new PS2Keyboard)
-  val rdata = RegInit(0.U(32.W))
-  val nextdata_n = RegInit(false.B)
-  val ready = RegInit(false.B)
+  val ps2Ctrl = Module(new ps2Keyboard)
+  val nextdata_n = RegInit(true.B)
+  val fifo = RegInit(VecInit(Seq.fill(16)(0.U(8.W))))
+  val w_ptr = RegInit(0.U(4.W))
+  val ready =RegNext(ps2Ctrl.io.ready)
+  val ready_rise = ps2Ctrl.io.ready & ~ready
   val is_read = io.in.psel && io.in.penable && !io.in.pwrite
-  when(ps2Ctrl.io.ready) {
-    rdata := Cat(0.U(24.W),ps2Ctrl.io.data)
+
+  when(ready_rise) {
+    fifo(w_ptr) := ps2Ctrl.io.data
+    w_ptr := Mux(w_ptr <= 14.U, w_ptr + 1.U, w_ptr)
     nextdata_n := false.B
-    ready := true.B
-  }.elsewhen(is_read){
-    nextdata_n := true.B
-    ready := false.B
-  }.otherwise {
+  }.otherwise{
     nextdata_n := true.B
-    rdata := rdata
-    ready := ready
   }
+  
+  when(is_read){
+    for(i <- 0 until 15){
+      fifo(i) := fifo(i + 1)
+    }
+    w_ptr := Mux(w_ptr >= 1.U, w_ptr - 1.U, w_ptr)
+  }
+
+  ps2Ctrl.io.clk := clock
+  ps2Ctrl.io.reset := reset
   ps2Ctrl.io.nextdata_n :=  nextdata_n  
-  ps2Ctrl.io.ps2 <> io.ps2
-  io.in.prdata    := Mux(ready,rdata,0.U)
-  io.in.pready    := is_read
-  io.in.pslverr   := 0.U
+  ps2Ctrl.io.ps2_clk := io.ps2.clk
+  ps2Ctrl.io.ps2_data := io.ps2.data
+
+  io.in.prdata    := Mux(is_read,fifo(0),0.U)
+  io.in.pready    := io.in.penable
 }
 
+
+class ps2Keyboard extends BlackBox with HasBlackBoxInline {
+    val io = IO(new Bundle{
+        val clk = Input(Clock())
+        val reset = Input(Reset())
+        val ps2_clk = Input(Bool())
+        val ps2_data = Input(Bool())
+        val nextdata_n = Input(Bool())
+        val data = Output(UInt(8.W))
+        val ready = Output(Bool())
+        val overflow = Output(Bool())
+    })
+    setInline("ps2Keyboard.v",
+    """module ps2Keyboard(clk,reset,ps2_clk,ps2_data,data,
+      |                    ready,nextdata_n,overflow);
+      |    input clk,reset,ps2_clk,ps2_data;
+      |    input nextdata_n;
+      |    output [7:0] data;
+      |    output reg ready;
+      |    output reg overflow;     // fifo overflow
+      |    // internal signal, for test
+      |    reg [9:0] buffer;        // ps2_data bits
+      |    reg [7:0] fifo[7:0];     // data fifo
+      |    reg [2:0] w_ptr,r_ptr;   // fifo write and read pointers
+      |    reg [3:0] count;  // count ps2_data bits
+      |    // detect falling edge of ps2_clk
+      |    reg [2:0] ps2_clk_sync;
+      |
+      |    always @(posedge clk) begin
+      |        ps2_clk_sync <=  {ps2_clk_sync[1:0],ps2_clk};
+      |    end
+      |
+      |    wire sampling = ps2_clk_sync[2] & ~ps2_clk_sync[1];
+      |
+      |    always @(posedge clk) begin
+      |        if (reset) begin // reset
+      |            count <= 0; w_ptr <= 0; r_ptr <= 0; ready<= 0;
+      |        end
+      |        else begin
+      |            if ( ready ) begin // read to output next data
+      |                if(nextdata_n == 1'b0) //read next data
+      |                begin
+      |                    r_ptr <= r_ptr + 3'b1;
+      |                    if(w_ptr==(r_ptr+1'b1)) //empty
+      |                        ready <= 1'b0;
+      |                end
+      |            end
+      |            if (sampling) begin
+      |              if (count == 4'd10) begin
+      |                if ((buffer[0] == 0) &&  // start bit
+      |                    (ps2_data)       &&  // stop bit
+      |                    (^buffer[9:1])) begin      // odd  parity
+      |                    fifo[w_ptr] <= buffer[8:1];  // kbd scan code
+      |                    w_ptr <= w_ptr+3'b1;
+      |                    ready <= 1'b1;
+      |                end
+      |                count <= 0;     // for next
+      |              end else begin
+      |                buffer[count] <= ps2_data;  // store ps2_data
+      |                count <= count + 3'b1;
+      |              end
+      |            end
+      |        end
+      |    end
+      |    assign data = fifo[r_ptr]; //always set output data
+      |endmodule  
+    """.stripMargin)
+ }
+
 class APBKeyboard(address: Seq[AddressSet])(implicit p: Parameters) extends LazyModule {
   val node = APBSlaveNode(Seq(APBSlavePortParameters(
     Seq(APBSlaveParameters(
diff --git a/src/device/VGA.scala b/src/device/VGA.scala
index b68a9e3..d50bf58 100644
--- a/src/device/VGA.scala
+++ b/src/device/VGA.scala
@@ -29,67 +29,124 @@ class vga_top_apb extends BlackBox {
 }
 
 class vgaChisel extends Module {
-  val io = IO(new VGACtrlIO)
-
-    // 可配置时序参数（640x480@60Hz）
-    case class VGAParams(
-        hFrontPorch: Int = 96,
-        hActive:     Int = 144,
-        hBackPorch:  Int = 784,
-        hTotal:      Int = 800,
-        vFrontPorch: Int = 2,
-        vActive:     Int = 35,
-        vBackPorch:  Int = 515,
-        vTotal:      Int = 525
-    )
-    io.in.pready := true.B
-    io.in.pslverr := false.B
-    io.in.prdata := 0.U
-    val params = VGAParams()
-    
-    val sram = SyncReadMem(524288, UInt(24.W))
-    val xCnt = RegInit(1.U(10.W)).suggestName("xCnt")
-    val yCnt = RegInit(1.U(10.W)).suggestName("yCnt")
-
-    val is_write = io.in.psel && io.in.penable && io.in.pwrite
-    when(is_write){
-      sram.write(io.in.paddr(18,0), io.in.pwdata(23,0))
-    }
+    val io = IO(new VGACtrlIO)
+    val vgaCtrl = Module(new vgaCtrl)
 
-    // 水平计数器逻辑
-    when(io.reset) {
-        xCnt := 1.U
-    }.otherwise {
-        xCnt := Mux(xCnt === params.hTotal.U, 1.U, xCnt + 1.U)
+    val buffer = Mem(640 * 480, Vec(4, UInt(8.W)))
+    val addr = Wire(UInt(20.W))
+    val wdata = Wire(Vec(4, UInt(8.W)))
+    io := DontCare
+    io.in.pready := io.in.penable
+    addr := io.in.paddr(20, 2)
+    for(i <- 0 until 4){
+        wdata(i) := io.in.pwdata(i * 8 + 7, i * 8)
     }
-
-    // 垂直计数器逻辑
-    when(io.reset) {
-        yCnt := 1.U
-    }.elsewhen(xCnt === params.hTotal.U) {
-        yCnt := Mux(yCnt === params.vTotal.U, 1.U, yCnt + 1.U)
+    when(io.in.penable && io.in.pwrite){
+      buffer.write(addr, wdata)
+        
     }
+    vgaCtrl.io.pclk := clock
+    vgaCtrl.io.reset := reset
+    vgaCtrl.io.vga_data := buffer.read(vgaCtrl.io.h_addr + vgaCtrl.io.v_addr * 640.U).asUInt
 
-    // 有效区域判断
-    val hValid = (xCnt > params.hActive.U) && (xCnt <= params.hBackPorch.U)
-    val vValid = (yCnt > params.vActive.U) && (yCnt <= params.vBackPorch.U)
-    
-    // 同步信号生成（低有效脉冲）
-    io.vga.vsync := yCnt > params.vFrontPorch.U
-    io.vga.hsync := xCnt > params.hFrontPorch.U
-    io.vga.valid := hValid && vValid
-
-    // 像素坐标计算（消隐区归零）
-    val h_addr = Mux(hValid, xCnt - (params.hActive + 1).U, 0.U)
-    val v_addr = Mux(vValid, yCnt - (params.vActive + 1).U, 0.U)
-    val vga_data = sram((v_addr<< 9) + h_addr)
-    
-    // RGB输出（直接映射高位）
-    io.vga.r := vga_data(23, 16)
-    io.vga.g := vga_data(15, 8)
-    io.vga.b := vga_data(7, 0)
+    io.vga.hsync := vgaCtrl.io.hsync
+    io.vga.vsync := vgaCtrl.io.vsync
+    io.vga.valid := vgaCtrl.io.valid
+    io.vga.r     := vgaCtrl.io.vga_r
+    io.vga.g     := vgaCtrl.io.vga_g
+    io.vga.b     := vgaCtrl.io.vga_b
 }
 
+
+
+
+
+class vgaCtrl extends BlackBox with HasBlackBoxInline {
+    val io = IO(new Bundle{
+        val pclk = Input(Clock())
+        val reset = Input(Reset())
+        val vga_data = Input(UInt(24.W))
+
+        val h_addr = Output(UInt(10.W))
+        val v_addr = Output(UInt(10.W))
+        val hsync = Output(Bool())
+        val vsync = Output(Bool())
+        val valid = Output(Bool())
+        val vga_r = Output(UInt(8.W))
+        val vga_g = Output(UInt(8.W))
+        val vga_b = Output(UInt(8.W))
+    })
+    setInline("vgaCtrl.v",
+    """module vgaCtrl(
+          input           pclk,     //25MHz时钟
+          input           reset,    //置位
+          input  [23:0]   vga_data, //上层模块提供的VGA颜色数据
+          output [9:0]    h_addr,   //提供给上层模块的当前扫描像素点坐标
+          output [9:0]    v_addr,
+          output          hsync,    //行同步和列同步信号
+          output          vsync,
+          output          valid,    //消隐信号
+          output [7:0]    vga_r,    //红绿蓝颜色信号
+          output [7:0]    vga_g,
+          output [7:0]    vga_b
+          );
+
+        //640x480分辨率下的VGA参数设置
+        parameter    h_frontporch = 96;
+        parameter    h_active = 144;
+        parameter    h_backporch = 784;
+        parameter    h_total = 800;
+
+        parameter    v_frontporch = 2;
+        parameter    v_active = 35;
+        parameter    v_backporch = 515;
+        parameter    v_total = 525;
+
+        //像素计数值
+        reg [9:0]    x_cnt;
+        reg [9:0]    y_cnt;
+        wire         h_valid;
+        wire         v_valid;
+
+        always @(posedge reset or posedge pclk) //行像素计数
+            if (reset == 1'b1)
+              x_cnt <= 1;
+            else
+            begin
+              if (x_cnt == h_total)
+                  x_cnt <= 1;
+              else
+                  x_cnt <= x_cnt + 10'd1;
+            end
+
+        always @(posedge pclk)  //列像素计数
+            if (reset == 1'b1)
+              y_cnt <= 1;
+            else
+            begin
+              if (y_cnt == v_total & x_cnt == h_total)
+                  y_cnt <= 1;
+              else if (x_cnt == h_total)
+                  y_cnt <= y_cnt + 10'd1;
+            end
+        //生成同步信号
+        assign hsync = (x_cnt > h_frontporch);
+        assign vsync = (y_cnt > v_frontporch);
+        //生成消隐信号
+        assign h_valid = (x_cnt > h_active) & (x_cnt <= h_backporch);
+        assign v_valid = (y_cnt > v_active) & (y_cnt <= v_backporch);
+        assign valid = h_valid & v_valid;
+        //计算当前有效像素坐标
+        assign h_addr = h_valid ? (x_cnt - 10'd145) : {10{1'b0}};
+        assign v_addr = v_valid ? (y_cnt - 10'd36) : {10{1'b0}};
+        //设置输出的颜色值
+        assign vga_r = vga_data[23:16];
+        assign vga_g = vga_data[15:8];
+        assign vga_b = vga_data[7:0];
+      endmodule
+    """.stripMargin)
+ }
+
 class APBVGA(address: Seq[AddressSet])(implicit p: Parameters) extends LazyModule {
   val node = APBSlaveNode(Seq(APBSlavePortParameters(
     Seq(APBSlaveParameters(
-- 
2.43.0

