From cc4986ef08cc1f55c3f791a662e3abdd29c4ceff Mon Sep 17 00:00:00 2001
From: EPTansuo <eptansuo@163.com>
Date: Thu, 12 Dec 2024 13:38:01 +0800
Subject: [PATCH 09/23] support PSRAM, but not support unaligned access

---
 src/device/PSRAM.scala | 134 ++++++++++++++++-------------------------
 1 file changed, 52 insertions(+), 82 deletions(-)

diff --git a/src/device/PSRAM.scala b/src/device/PSRAM.scala
index ebdbe4df8..cc783af4e 100644
--- a/src/device/PSRAM.scala
+++ b/src/device/PSRAM.scala
@@ -37,47 +37,43 @@ class psramChisel extends RawModule {
   dontTouch(dout)
   val din = TriStateInBuf(io.dio, dout, out_en) // change this if you need
   
-  // We only need to wait when reading data
-  val cnt = withClockAndReset(io.sck.asClock, io.ce_n.asBool) { RegInit(0.U(4.W)) }
-  val cnt_next = Wire(UInt(4.W))
+  val first_cycle = withClockAndReset((!io.sck).asClock, io.ce_n.asAsyncReset) { RegInit(1.U(1.W)) }
+  first_cycle := io.ce_n
+
+  val cnt = withClockAndReset((!io.sck).asClock, io.ce_n.asAsyncReset) { RegInit(0.U(3.W)) }
+  val cnt_next = Wire(UInt(3.W))
   val isread = Wire(Bool())
   val s_cmd :: s_addr :: s_wait :: s_data :: Nil = Enum(4)
-  val state = withClockAndReset(io.sck.asClock, io.ce_n.asBool) { RegInit(s_cmd) }
+  val state = withClockAndReset((!io.sck).asClock, io.ce_n.asAsyncReset) { RegInit(s_cmd) }
   val state_next = Wire(UInt(s_cmd.getWidth.W))
   state_next := MuxLookup(state, s_cmd)( Seq(
-    //(s_idle -> Mux(io.ce_n, s_idle, s_cmd)),
-    (s_cmd  -> Mux(cnt === 8.U, s_addr, s_cmd)),   // 8 bits  
+    (s_cmd  -> Mux(cnt === 7.U, s_addr, s_cmd)),   // 8 bits
     (s_addr -> Mux(cnt === 5.U, Mux(isread, s_wait, s_data), s_addr)), // 4*6 bits
     (s_wait -> Mux(cnt === 5.U, s_data, s_wait)),  // wait 6 cycles
-    (s_data -> Mux(cnt === Mux(isread, 7.U, 6.U), s_cmd, s_data))   // 4*8 bits  
+    (s_data -> Mux(cnt === 7.U, s_cmd, s_data))   // Max 4*8 bits
   ))  
   state := state_next
-
+  dontTouch(cnt_next)
   cnt_next := cnt + 1.U
   when(state =/= state_next) {
     cnt := 0.U
   }.otherwise {
-    cnt := cnt_next
+    cnt := cnt_next(2,0)
   }
 
   out_en := (state === s_data) && isread
 
   val cmd = withClockAndReset(io.sck.asClock, io.ce_n.asBool) { RegInit(0.U(8.W)) }
-  when(state_next === s_cmd) {
+  when(state === s_cmd) {
     cmd := Cat(cmd(6,0), din(0))
   }
   isread := cmd === 0xEB.U
 
-  
-  
-
-  //val addr_raw = VecInit(Seq.fill(4)(withClockAndReset(io.sck.asClock, io.ce_n.asBool) { RegInit(0.U(6.W)) }))
-//  val addr_raw = withClockAndReset(io.sck.asClock, io.ce_n.asBool) { RegInit(VecInit(Seq.fill(4)(0.U(6.W)))) }
 
   val addr_raw = withClockAndReset(io.sck.asClock, io.ce_n.asBool) { RegInit(VecInit(Seq.fill(4)(0.U(6.W)))) }
 
 
-  when(state_next === s_addr) {
+  when(state === s_addr) {
     for(i <- 0 until 4){
       addr_raw(i) := Cat(addr_raw(i)(4,0), din(i))
     }
@@ -85,89 +81,63 @@ class psramChisel extends RawModule {
   
   val addr = Wire(UInt(24.W))
 
-  //  addr := Cat(addr_raw.reverse.map(_.asUInt).reduce(_ ## _))
   addr := Cat(addr_raw(3)(5), addr_raw(2)(5), addr_raw(1)(5), addr_raw(0)(5),
               addr_raw(3)(4), addr_raw(2)(4), addr_raw(1)(4), addr_raw(0)(4),
               addr_raw(3)(3), addr_raw(2)(3), addr_raw(1)(3), addr_raw(0)(3),
               addr_raw(3)(2), addr_raw(2)(2), addr_raw(1)(2), addr_raw(0)(2),
               addr_raw(3)(1), addr_raw(2)(1), addr_raw(1)(1), addr_raw(0)(1),
               addr_raw(3)(0), addr_raw(2)(0), addr_raw(1)(0), addr_raw(0)(0))
-  // for(i <- 0 until 4) {
-  //   for(j <- 0 until 6) {
-  //     addr(j*4+i) := addr_raw(i)(j)
-  //   }
-  // }
 
+  val cnt_data = withClockAndReset( (io.sck|io.ce_n).asClock, io.ce_n.asBool) { RegInit(0.U(3.W)) }
+  cnt_data := Mux(state === s_data, cnt, 0.U)
   val psram_rw_inst = Module(new psram_rw)
-  psram_rw_inst.io.clock := io.sck.asClock 
-  psram_rw_inst.io.reset := io.ce_n.asBool
-  psram_rw_inst.io.sel := (state === s_data && cnt === 6.U && (!isread)) || 
-                          (isread  && state === s_wait && cnt === 5.U)
+  psram_rw_inst.io.clock := (io.sck|io.ce_n).asClock
+  psram_rw_inst.io.reset := 0.U.asBool//io.ce_n.asBool
+  psram_rw_inst.io.sel := ((cnt_data(0) && (!isread) ) ||
+                          (isread)) &&
+                           (state === s_data || cnt_data.orR)
   psram_rw_inst.io.write := !isread
   psram_rw_inst.io.addr := addr(23, 0)
 
-  val data_raw = withClockAndReset(io.sck.asClock, io.ce_n.asBool) { RegInit(VecInit(Seq.fill(4)(0.U(8.W)))) }
-  //val data_raw = Vec(4, withClockAndReset(io.sck.asClock, io.ce_n.asBool) { RegInit(0.U(8.W)) })
-  when(state_next === s_data && (!isread)) {
-    for(i <- 0 until 4) {
-      data_raw(i) := Cat(data_raw(i)(7,0), din(i))
-    }
-  }
-  val data = Wire(UInt(32.W))
-
-  // data := Cat(data_raw.reverse.map(_.asUInt).reduce(_ ## _))
-
- data := Cat( data_raw(3)(0), data_raw(2)(0), data_raw(1)(0), data_raw(0)(0),
-              din, 
-              data_raw(3)(2), data_raw(2)(2), data_raw(1)(2), data_raw(0)(2),
-              data_raw(3)(1), data_raw(2)(1), data_raw(1)(1), data_raw(0)(1),
-              data_raw(3)(4), data_raw(2)(4), data_raw(1)(4), data_raw(0)(4),
-              data_raw(3)(3), data_raw(2)(3), data_raw(1)(3), data_raw(0)(3),
-              data_raw(3)(6), data_raw(2)(6), data_raw(1)(6), data_raw(0)(6),
-              data_raw(3)(5), data_raw(2)(5), data_raw(1)(5), data_raw(0)(5))
-  
-                 
-  // for(i <- 0 until 4){
-  //   for(j <- 0 until 8) {
-  //     data(j*4+i) := data_raw(i)(j)
-  //   }
-  // }
+  val wdata = withClockAndReset(io.sck.asClock, io.ce_n.asBool) { RegInit(0.U(8.W)) }
 
   when(state === s_data && (!isread)) {
-    psram_rw_inst.io.wdata := data
-    psram_rw_inst.io.wmask := 0xF.U
+    wdata := Cat(wdata(3,0),din)
+  }
+
+
+  psram_rw_inst.io.wdata := Mux((state === s_data || cnt_data.orR) && (!isread), Fill(4, wdata), 0.U)
+
+  when((state === s_data || cnt_data.orR) && (!isread)) {
+    psram_rw_inst.io.wmask := MuxLookup(cnt_data(2,1), 0.U)(Seq(
+      (0.U -> "b0001".U),
+      (1.U -> "b0010".U),
+      (2.U -> "b0100".U),
+      (3.U -> "b1000".U),
+      ))
   }.otherwise {
-    psram_rw_inst.io.wdata := 0.U
     psram_rw_inst.io.wmask := 0.U
   }
-  //val data_read =withClockAndReset(io.sck.asClock, io.ce_n.asBool) { RegInit(VecInit(Seq.fill(8)(0.U(4.W)))) }
-  val data_read_reg = withClockAndReset(io.sck.asClock, io.ce_n.asBool) { RegInit(0.U(32.W)) }
-  //dontTouch(data_read)
-  //val data_read = Vec(8, withClockAndReset(io.sck.asClock, io.ce_n.asBool) { Wire(UInt(4.W)) })
-  when(state === s_wait && cnt === 5.U) {
-  //   for(j <- 0 until 8) {
-  //     data_read(j) := psram_rw_inst.io.rdata(j*4+3, j*4)
-  // }
-    data_read_reg := psram_rw_inst.io.rdata
-  }
 
-  dout := Mux(state === s_data && isread, 
-              MuxLookup(cnt, 0.U)( Seq(
-                0.U -> data_read_reg(7, 4),
-                1.U -> data_read_reg(3, 0),
-                2.U -> data_read_reg(15, 12),
-                3.U -> data_read_reg(11, 8),
-                4.U -> data_read_reg(23, 20),
-                5.U -> data_read_reg(19, 16),
-                6.U -> data_read_reg(31, 28),
-                7.U -> data_read_reg(27, 24)
-              )), 0.U)
-
-  // when(state_next === s_data && isread && cnt === 5.U) {
-  //   dout := data_read(Mux(cnt === "b101".U, 0.U, cnt+1.U)) //需要提前读
-  // }.otherwise {
-  //   dout := 0.U
-  // }
+  val rdata_dout = Wire(UInt(4.W)) //withClockAndReset(io.sck.asClock, io.ce_n.asBool) { RegInit(0.U(4.W)) }
+  val rdata = psram_rw_inst.io.rdata
+
+  rdata_dout := Mux(state === s_data && isread,
+            MuxLookup(cnt_data, 0.U)(Seq(
+              (0.U -> rdata(7,4)),
+              (1.U -> rdata(3,0)),
+              (2.U -> rdata(15,12)),
+              (3.U -> rdata(11,8)),
+              (4.U -> rdata(23,20)),
+              (5.U -> rdata(19,16)),
+              (6.U -> rdata(31,28)),
+              (7.U -> rdata(27,24)),
+            )), 0.U)
+
+
+  dout := rdata_dout
+
+
   
   dontTouch(dout)
   withClockAndReset(io.sck.asClock, io.ce_n.asBool) {
-- 
2.51.0

