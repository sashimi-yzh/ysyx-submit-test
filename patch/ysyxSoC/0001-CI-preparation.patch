From 445664012109c005e65490004a7fb125b144607b Mon Sep 17 00:00:00 2001
From: huhao <huhao1226968736@outlook.com>
Date: Wed, 22 Oct 2025 09:46:07 +0800
Subject: [PATCH 1/3] CI preparation

---
 perip/amba/apb_delayer.v                     |  69 +-
 perip/amba/axi4_delayer.v                    | 180 ++++-
 perip/bitrev/bitrev.v                        |  27 +-
 perip/flash/flash.v                          |   1 +
 perip/gpio/gpio_top_apb.v                    | 110 +++
 perip/ps2/ps2_top_apb.v                      | 104 +++
 perip/psram/efabless/EF_PSRAM_CTRL.v         |  64 +-
 perip/psram/efabless/EF_PSRAM_CTRL_wb.v      |  10 +-
 perip/psram/psram.v                          | 138 +++-
 perip/psram/psram_top_apb.v                  |  35 +-
 perip/sdram/core_sdram_axi4/sdram_axi.v      |   6 +-
 perip/sdram/core_sdram_axi4/sdram_axi_core.v | 792 +++++++++++++++++--
 perip/sdram/sdram.v                          |  93 ++-
 perip/sdram/sdram_top_apb.v                  |  96 ++-
 perip/sdram/sdram_top_axi.v                  |  14 +-
 perip/spi/rtl/spi_top.v                      |   6 +-
 perip/spi/rtl/spi_top_apb.v                  | 238 +++++-
 perip/vga/vga_top_apb.v                      | 113 +++
 src/CPU.scala                                |   4 +-
 src/SoC.scala                                |  68 +-
 src/Top.scala                                |   2 +-
 src/device/SDRAM.scala                       |  17 +-
 22 files changed, 2010 insertions(+), 177 deletions(-)

diff --git a/perip/amba/apb_delayer.v b/perip/amba/apb_delayer.v
index c0d20764..e39b7199 100644
--- a/perip/amba/apb_delayer.v
+++ b/perip/amba/apb_delayer.v
@@ -23,16 +23,75 @@ module apb_delayer(
   input  [31:0] out_prdata,
   input         out_pslverr
 );
+  // localparam CPU_MHZ = 270.5;
+  // localparam DEV_MHZ = 100;
+  // R = (r - 1) * s
+  localparam R = 32'd7004488 - 32'd1048576; // r = 2.73767  s=2^20
+  // F = t1' - t0 = (t1 - t0) * r
+  // wite = F - (t1 - t0) = (t1 - t0) * (r - 1) = (t1 - t0) * R / s
 
   assign out_paddr   = in_paddr;
-  assign out_psel    = in_psel;
-  assign out_penable = in_penable;
+  assign out_psel    = ready ? 1'b0 : in_psel;
+  assign out_penable = ready ? 1'b0 : in_penable;
   assign out_pprot   = in_pprot;
   assign out_pwrite  = in_pwrite;
   assign out_pwdata  = in_pwdata;
   assign out_pstrb   = in_pstrb;
-  assign in_pready   = out_pready;
-  assign in_prdata   = out_prdata;
-  assign in_pslverr  = out_pslverr;
+
+  assign in_pready   = rcount == wcount & waits;
+  assign in_prdata   = waits & start ? out_prdata : rdata;
+  assign in_pslverr  = waits & start ? out_pslverr : slverr;
+
+  reg start, ready, slverr;
+  reg [31:0] count, wcount, rdata;
+  always @(posedge clock) begin
+    if (reset) begin 
+      start <= 1'b0;
+      count <= 32'b0;
+    end
+    else if (out_psel & ~start) begin
+      start <= 1'b1;
+      count <= count + R;  
+    end
+    else if (start & out_pready) begin
+      start <= 1'b0;
+      if (wcount == rcount) ready <= 1'b0;
+      else ready <= 1'b1;
+    end
+  end
+
+  wire [31:0] rcount = count >> 20;
+  wire waits = out_pready | ready;
+
+  always @(posedge clock) begin
+    if (reset) begin
+      ready <= 1'b0;
+      wcount <= 32'b0;
+    end 
+    else if (start & ~out_pready) begin
+      count <= count + R;
+    end
+    else if (waits) begin
+      if (wcount == rcount) begin
+        wcount <= 0;
+        count <= 0;
+        ready <= 0;
+      end
+      else wcount <= wcount + 1;
+    end
+  end
+
+  always @(posedge clock) begin
+    // $display("r s e:%b %b %b   start:%b  wait:%b  count:%d  wcount:%d", out_pready, out_psel, out_penable, start, waits, count, wcount);
+    // $display("%h", out_prdata);
+    if (start & out_pready) begin
+      rdata <= out_prdata;
+      slverr <= out_pslverr;
+    end
+    else begin
+      rdata <= rdata;
+      slverr <= slverr;
+    end
+  end
 
 endmodule
diff --git a/perip/amba/axi4_delayer.v b/perip/amba/axi4_delayer.v
index f692803b..106124d0 100644
--- a/perip/amba/axi4_delayer.v
+++ b/perip/amba/axi4_delayer.v
@@ -62,6 +62,12 @@ module axi4_delayer(
   input  [3:0]  out_bid,
   input  [1:0]  out_bresp
 );
+  // localparam CPU_MHZ = 270.5;
+  // localparam DEV_MHZ = 100;
+  // R = (r - 1) * s
+  localparam R = 32'd7004488 - 32'd1048576; // r = 2.73767  s=2^20
+  // F = t1' - t0 = (t1 - t0) * r
+  // wite = F - (t1 - t0) = (t1 - t0) * (r - 1) = (t1 - t0) * R / s
 
   assign in_arready = out_arready;
   assign out_arvalid = in_arvalid;
@@ -71,11 +77,11 @@ module axi4_delayer(
   assign out_arsize = in_arsize;
   assign out_arburst = in_arburst;
   assign out_rready = in_rready;
-  assign in_rvalid = out_rvalid;
+  assign in_rvalid = rvalid;
   assign in_rid = out_rid;
-  assign in_rdata = out_rdata;
+  assign in_rdata = rdata[lenr[4:0]];
   assign in_rresp = out_rresp;
-  assign in_rlast = out_rlast;
+  assign in_rlast = rlast; // out_rlast;
   assign in_awready = out_awready;
   assign out_awvalid = in_awvalid;
   assign out_awid = in_awid;
@@ -83,14 +89,178 @@ module axi4_delayer(
   assign out_awlen = in_awlen;
   assign out_awsize = in_awsize;
   assign out_awburst = in_awburst;
-  assign in_wready = out_wready;
+  assign in_wready = wready & lenw != 8'b1;
   assign out_wvalid = in_wvalid;
   assign out_wdata = in_wdata;
   assign out_wstrb = in_wstrb;
   assign out_wlast = in_wlast;
   assign out_bready = in_bready;
-  assign in_bvalid = out_bvalid;
+  assign in_bvalid = wlast;
   assign in_bid = out_bid;
   assign in_bresp = out_bresp;
 
+//-------------------------------------------------------------
+// axi read delayer
+//-------------------------------------------------------------
+
+  reg [7:0] rlen, lenr;
+  reg [31:0] rcount, countr;
+  reg [31:0] rwait [31:0]; // wait queue
+  reg [31:0] rdata [31:0];
+  reg [31:0] validr; // read complete flag
+  reg rstart;
+
+  wire rvalid = countr == rwait[lenr[4:0]] & validr[lenr[4:0]];
+  wire rlast = rvalid & lenr == 8'b1;
+
+  // rstart
+  always @(posedge clock) begin
+    if (reset)
+      rstart <= 1'b0;
+    else if (in_arvalid)
+      rstart <= 1'b1;
+    else if (rlast)
+      rstart <= 1'b0;
+  end
+
+  // rlen
+  always @(posedge clock) begin
+    if (reset)
+      rlen <= 8'b0;
+    else if (~rstart & in_arvalid)
+      rlen <= in_arlen + 1;
+    else if (in_rready & out_rvalid)
+      rlen <= rlen - 1;
+  end
+
+  // lenr
+  always @(posedge clock) begin
+    if (reset)
+      lenr <= 0;
+    else if (~rstart & in_arvalid)
+      lenr <= in_arlen + 1;
+    else if (in_rready & rvalid)
+      lenr <= lenr - 1;
+  end
+
+  // rcount rwait
+  always @(posedge clock) begin
+    if (reset)
+      rcount <= 0;
+    else if (in_arvalid & ~rstart)
+      rcount <= 0;
+    else if (in_rready & out_rvalid) begin
+      rcount <= 0;
+      rwait[rlen[4:0]] <= (rcount + R) >> 20;
+      rdata[rlen[4:0]] <= out_rdata;
+    end
+    else if (rstart)
+      rcount <= rcount + R;
+  end
+
+  // countr
+  always @(posedge clock) begin
+    if (reset)
+      countr <= 0;
+    else if (in_rready & out_rvalid & lenr == rlen)
+      countr <= 0;
+    else if (in_rready & rvalid)
+      countr <= 0;
+    else if (rstart)
+      countr <= countr + 1;
+  end
+
+  // validr
+  always @(posedge clock) begin
+    if (reset)
+      validr <= 32'b0;
+    else if (~rstart & in_arvalid)
+      validr <= 32'b0;
+    else if (in_rready & out_rvalid)
+      validr[rlen[4:0]] <= 1'b1;
+    else if (in_rready & rvalid)
+      validr[lenr[4:0]] <= 1'b0;
+  end
+
+//-------------------------------------------------------------
+// axi write delayer
+//-------------------------------------------------------------
+
+  reg [7:0] wlen, lenw;
+  reg [31:0] wcount, countw;
+  reg [31:0] wwait [7:0]; // wait queue
+  reg [7:0] validw; // read complete flag
+  reg wstart;
+
+  wire wready = countw == wwait[lenw[2:0]] & validw[lenw[2:0]];
+  wire wlast = wready & lenw == 8'b1;
+
+  // wstart
+  always @(posedge clock) begin
+    if (reset)
+      wstart <= 1'b0;
+    else if (in_awvalid)
+      wstart <= 1'b1;
+    else if (wlast)
+      wstart <= 1'b0;
+  end
+
+  // wlen
+  always @(posedge clock) begin
+    if (reset)
+      wlen <= 8'b0;
+    else if (~wstart & in_awvalid)
+      wlen <= in_awlen + 2;
+    else if ((out_wready & in_wvalid) | (in_bready & out_bvalid))
+      wlen <= wlen - 1;
+  end
+
+  // lenw
+  always @(posedge clock) begin
+    if (reset)
+      lenw <= 0;
+    else if (~wstart & in_awvalid)
+      lenw <= in_awlen + 2;
+    else if ((in_wvalid & wready) | (in_bready & wready))
+      lenw <= lenw - 1;
+  end
+
+  // wcount wwait
+  always @(posedge clock) begin
+    if (reset)
+      wcount <= 0;
+    else if (in_awvalid & ~wstart)
+      wcount <= 0;
+    else if((out_wready & in_wvalid) | (in_bready & out_bvalid)) begin
+      wcount <= 0;
+      wwait[wlen[2:0]] <= (wcount + R) >> 20;
+    end
+    else if (wstart)
+      wcount <= wcount + R;
+  end
+
+  // countw
+  always @(posedge clock) begin
+    if (reset)
+      countw <= 0;
+    else if (((out_wready & in_wvalid) | (in_bready & out_bvalid)) & wlen == lenw)
+      countw <= 0;
+    else if ((in_wvalid & wready) | (in_bready & wready))
+      countw <= 0;      
+    else if (wstart)
+      countw <= countw + 1;
+  end
+
+  // validw
+  always @(posedge clock) begin
+    if (reset)
+      validw <= 8'b0;
+    else if (~wstart & in_awvalid)
+      validw <= 8'b0;
+    else if ((out_wready & in_wvalid) | (in_bready & out_bvalid))
+      validw[wlen[2:0]] <= 1'b1;
+    else if ((in_wvalid & wready) | (in_bready & wready))
+      validw[lenw[2:0]] <= 1'b0;
+  end
+
 endmodule
diff --git a/perip/bitrev/bitrev.v b/perip/bitrev/bitrev.v
index f1c3b363..9f557253 100644
--- a/perip/bitrev/bitrev.v
+++ b/perip/bitrev/bitrev.v
@@ -1,8 +1,29 @@
 module bitrev (
-  input  sck,
+  input  sck, // 时钟信号
   input  ss,
   input  mosi,
-  output miso
+  output reg miso
 );
-  assign miso = 1'b1;
+
+  reg [7:0] recv;
+  reg [3:0] count;
+
+  assign miso = ~ss & count[3] ? recv[0] : 1;
+  always @(posedge sck) begin
+    if (~ss & ~count[3]) begin // 低电平有效
+      // $display("recv=> recv:%b  count:%d", recv, count);
+      recv[0] <= mosi;
+      recv[7:1] <= recv[6:0];
+    end
+    else if (~ss & count[3]) begin
+      // $display("send=> recv:%b  count:%d", recv, count);
+      recv[6:0] <= recv[7:1];
+      recv[7] <= 0;
+    end
+  end
+
+  always @(posedge sck) begin
+      if (~ss) count <= count + 1;
+  end
+
 endmodule
diff --git a/perip/flash/flash.v b/perip/flash/flash.v
index 480d7092..74228a36 100644
--- a/perip/flash/flash.v
+++ b/perip/flash/flash.v
@@ -30,6 +30,7 @@ module flash (
   );
 
   always@(posedge sck or posedge reset) begin
+    // $display("cmd:%h  addr:%b  counter:%d", cmd, raddr[23:0], counter);
     if (reset) state <= cmd_t;
     else begin
       case (state)
diff --git a/perip/gpio/gpio_top_apb.v b/perip/gpio/gpio_top_apb.v
index ec51ffe5..9230ec29 100644
--- a/perip/gpio/gpio_top_apb.v
+++ b/perip/gpio/gpio_top_apb.v
@@ -24,4 +24,114 @@ module gpio_top_apb(
   output [7:0]  gpio_seg_7
 );
 
+  wire gpio_en = in_psel & in_penable;
+  wire [31:0] wmask = {{8{in_pstrb[3]}}, {8{in_pstrb[2]}}, {8{in_pstrb[1]}}, {8{in_pstrb[0]}}};
+  wire [15:0] data_out = (in_pwdata[15:0] & wmask[15:0]) | (gpio_out & ~wmask[15:0]);
+  wire [31:0] data_seg = (in_pwdata & wmask) | (gp_seg_t & ~wmask);
+
+  reg [31:0] gp_rdata;
+  reg [31:0] gp_seg_t;
+  reg [15:0] gp_out;
+  reg ready;
+
+  assign in_prdata = in_pwrite ? 32'b0 : gp_rdata;
+  assign in_pready = ready;
+  assign gpio_out = gp_out;
+
+  always @(posedge clock) begin
+      if (reset) begin
+        gp_rdata <= 0;
+        gp_seg_t <= 0;
+        ready <= 0;
+        gp_out <= 0;
+      end
+      else if (gpio_en) begin
+        // $display("wdata:%h  strb:%b  rdata:%h  %b", data_out, in_pstrb, in_prdata, in_pwrite);
+        if (in_pwrite) begin
+          case (in_paddr[3:2])
+            2'b00: gp_out <= data_out; 
+            2'b01: gp_rdata <= gp_rdata;
+            2'b10: gp_seg_t <= data_seg;
+            2'b11: ;
+          endcase
+        end
+        else begin
+          case (in_paddr[3:2])
+            2'b00: gp_rdata <= {16'b0, gpio_out}; 
+            2'b01: gp_rdata <= {16'b0, gpio_in};
+            2'b10: gp_rdata <= gp_seg_t;
+            2'b11: gp_rdata <= 0;
+          endcase
+        end
+      end
+  end
+
+  always @(posedge clock) begin
+      if (gpio_en & ~reset) ready <= 1'b1;
+      else ready <= 1'b0;
+  end
+
+  seg_decoder u_decoder(
+    .gp_seg_t   (gp_seg_t),
+    .gpio_seg_0 (gpio_seg_0),
+    .gpio_seg_1 (gpio_seg_1), 
+    .gpio_seg_2 (gpio_seg_2),
+    .gpio_seg_3 (gpio_seg_3),
+    .gpio_seg_4 (gpio_seg_4),
+    .gpio_seg_5 (gpio_seg_5),
+    .gpio_seg_6 (gpio_seg_6),
+    .gpio_seg_7 (gpio_seg_7)
+  );
+
+endmodule
+
+module seg_decoder (
+    input  wire [31:0] gp_seg_t,          // 每4位一组，共8组
+    output reg  [7:0]  gpio_seg_0,
+    output reg  [7:0]  gpio_seg_1,
+    output reg  [7:0]  gpio_seg_2,
+    output reg  [7:0]  gpio_seg_3,
+    output reg  [7:0]  gpio_seg_4,
+    output reg  [7:0]  gpio_seg_5,
+    output reg  [7:0]  gpio_seg_6,
+    output reg  [7:0]  gpio_seg_7
+);
+
+// 共阳极，a~g~dp 映射 7~0
+function [7:0] seg_lut;
+    input [3:0] digit;
+    begin
+        case (digit)
+            4'h0: seg_lut = 8'b00000011;
+            4'h1: seg_lut = 8'b10011111;
+            4'h2: seg_lut = 8'b00100101;
+            4'h3: seg_lut = 8'b00001101;
+            4'h4: seg_lut = 8'b10011001;
+            4'h5: seg_lut = 8'b01001001;
+            4'h6: seg_lut = 8'b01000001;
+            4'h7: seg_lut = 8'b00011111;
+            4'h8: seg_lut = 8'b00000001;
+            4'h9: seg_lut = 8'b00001001;
+            4'hA: seg_lut = 8'b00010001;
+            4'hB: seg_lut = 8'b11000001;
+            4'hC: seg_lut = 8'b01100011;
+            4'hD: seg_lut = 8'b10000101;
+            4'hE: seg_lut = 8'b01100001;
+            4'hF: seg_lut = 8'b01110001;
+            default: seg_lut = 8'b11111111; // 全灭
+        endcase
+    end
+endfunction
+
+always @(*) begin
+    gpio_seg_0 = seg_lut(gp_seg_t[ 3: 0]);
+    gpio_seg_1 = seg_lut(gp_seg_t[ 7: 4]);
+    gpio_seg_2 = seg_lut(gp_seg_t[11: 8]);
+    gpio_seg_3 = seg_lut(gp_seg_t[15:12]);
+    gpio_seg_4 = seg_lut(gp_seg_t[19:16]);
+    gpio_seg_5 = seg_lut(gp_seg_t[23:20]);
+    gpio_seg_6 = seg_lut(gp_seg_t[27:24]);
+    gpio_seg_7 = seg_lut(gp_seg_t[31:28]);
+end
+
 endmodule
diff --git a/perip/ps2/ps2_top_apb.v b/perip/ps2/ps2_top_apb.v
index 080d38fa..119301a4 100644
--- a/perip/ps2/ps2_top_apb.v
+++ b/perip/ps2/ps2_top_apb.v
@@ -1,3 +1,67 @@
+module ps2_keyboard(
+    input clk,          // 系统主时钟
+    input clrn,         // 异步复位信号（低电平有效）
+    input ps2_clk,      // PS2接口时钟信号
+    input ps2_data,     // PS2接口数据信号
+    input nextdata_n,   // 数据读取请求信号（低电平有效）
+    output [7:0] data,  // 当前读取的键盘数据
+    output reg ready,   // FIFO数据就绪标志
+    output reg overflow // FIFO溢出标志
+);
+    
+    // internal signal, for test
+    reg [9:0] buffer;        // ps2_data bits
+    reg [7:0] fifo[7:0];     // data fifo
+    reg [2:0] w_ptr,r_ptr;   // fifo write and read pointers
+    reg [3:0] count;  // count ps2_data bits
+
+    // detect falling edge of ps2_clk
+    reg [2:0] ps2_clk_sync;
+
+    always @(posedge clk) begin
+        ps2_clk_sync <=  {ps2_clk_sync[1:0],ps2_clk};
+    end
+
+    wire sampling = ps2_clk_sync[2] & ~ps2_clk_sync[1];
+
+    always @(posedge clk) begin
+        if (clrn == 0) begin // reset
+            count <= 0; w_ptr <= 0; r_ptr <= 0; overflow <= 0; ready<= 0;
+        end
+        else begin
+            if ( ready ) begin // read to output next data
+                if(nextdata_n == 1'b0) //read next data
+                begin
+                    // $display("rptr: %d, w_ptr: %d, data: %h", r_ptr, w_ptr, data);
+                    r_ptr <= r_ptr + 3'b1;
+                    if(w_ptr==(r_ptr+3'b1)) //empty
+                        ready <= 1'b0;
+                end
+            end
+            if (sampling) begin
+              if (count == 4'd10) begin
+                if ((buffer[0] == 0) &&  // start bit
+                    (ps2_data)       &&  // stop bit
+                    (^buffer[9:1])) begin      // odd  parity
+                    fifo[w_ptr] <= buffer[8:1];  // kbd scan code
+                    w_ptr <= w_ptr+3'b1;
+                    ready <= 1'b1;
+                    overflow <= overflow | (r_ptr == (w_ptr + 3'b1));
+                end
+                count <= 0;     // for next
+              end else begin
+                buffer[count] <= ps2_data;  // store ps2_data
+                count <= count + 3'b1;
+              end
+            end
+            // $display("code: %b  %b  %b", buffer, ps2_clk, ps2_data);
+        end
+    end
+    assign data = fifo[r_ptr]; //always set output data
+
+endmodule
+
+
 module ps2_top_apb(
   input         clock,
   input         reset,
@@ -15,5 +79,45 @@ module ps2_top_apb(
   input         ps2_clk,
   input         ps2_data
 );
+  
+  wire ready, overflow;
+  wire [7:0] data;
+
+  reg pready, nextdata;
+  reg [7:0] rdata;
+
+  assign in_prdata = {24'b0, rdata};
+  assign in_pready = pready;
+  wire ren = in_psel & in_penable;
+
+  always @(posedge clock) begin
+      if (reset) begin
+        rdata <= 0;        
+        nextdata <= 1;
+        pready <= 0;
+      end
+      else if (ren) begin
+        if (ready) begin 
+          rdata <= data;
+          nextdata <= 1'b0;
+        end
+        else rdata <= 0;
+        pready <= 1;
+      end
+
+      if (~nextdata) nextdata <= 1'b1;
+  end
+
+  // 数据读取
+  ps2_keyboard u_ps2_keyboard(
+    .clk        	(clock       ),
+    .clrn       	(~reset      ),
+    .ps2_clk    	(ps2_clk     ),
+    .ps2_data   	(ps2_data    ),
+    .nextdata_n 	(nextdata    ),
+    .data       	(data        ),
+    .ready      	(ready       ),
+    .overflow   	(overflow)
+  );
 
 endmodule
diff --git a/perip/psram/efabless/EF_PSRAM_CTRL.v b/perip/psram/efabless/EF_PSRAM_CTRL.v
index b6e737e9..f5bc480f 100644
--- a/perip/psram/efabless/EF_PSRAM_CTRL.v
+++ b/perip/psram/efabless/EF_PSRAM_CTRL.v
@@ -47,6 +47,7 @@ module PSRAM_READER (
     input   wire [23:0]     addr,
     input   wire            rd,
     input   wire [2:0]      size,
+    input   wire            qpi_mod,
     output  wire            done,
     output  wire [31:0]     line,
 
@@ -60,7 +61,7 @@ module PSRAM_READER (
     localparam  IDLE = 1'b0,
                 READ = 1'b1;
 
-    wire [7:0]  FINAL_COUNT = 19 + size*2; // was 27: Always read 1 word
+    wire [7:0]  FINAL_COUNT = qpi_mod ? 13 + size*2 : 19 + size*2; // was 27: Always read 1 word
 
     reg         state, nstate;
     reg [7:0]   counter;
@@ -113,19 +114,22 @@ module PSRAM_READER (
             saddr <= {addr[23:0]};
 
     // Sample with the negedge of sck
-    wire[1:0] byte_index = {counter[7:1] - 8'd10}[1:0];
+    wire [7:0] data_send = qpi_mod ? 8'd14 : 8'd20;
+    wire[1:0] byte_index = {counter[7:1] - 8'd7}[1:0];
     always @ (posedge clk)
-        if(counter >= 20 && counter <= FINAL_COUNT)
+        if(counter >= data_send && counter <= FINAL_COUNT)
             if(sck)
                 data[byte_index] <= {data[byte_index][3:0], din}; // Optimize!
-
-    assign dout     =   (counter < 8)   ?   {3'b0, CMD_EBH[7 - counter]}:
-                        (counter == 8)  ?   saddr[23:20]        :
-                        (counter == 9)  ?   saddr[19:16]        :
-                        (counter == 10) ?   saddr[15:12]        :
-                        (counter == 11) ?   saddr[11:8]         :
-                        (counter == 12) ?   saddr[7:4]          :
-                        (counter == 13) ?   saddr[3:0]          :
+    
+    wire [7:0] cmd_send = qpi_mod ? 2 : 8;
+    wire [3:0] cmd_data = qpi_mod ?  counter == 1 ? CMD_EBH[3:0] : CMD_EBH[7:4] : {3'b0, CMD_EBH[7 - counter]};
+    assign dout     =   (counter < cmd_send     ) ?   cmd_data            :
+                        (counter == cmd_send    ) ?   saddr[23:20]        :
+                        (counter == cmd_send + 1) ?   saddr[19:16]        :
+                        (counter == cmd_send + 2) ?   saddr[15:12]        :
+                        (counter == cmd_send + 3) ?   saddr[11:8]         :
+                        (counter == cmd_send + 4) ?   saddr[7:4]          :
+                        (counter == cmd_send + 5) ?   saddr[3:0]          :
                         4'h0;
 
     assign douten   = (counter < 14);
@@ -149,6 +153,8 @@ module PSRAM_WRITER (
     input   wire [31: 0]    line,
     input   wire [2:0]      size,
     input   wire            wr,
+    input   wire            qpi_set,
+    input   wire            qpi_mod,
     output  wire            done,
 
     output  reg             sck,
@@ -161,14 +167,14 @@ module PSRAM_WRITER (
     localparam  IDLE = 1'b0,
                 WRITE = 1'b1;
 
-    wire[7:0]        FINAL_COUNT = 13 + size*2;
+    wire[7:0]        FINAL_COUNT = qpi_set ? 8'd8 : qpi_mod ? 7 + size*2 : 13 + size*2;
 
     reg         state, nstate;
     reg [7:0]   counter;
     reg [23:0]  saddr;
     //reg [7:0]   data [3:0];
 
-    wire[7:0]   CMD_38H = 8'h38;
+    wire[7:0]   CMD_38H = qpi_set ? 8'h35 : 8'h38;
 
     always @*
         case (state)
@@ -185,7 +191,7 @@ module PSRAM_WRITER (
         if(!rst_n)
             sck <= 1'b0;
         else if(~ce_n)
-            sck <= ~ sck;
+            sck <= ~sck;
         else if(state == IDLE)
             sck <= 1'b0;
 
@@ -212,20 +218,22 @@ module PSRAM_WRITER (
         else if((state == IDLE) && wr)
             saddr <= addr;
 
-    assign dout     =   (counter < 8)   ?   {3'b0, CMD_38H[7 - counter]}:
-                        (counter == 8)  ?   saddr[23:20]        :
-                        (counter == 9)  ?   saddr[19:16]        :
-                        (counter == 10) ?   saddr[15:12]        :
-                        (counter == 11) ?   saddr[11:8]         :
-                        (counter == 12) ?   saddr[7:4]          :
-                        (counter == 13) ?   saddr[3:0]          :
-                        (counter == 14) ?   line[7:4]           :
-                        (counter == 15) ?   line[3:0]           :
-                        (counter == 16) ?   line[15:12]         :
-                        (counter == 17) ?   line[11:8]          :
-                        (counter == 18) ?   line[23:20]         :
-                        (counter == 19) ?   line[19:16]         :
-                        (counter == 20) ?   line[31:28]         :
+    wire [7:0] cmd_send = qpi_mod ? 2 : 8;
+    wire [3:0] cmd_data = qpi_mod ?  counter == 1 ? CMD_38H[3:0] : CMD_38H[7:4] : {3'b0, CMD_38H[7 - counter]};
+    assign dout     =   (counter < cmd_send     ) ?   cmd_data            :
+                        (counter == cmd_send    )  ?   saddr[23:20]        :
+                        (counter == cmd_send + 1)  ?   saddr[19:16]        :
+                        (counter == cmd_send + 2) ?   saddr[15:12]        :
+                        (counter == cmd_send + 3) ?   saddr[11:8]         :
+                        (counter == cmd_send + 4) ?   saddr[7:4]          :
+                        (counter == cmd_send + 5) ?   saddr[3:0]          :
+                        (counter == cmd_send + 6) ?   line[7:4]           :
+                        (counter == cmd_send + 7) ?   line[3:0]           :
+                        (counter == cmd_send + 8) ?   line[15:12]         :
+                        (counter == cmd_send + 9) ?   line[11:8]          :
+                        (counter == cmd_send + 10) ?   line[23:20]         :
+                        (counter == cmd_send + 11) ?   line[19:16]         :
+                        (counter == cmd_send + 12) ?   line[31:28]         :
                         line[27:24];
 
     assign douten   = (~ce_n);
diff --git a/perip/psram/efabless/EF_PSRAM_CTRL_wb.v b/perip/psram/efabless/EF_PSRAM_CTRL_wb.v
index 7b5296db..4c08b355 100644
--- a/perip/psram/efabless/EF_PSRAM_CTRL_wb.v
+++ b/perip/psram/efabless/EF_PSRAM_CTRL_wb.v
@@ -30,6 +30,8 @@ module EF_PSRAM_CTRL_wb (
     input   wire        stb_i,
     output  wire        ack_o,
     input   wire        we_i,
+    input   wire        qpi_set,
+    input   wire        qpi_mod,
 
     // External Interface to Quad I/O
     output  wire            sck,
@@ -100,8 +102,6 @@ module EF_PSRAM_CTRL_wb (
                         (sel_i == 4'b1100) ? 2 :
                         (sel_i == 4'b1111) ? 4 : 4;
 
-
-
     wire [7:0]  byte0 = (sel_i[0])          ? dat_i[7:0]   :
                         (sel_i[1] & size==1)? dat_i[15:8]  :
                         (sel_i[2] & size==1)? dat_i[23:16] :
@@ -143,7 +143,8 @@ module EF_PSRAM_CTRL_wb (
         .ce_n(mr_ce_n),
         .din(mr_din),
         .dout(mr_dout),
-        .douten(mr_doe)
+        .douten(mr_doe),
+        .qpi_mod (qpi_mod)
     );
 
     PSRAM_WRITER MW (
@@ -153,7 +154,10 @@ module EF_PSRAM_CTRL_wb (
         .wr(mw_wr),
         .size(size),
         .done(mw_done),
+        .qpi_set (qpi_set),
+        .qpi_mod (qpi_mod),
         .line(wdata),
+
         .sck(mw_sck),
         .ce_n(mw_ce_n),
         .din(mw_din),
diff --git a/perip/psram/psram.v b/perip/psram/psram.v
index d9bdd882..fee97352 100644
--- a/perip/psram/psram.v
+++ b/perip/psram/psram.v
@@ -3,7 +3,143 @@ module psram(
   input ce_n,
   inout [3:0] dio
 );
+  typedef enum [2:0] { cmd_t, addr_t, wait_t, rdata_t, wdata_t, err_t } state_t;
+  wire reset = ce_n;
 
-  assign dio = 4'bz;
+  reg [7:0]  counter;
+  reg [7:0] cmd;
+  reg [2:0] state;
+  reg [23:0] addr;
+  reg [31:0] rdata_r;
+  reg [31:0] wdata_r;
 
+  wire [31:0] rdata, wdata;
+  reg [3:0] eaddr_r;
+  wire [3:0] eaddr = state == addr_t ? dio : eaddr_r;
+  
+  reg qpi_mod;
+
+  psram_cmd psram_cmd_i(
+    .clock(sck | reset),
+    .ren ((state == addr_t) & (counter == 8'd5)),
+    .wen ((state == wdata_t) & reset),
+    .cmd (cmd),
+    .len (counter >> 1),
+    .addr({8'b0, addr[19:0], eaddr}),
+    .rdata(rdata),
+    .wdata(wdata)
+  );
+
+  wire [7:0] cmd_m = qpi_mod ? 8'd1 : 8'd7;
+
+  // state
+  always@(posedge sck or posedge reset) begin
+    // $display("qpi:%b  cmd:%h  addr:%h  counter:%d  dio:%b  state:%b  rdata:%h  en:%b %b", qpi_mod, cmd, addr, counter, dio, state, rdata, reset, sck);
+    if (reset) begin 
+      state <= cmd_t;
+    end
+    else begin
+      case (state)
+        cmd_t:  state <= (counter == cmd_m ) ? addr_t : state;
+        
+        addr_t: begin
+          if (cmd == 8'hEB) state <= (counter == 8'd5) ? wait_t : state;
+          else if (cmd == 8'h38) state <= (counter == 8'd5) ? wdata_t : state;
+          else if (cmd == 8'h35) qpi_mod <= 1;
+          else state <= err_t;
+        end
+
+        wait_t: state <= (counter == 8'd6) ? rdata_t : state;
+
+        wdata_t: state <= state;
+        
+        rdata_t: state <= state;
+
+        default: begin
+          state <= state;
+          $fwrite(32'h80000002, "Assertion failed: Unsupported command `%xh`, support `38h` `EBh` read command\n", cmd);
+          $fatal;
+        end
+      endcase
+    end
+  end
+  
+  // counter 
+  always@(posedge sck or posedge reset) begin
+    if (reset) counter <= 8'd0;
+    else begin
+      case (state)
+        cmd_t:   counter <= (counter < cmd_m ) ? counter + 8'd1 : 8'd0;
+        addr_t:  counter <= (counter < 8'd5) ? counter + 8'd1 : 8'd0;
+        wait_t:  counter <= (counter < 8'd6) ? counter + 8'd1 : 8'd0;
+        default: counter <= counter + 8'd1;
+      endcase
+    end
+  end
+
+  // command
+  always@(posedge sck or posedge reset) begin
+    if (reset)               cmd <= 8'd0;
+    else if (state == cmd_t) begin
+      if (qpi_mod) cmd <= { cmd[3:0], dio }; 
+      else cmd <= { cmd[6:0], dio[0] };
+
+    end 
+  end
+
+  // address
+  always@(posedge sck or posedge reset) begin
+    if (reset) begin 
+      addr <= 24'd0;
+      eaddr_r <= 4'b0;
+    end
+    else if (state == addr_t && counter < 8'd5) begin
+      addr <= { addr[19:0], dio };
+      eaddr_r <= 4'b0;      
+    end
+    else if (state == addr_t && counter == 8'd5)
+      eaddr_r <= dio;
+    else 
+      eaddr_r <= eaddr_r;
+  end
+
+  // rdata send
+  wire [31:0] data_bswap = {rdata[7:0], rdata[15:8], rdata[23:16], rdata[31:24]};
+  always@(posedge sck or posedge reset) begin
+    if (reset) rdata_r <= 32'd0;
+    else if (state == rdata_t) begin
+      rdata_r <= { {counter == 8'd0 ? data_bswap : rdata_r}[27:0], 4'b0 };
+    end
+  end
+  wire [3:0] rdio = ({(state == rdata_t && counter == 8'd0) ? data_bswap : rdata_r}[31:28]);
+  assign dio = (state == rdata_t) ? rdio : 4'dz;
+
+  // wdata recvice
+  always@(posedge sck or posedge reset) begin
+    if (reset) wdata_r <= 32'd0;
+    else if (state == wdata_t) begin
+      wdata_r <= { wdata_r[27:0], dio };
+    end
+  end
+  assign wdata = {wdata_r[7:0], wdata_r[15:8], wdata_r[23:16], wdata_r[31:24]};
+
+endmodule
+
+import "DPI-C" function void psram_read(input int addr, output int data);
+import "DPI-C" function void psram_write(input int addr, input int data, input int len);
+
+module psram_cmd(
+  input             clock,
+  input             ren,
+  input             wen,
+  input      [7:0]  cmd,
+  input      [7:0]  len,
+  input      [31:0] addr,
+  output reg [31:0] rdata,
+  input  reg [31:0] wdata
+);
+  always@(posedge clock) begin
+      if (ren && cmd == 8'heb) psram_read(addr, rdata);
+      else if (wen && cmd == 8'h38) psram_write(addr, wdata, {24'd0, len}); 
+  end
 endmodule
diff --git a/perip/psram/psram_top_apb.v b/perip/psram/psram_top_apb.v
index 0ba9c2f2..70ec8114 100644
--- a/perip/psram/psram_top_apb.v
+++ b/perip/psram/psram_top_apb.v
@@ -17,19 +17,40 @@ module psram_top_apb (
   inout  [3:0] qspi_dio
 );
 
+  reg QPI_SET;
+  reg qpi_mod;
+  always @(posedge clock) begin
+      if (reset) begin
+        QPI_SET <= 1;
+        qpi_mod <= 0;
+      end
+
+      if (QPI_SET & ack) begin
+        QPI_SET <= 0;
+        qpi_mod <= 1;
+      end
+  end
+
+  wire [31:0] addr_in = QPI_SET ? 32'b0 : in_paddr;
+  wire [31:0] data_in = QPI_SET ? 32'b0 : in_pwdata;
+  wire [31:0] data_out;
+  assign in_prdata = QPI_SET ? 32'b0 : data_out;
+
   wire [3:0] din, dout, douten;
   wire ack;
   EF_PSRAM_CTRL_wb u0 (
     .clk_i(clock),
     .rst_i(reset),
-    .adr_i(in_paddr),
-    .dat_i(in_pwdata),
-    .dat_o(in_prdata),
-    .sel_i(in_pstrb),
-    .cyc_i(in_psel),
-    .stb_i(in_psel),
+    .adr_i(addr_in),
+    .dat_i(data_in),
+    .dat_o(data_out),
+    .sel_i(QPI_SET ? 4'b0 : in_pstrb),
+    .cyc_i(QPI_SET ? 1'b1 : in_psel),
+    .stb_i(QPI_SET ? 1'b1 :in_psel),
     .ack_o(ack),
-    .we_i(in_pwrite),
+    .we_i(QPI_SET ? 1'b1 : in_pwrite),
+    .qpi_set (QPI_SET),
+    .qpi_mod (qpi_mod),
   
     .sck(qspi_sck),
     .ce_n(qspi_ce_n),
diff --git a/perip/sdram/core_sdram_axi4/sdram_axi.v b/perip/sdram/core_sdram_axi4/sdram_axi.v
index 64641f58..e743eb16 100644
--- a/perip/sdram/core_sdram_axi4/sdram_axi.v
+++ b/perip/sdram/core_sdram_axi4/sdram_axi.v
@@ -53,7 +53,7 @@ module sdram_axi
     ,input  [  7:0]  inport_arlen_i
     ,input  [  1:0]  inport_arburst_i
     ,input           inport_rready_i
-    ,input  [ 15:0]  sdram_data_input_i
+    ,input  [ 31:0]  sdram_data_input_i
 
     // Outputs
     ,output          inport_awready_o
@@ -73,10 +73,10 @@ module sdram_axi
     ,output          sdram_ras_o
     ,output          sdram_cas_o
     ,output          sdram_we_o
-    ,output [  1:0]  sdram_dqm_o
+    ,output [  3:0]  sdram_dqm_o
     ,output [ 12:0]  sdram_addr_o
     ,output [  1:0]  sdram_ba_o
-    ,output [ 15:0]  sdram_data_output_o
+    ,output [ 31:0]  sdram_data_output_o
     ,output          sdram_data_out_en_o
 );
 
diff --git a/perip/sdram/core_sdram_axi4/sdram_axi_core.v b/perip/sdram/core_sdram_axi4/sdram_axi_core.v
index cedbf77b..e361b13f 100644
--- a/perip/sdram/core_sdram_axi4/sdram_axi_core.v
+++ b/perip/sdram/core_sdram_axi4/sdram_axi_core.v
@@ -32,6 +32,716 @@
 //                          Generated File
 //-----------------------------------------------------------------
 
+// module sdram_axi_core
+// (
+//     // Inputs
+//      input           clk_i
+//     ,input           rst_i
+//     ,input  [  3:0]  inport_wr_i
+//     ,input           inport_rd_i
+//     ,input  [  7:0]  inport_len_i
+//     ,input  [ 31:0]  inport_addr_i
+//     ,input  [ 31:0]  inport_write_data_i
+//     ,input  [ 15:0]  sdram_data_input_i
+
+//     // Outputs
+//     ,output          inport_accept_o
+//     ,output          inport_ack_o
+//     ,output          inport_error_o
+//     ,output [ 31:0]  inport_read_data_o
+//     ,output          sdram_clk_o
+//     ,output          sdram_cke_o
+//     ,output          sdram_cs_o
+//     ,output          sdram_ras_o
+//     ,output          sdram_cas_o
+//     ,output          sdram_we_o
+//     ,output [  1:0]  sdram_dqm_o
+//     ,output [ 12:0]  sdram_addr_o
+//     ,output [  1:0]  sdram_ba_o
+//     ,output [ 15:0]  sdram_data_output_o
+//     ,output          sdram_data_out_en_o
+// );
+
+
+
+// //-----------------------------------------------------------------
+// // Key Params
+// //-----------------------------------------------------------------
+// parameter SDRAM_MHZ              = 50;
+// parameter SDRAM_ADDR_W           = 24;
+// parameter SDRAM_COL_W            = 9;
+// parameter SDRAM_READ_LATENCY     = 2;
+
+// //-----------------------------------------------------------------
+// // Defines / Local params
+// //-----------------------------------------------------------------
+// localparam SDRAM_BANK_W          = 2;
+// localparam SDRAM_DQM_W           = 2;
+// localparam SDRAM_BANKS           = 2 ** SDRAM_BANK_W;
+// localparam SDRAM_ROW_W           = SDRAM_ADDR_W - SDRAM_COL_W - SDRAM_BANK_W;
+// localparam SDRAM_REFRESH_CNT     = 2 ** SDRAM_ROW_W;
+// localparam SDRAM_START_DELAY     = 100000 / (1000 / SDRAM_MHZ); // 100uS
+// localparam SDRAM_REFRESH_CYCLES  = (64000*SDRAM_MHZ) / SDRAM_REFRESH_CNT-1;
+
+// localparam CMD_W             = 4;
+// localparam CMD_NOP           = 4'b0111;
+// localparam CMD_ACTIVE        = 4'b0011;
+// localparam CMD_READ          = 4'b0101;
+// localparam CMD_WRITE         = 4'b0100;
+// localparam CMD_TERMINATE     = 4'b0110;
+// localparam CMD_PRECHARGE     = 4'b0010;
+// localparam CMD_REFRESH       = 4'b0001;
+// localparam CMD_LOAD_MODE     = 4'b0000;
+
+// // Mode: Burst Length = 4 bytes, CAS=2
+// localparam MODE_REG          = {3'b000,1'b0,2'b00,3'b010,1'b0,3'b001};
+
+// // SM states
+// localparam STATE_W           = 4;
+// localparam STATE_INIT        = 4'd0;
+// localparam STATE_DELAY       = 4'd1;
+// localparam STATE_IDLE        = 4'd2;
+// localparam STATE_ACTIVATE    = 4'd3;
+// localparam STATE_READ        = 4'd4;
+// localparam STATE_READ_WAIT   = 4'd5;
+// localparam STATE_WRITE0      = 4'd6;
+// localparam STATE_WRITE1      = 4'd7;
+// localparam STATE_PRECHARGE   = 4'd8;
+// localparam STATE_REFRESH     = 4'd9;
+
+// localparam AUTO_PRECHARGE    = 10;
+// localparam ALL_BANKS         = 10;
+
+// localparam SDRAM_DATA_W      = 16;
+
+// localparam CYCLE_TIME_NS     = 1000 / SDRAM_MHZ;
+
+// // SDRAM timing
+// localparam SDRAM_TRCD_CYCLES = (20 + (CYCLE_TIME_NS-1)) / CYCLE_TIME_NS;
+// localparam SDRAM_TRP_CYCLES  = (20 + (CYCLE_TIME_NS-1)) / CYCLE_TIME_NS;
+// localparam SDRAM_TRFC_CYCLES = (60 + (CYCLE_TIME_NS-1)) / CYCLE_TIME_NS;
+
+// //-----------------------------------------------------------------
+// // External Interface
+// //-----------------------------------------------------------------
+// wire [ 31:0]  ram_addr_w       = inport_addr_i;
+// wire [  3:0]  ram_wr_w         = inport_wr_i;
+// wire          ram_rd_w         = inport_rd_i;
+// wire          ram_accept_w;
+// wire [ 31:0]  ram_write_data_w = inport_write_data_i;
+// wire [ 31:0]  ram_read_data_w;
+// wire          ram_ack_w;
+
+// wire          ram_req_w = (ram_wr_w != 4'b0) | ram_rd_w;
+
+// assign inport_ack_o       = ram_ack_w;
+// assign inport_read_data_o = ram_read_data_w;
+// assign inport_error_o     = 1'b0;
+// assign inport_accept_o    = ram_accept_w;
+
+// //-----------------------------------------------------------------
+// // Registers / Wires
+// //-----------------------------------------------------------------
+
+// // Xilinx placement pragmas:
+// //synthesis attribute IOB of command_q is "TRUE"
+// //synthesis attribute IOB of addr_q is "TRUE"
+// //synthesis attribute IOB of dqm_q is "TRUE"
+// //synthesis attribute IOB of cke_q is "TRUE"
+// //synthesis attribute IOB of bank_q is "TRUE"
+// //synthesis attribute IOB of data_q is "TRUE"
+
+// reg [CMD_W-1:0]        command_q;
+// reg [SDRAM_ROW_W-1:0]  addr_q;
+// reg [SDRAM_DATA_W-1:0] data_q;
+// reg                    data_rd_en_q;
+// reg [SDRAM_DQM_W-1:0]  dqm_q;
+// reg                    cke_q;
+// reg [SDRAM_BANK_W-1:0] bank_q;
+
+// // Buffer half word during read and write commands
+// reg [SDRAM_DATA_W-1:0] data_buffer_q;
+// reg [SDRAM_DQM_W-1:0]  dqm_buffer_q;
+
+// wire [SDRAM_DATA_W-1:0] sdram_data_in_w;
+
+// reg                    refresh_q;
+
+// reg [SDRAM_BANKS-1:0]  row_open_q;
+// reg [SDRAM_ROW_W-1:0]  active_row_q[0:SDRAM_BANKS-1];
+
+// reg  [STATE_W-1:0]     state_q;
+// reg  [STATE_W-1:0]     next_state_r;
+// reg  [STATE_W-1:0]     target_state_r;
+// reg  [STATE_W-1:0]     target_state_q;
+// reg  [STATE_W-1:0]     delay_state_q;
+
+// // Address bits
+// wire [SDRAM_ROW_W-1:0]  addr_col_w  = {{(SDRAM_ROW_W-SDRAM_COL_W){1'b0}}, ram_addr_w[SDRAM_COL_W:2], 1'b0};
+// wire [SDRAM_ROW_W-1:0]  addr_row_w  = ram_addr_w[SDRAM_ADDR_W:SDRAM_COL_W+2+1];
+// wire [SDRAM_BANK_W-1:0] addr_bank_w = ram_addr_w[SDRAM_COL_W+2:SDRAM_COL_W+2-1];
+
+// //-----------------------------------------------------------------
+// // SDRAM State Machine
+// //-----------------------------------------------------------------
+// always @ *
+// begin
+//     next_state_r   = state_q;
+//     target_state_r = target_state_q;
+
+//     case (state_q)
+//     //-----------------------------------------
+//     // STATE_INIT
+//     //-----------------------------------------
+//     STATE_INIT :
+//     begin
+//         if (refresh_q)
+//             next_state_r = STATE_IDLE;
+//     end
+//     //-----------------------------------------
+//     // STATE_IDLE
+//     //-----------------------------------------
+//     STATE_IDLE :
+//     begin
+//         // Pending refresh
+//         // Note: tRAS (open row time) cannot be exceeded due to periodic
+//         //        auto refreshes.
+//         if (refresh_q)
+//         begin
+//             // Close open rows, then refresh
+//             if (|row_open_q)
+//                 next_state_r = STATE_PRECHARGE;
+//             else
+//                 next_state_r = STATE_REFRESH;
+
+//             target_state_r = STATE_REFRESH;
+//         end
+//         // Access request
+//         else if (ram_req_w)
+//         begin
+//             // Open row hit
+//             if (row_open_q[addr_bank_w] && addr_row_w == active_row_q[addr_bank_w])
+//             begin
+//                 if (!ram_rd_w)
+//                     next_state_r = STATE_WRITE0;
+//                 else
+//                     next_state_r = STATE_READ;
+//             end
+//             // Row miss, close row, open new row
+//             else if (row_open_q[addr_bank_w])
+//             begin
+//                 next_state_r   = STATE_PRECHARGE;
+
+//                 if (!ram_rd_w)
+//                     target_state_r = STATE_WRITE0;
+//                 else
+//                     target_state_r = STATE_READ;
+//             end
+//             // No open row, open row
+//             else
+//             begin
+//                 next_state_r   = STATE_ACTIVATE;
+
+//                 if (!ram_rd_w)
+//                     target_state_r = STATE_WRITE0;
+//                 else
+//                     target_state_r = STATE_READ;
+//             end
+//         end
+//     end
+//     //-----------------------------------------
+//     // STATE_ACTIVATE
+//     //-----------------------------------------
+//     STATE_ACTIVATE :
+//     begin
+//         // Proceed to read or write state
+//         next_state_r = target_state_r;
+//     end
+//     //-----------------------------------------
+//     // STATE_READ
+//     //-----------------------------------------
+//     STATE_READ :
+//     begin
+//         next_state_r = STATE_READ_WAIT;
+//     end
+//     //-----------------------------------------
+//     // STATE_READ_WAIT
+//     //-----------------------------------------
+//     STATE_READ_WAIT :
+//     begin
+//         next_state_r = STATE_IDLE;
+
+//         // Another pending read request (with no refresh pending)
+//         if (!refresh_q && ram_req_w && ram_rd_w)
+//         begin
+//             // Open row hit
+//             if (row_open_q[addr_bank_w] && addr_row_w == active_row_q[addr_bank_w])
+//                 next_state_r = STATE_READ;
+//         end
+//     end
+//     //-----------------------------------------
+//     // STATE_WRITE0
+//     //-----------------------------------------
+//     STATE_WRITE0 :
+//     begin
+//         next_state_r = STATE_WRITE1;
+//     end
+//     //-----------------------------------------
+//     // STATE_WRITE1
+//     //-----------------------------------------
+//     STATE_WRITE1 :
+//     begin
+//         next_state_r = STATE_IDLE;
+
+//         // Another pending write request (with no refresh pending)
+//         if (!refresh_q && ram_req_w && (ram_wr_w != 4'b0))
+//         begin
+//             // Open row hit
+//             if (row_open_q[addr_bank_w] && addr_row_w == active_row_q[addr_bank_w])
+//                 next_state_r = STATE_WRITE0;
+//         end
+//     end
+//     //-----------------------------------------
+//     // STATE_PRECHARGE
+//     //-----------------------------------------
+//     STATE_PRECHARGE :
+//     begin
+//         // Closing row to perform refresh
+//         if (target_state_r == STATE_REFRESH)
+//             next_state_r = STATE_REFRESH;
+//         // Must be closing row to open another
+//         else
+//             next_state_r = STATE_ACTIVATE;
+//     end
+//     //-----------------------------------------
+//     // STATE_REFRESH
+//     //-----------------------------------------
+//     STATE_REFRESH :
+//     begin
+//         next_state_r = STATE_IDLE;
+//     end
+//     //-----------------------------------------
+//     // STATE_DELAY
+//     //-----------------------------------------
+//     STATE_DELAY :
+//     begin
+//         next_state_r = delay_state_q;
+//     end
+//     default:
+//         ;
+//    endcase
+// end
+
+// //-----------------------------------------------------------------
+// // Delays
+// //-----------------------------------------------------------------
+// localparam DELAY_W = 4;
+
+// reg [DELAY_W-1:0] delay_q;
+// reg [DELAY_W-1:0] delay_r;
+
+// /* verilator lint_off WIDTH */
+
+// always @ *
+// begin
+//     case (state_q)
+//     //-----------------------------------------
+//     // STATE_ACTIVATE
+//     //-----------------------------------------
+//     STATE_ACTIVATE :
+//     begin
+//         // tRCD (ACTIVATE -> READ / WRITE)
+//         delay_r = SDRAM_TRCD_CYCLES;
+//     end
+//     //-----------------------------------------
+//     // STATE_READ_WAIT
+//     //-----------------------------------------
+//     STATE_READ_WAIT :
+//     begin
+//         delay_r = SDRAM_READ_LATENCY;
+
+//         // Another pending read request (with no refresh pending)
+//         if (!refresh_q && ram_req_w && ram_rd_w)
+//         begin
+//             // Open row hit
+//             if (row_open_q[addr_bank_w] && addr_row_w == active_row_q[addr_bank_w])
+//                 delay_r = 4'd0;
+//         end
+//     end
+//     //-----------------------------------------
+//     // STATE_PRECHARGE
+//     //-----------------------------------------
+//     STATE_PRECHARGE :
+//     begin
+//         // tRP (PRECHARGE -> ACTIVATE)
+//         delay_r = SDRAM_TRP_CYCLES;
+//     end
+//     //-----------------------------------------
+//     // STATE_REFRESH
+//     //-----------------------------------------
+//     STATE_REFRESH :
+//     begin
+//         // tRFC
+//         delay_r = SDRAM_TRFC_CYCLES;
+//     end
+//     //-----------------------------------------
+//     // STATE_DELAY
+//     //-----------------------------------------
+//     STATE_DELAY:
+//     begin
+//         delay_r = delay_q - 4'd1;
+//     end
+//     //-----------------------------------------
+//     // Others
+//     //-----------------------------------------
+//     default:
+//     begin
+//         delay_r = {DELAY_W{1'b0}};
+//     end
+//     endcase
+// end
+// /* verilator lint_on WIDTH */
+
+// // Record target state
+// always @ (posedge clk_i or posedge rst_i)
+// if (rst_i)
+//     target_state_q   <= STATE_IDLE;
+// else
+//     target_state_q   <= target_state_r;
+
+// // Record delayed state
+// always @ (posedge clk_i or posedge rst_i)
+// if (rst_i)
+//     delay_state_q   <= STATE_IDLE;
+// // On entering into delay state, record intended next state
+// else if (state_q != STATE_DELAY && delay_r != {DELAY_W{1'b0}})
+//     delay_state_q   <= next_state_r;
+
+// // Update actual state
+// always @ (posedge clk_i or posedge rst_i)
+// if (rst_i)
+//     state_q   <= STATE_INIT;
+// // Delaying...
+// else if (delay_r != {DELAY_W{1'b0}})
+//     state_q   <= STATE_DELAY;
+// else
+//     state_q   <= next_state_r;
+
+// // Update delay flops
+// always @ (posedge clk_i or posedge rst_i)
+// if (rst_i)
+//     delay_q   <= {DELAY_W{1'b0}};
+// else
+//     delay_q   <= delay_r;
+
+// //-----------------------------------------------------------------
+// // Refresh counter
+// //-----------------------------------------------------------------
+// localparam REFRESH_CNT_W = 17;
+
+// reg [REFRESH_CNT_W-1:0] refresh_timer_q;
+// always @ (posedge clk_i or posedge rst_i)
+// if (rst_i)
+//     refresh_timer_q <= SDRAM_START_DELAY + 100;
+// else if (refresh_timer_q == {REFRESH_CNT_W{1'b0}})
+//     refresh_timer_q <= SDRAM_REFRESH_CYCLES;
+// else
+//     refresh_timer_q <= refresh_timer_q - 1;
+
+// always @ (posedge clk_i or posedge rst_i)
+// if (rst_i)
+//     refresh_q <= 1'b0;
+// else if (refresh_timer_q == {REFRESH_CNT_W{1'b0}})
+//     refresh_q <= 1'b1;
+// else if (state_q == STATE_REFRESH)
+//     refresh_q <= 1'b0;
+
+// //-----------------------------------------------------------------
+// // Input sampling
+// //-----------------------------------------------------------------
+
+// reg [SDRAM_DATA_W-1:0] sample_data0_q;
+// always @ (posedge clk_i or posedge rst_i)
+// if (rst_i)
+//     sample_data0_q <= {SDRAM_DATA_W{1'b0}};
+// else
+//     sample_data0_q <= sdram_data_in_w;
+
+// reg [SDRAM_DATA_W-1:0] sample_data_q;
+// always @ (posedge clk_i or posedge rst_i)
+// if (rst_i)
+//     sample_data_q <= {SDRAM_DATA_W{1'b0}};
+// else
+//     sample_data_q <= sample_data0_q;
+
+// //-----------------------------------------------------------------
+// // Command Output
+// //-----------------------------------------------------------------
+// integer idx;
+
+// always @ (posedge clk_i or posedge rst_i)
+// if (rst_i)
+// begin
+//     command_q       <= CMD_NOP;
+//     data_q          <= 16'b0;
+//     addr_q          <= {SDRAM_ROW_W{1'b0}};
+//     bank_q          <= {SDRAM_BANK_W{1'b0}};
+//     cke_q           <= 1'b0;
+//     dqm_q           <= {SDRAM_DQM_W{1'b0}};
+//     data_rd_en_q    <= 1'b1;
+//     dqm_buffer_q    <= {SDRAM_DQM_W{1'b0}};
+
+//     for (idx=0;idx<SDRAM_BANKS;idx=idx+1)
+//         active_row_q[idx] <= {SDRAM_ROW_W{1'b0}};
+
+//     row_open_q      <= {SDRAM_BANKS{1'b0}};
+// end
+// else
+// begin
+//     case (state_q)
+//     //-----------------------------------------
+//     // STATE_IDLE / Default (delays)
+//     //-----------------------------------------
+//     default:
+//     begin
+//         // Default
+//         command_q    <= CMD_NOP;
+//         addr_q       <= {SDRAM_ROW_W{1'b0}};
+//         bank_q       <= {SDRAM_BANK_W{1'b0}};
+//         data_rd_en_q <= 1'b1;
+//     end
+//     //-----------------------------------------
+//     // STATE_INIT
+//     //-----------------------------------------
+//     STATE_INIT:
+//     begin
+//         // Assert CKE
+//         if (refresh_timer_q == 50)
+//         begin
+//             // Assert CKE after 100uS
+//             cke_q <= 1'b1;
+//         end
+//         // PRECHARGE
+//         else if (refresh_timer_q == 40)
+//         begin
+//             // Precharge all banks
+//             command_q           <= CMD_PRECHARGE;
+//             addr_q[ALL_BANKS]   <= 1'b1;
+//         end
+//         // 2 x REFRESH (with at least tREF wait)
+//         else if (refresh_timer_q == 20 || refresh_timer_q == 30)
+//         begin
+//             command_q <= CMD_REFRESH;
+//         end
+//         // Load mode register
+//         else if (refresh_timer_q == 10)
+//         begin
+//             command_q <= CMD_LOAD_MODE;
+//             addr_q    <= MODE_REG;
+//         end
+//         // Other cycles during init - just NOP
+//         else
+//         begin
+//             command_q   <= CMD_NOP;
+//             addr_q      <= {SDRAM_ROW_W{1'b0}};
+//             bank_q      <= {SDRAM_BANK_W{1'b0}};
+//         end
+//     end
+//     //-----------------------------------------
+//     // STATE_ACTIVATE
+//     //-----------------------------------------
+//     STATE_ACTIVATE :
+//     begin
+//         // Select a row and activate it
+//         command_q     <= CMD_ACTIVE;
+//         addr_q        <= addr_row_w;
+//         bank_q        <= addr_bank_w;
+
+//         active_row_q[addr_bank_w]  <= addr_row_w;
+//         row_open_q[addr_bank_w]    <= 1'b1;
+//     end
+//     //-----------------------------------------
+//     // STATE_PRECHARGE
+//     //-----------------------------------------
+//     STATE_PRECHARGE :
+//     begin
+//         // Precharge due to refresh, close all banks
+//         if (target_state_r == STATE_REFRESH)
+//         begin
+//             // Precharge all banks
+//             command_q           <= CMD_PRECHARGE;
+//             addr_q[ALL_BANKS]   <= 1'b1;
+//             row_open_q          <= {SDRAM_BANKS{1'b0}};
+//         end
+//         else
+//         begin
+//             // Precharge specific banks
+//             command_q           <= CMD_PRECHARGE;
+//             addr_q[ALL_BANKS]   <= 1'b0;
+//             bank_q              <= addr_bank_w;
+
+//             row_open_q[addr_bank_w] <= 1'b0;
+//         end
+//     end
+//     //-----------------------------------------
+//     // STATE_REFRESH
+//     //-----------------------------------------
+//     STATE_REFRESH :
+//     begin
+//         // Auto refresh
+//         command_q   <= CMD_REFRESH;
+//         addr_q      <= {SDRAM_ROW_W{1'b0}};
+//         bank_q      <= {SDRAM_BANK_W{1'b0}};
+//     end
+//     //-----------------------------------------
+//     // STATE_READ
+//     //-----------------------------------------
+//     STATE_READ :
+//     begin
+//         command_q   <= CMD_READ;
+//         addr_q      <= addr_col_w;
+//         bank_q      <= addr_bank_w;
+
+//         // Disable auto precharge (auto close of row)
+//         addr_q[AUTO_PRECHARGE]  <= 1'b0;
+
+//         // Read mask (all bytes in burst)
+//         dqm_q       <= {SDRAM_DQM_W{1'b0}};
+//     end
+//     //-----------------------------------------
+//     // STATE_WRITE0
+//     //-----------------------------------------
+//     STATE_WRITE0 :
+//     begin
+//         command_q       <= CMD_WRITE;
+//         addr_q          <= addr_col_w;
+//         bank_q          <= addr_bank_w;
+//         data_q          <= ram_write_data_w[15:0];
+
+//         // Disable auto precharge (auto close of row)
+//         addr_q[AUTO_PRECHARGE]  <= 1'b0;
+
+//         // Write mask
+//         dqm_q           <= ~ram_wr_w[1:0];
+//         dqm_buffer_q    <= ~ram_wr_w[3:2];
+
+//         data_rd_en_q    <= 1'b0;
+//     end
+//     //-----------------------------------------
+//     // STATE_WRITE1
+//     //-----------------------------------------
+//     STATE_WRITE1 :
+//     begin
+//         // Burst continuation
+//         command_q   <= CMD_NOP;
+
+//         data_q      <= data_buffer_q;
+
+//         // Disable auto precharge (auto close of row)
+//         addr_q[AUTO_PRECHARGE]  <= 1'b0;
+
+//         // Write mask
+//         dqm_q       <= dqm_buffer_q;
+//     end
+//     endcase
+// end
+
+// //-----------------------------------------------------------------
+// // Record read events
+// //-----------------------------------------------------------------
+// reg [SDRAM_READ_LATENCY+1:0]  rd_q;
+
+// always @ (posedge clk_i or posedge rst_i)
+// if (rst_i)
+//     rd_q    <= {(SDRAM_READ_LATENCY+2){1'b0}};
+// else
+//     rd_q    <= {rd_q[SDRAM_READ_LATENCY:0], (state_q == STATE_READ)};
+
+// //-----------------------------------------------------------------
+// // Data Buffer
+// //-----------------------------------------------------------------
+
+// // Buffer upper 16-bits of write data so write command can be accepted
+// // in WRITE0. Also buffer lower 16-bits of read data.
+// always @ (posedge clk_i or posedge rst_i)
+// if (rst_i)
+//     data_buffer_q <= 16'b0;
+// else if (state_q == STATE_WRITE0)
+//     data_buffer_q <= ram_write_data_w[31:16];
+// else if (rd_q[SDRAM_READ_LATENCY+1])
+//     data_buffer_q <= sample_data_q;
+
+// // Read data output
+// assign ram_read_data_w = {sample_data_q, data_buffer_q};
+
+// //-----------------------------------------------------------------
+// // ACK
+// //-----------------------------------------------------------------
+// reg ack_q;
+
+// always @ (posedge clk_i or posedge rst_i)
+// if (rst_i)
+//     ack_q   <= 1'b0;
+// else
+// begin
+//     if (state_q == STATE_WRITE1)
+//         ack_q <= 1'b1;
+//     else if (rd_q[SDRAM_READ_LATENCY+1])
+//         ack_q <= 1'b1;
+//     else
+//         ack_q <= 1'b0;
+// end
+
+// assign ram_ack_w = ack_q;
+
+// // Accept command in READ or WRITE0 states
+// assign ram_accept_w = (state_q == STATE_READ || state_q == STATE_WRITE0);
+
+// //-----------------------------------------------------------------
+// // SDRAM I/O
+// //-----------------------------------------------------------------
+// assign sdram_clk_o           = ~clk_i;
+// assign sdram_data_out_en_o   = ~data_rd_en_q;
+// assign sdram_data_output_o   =  data_q;
+// assign sdram_data_in_w       = sdram_data_input_i;
+
+// assign sdram_cke_o  = cke_q;
+// assign sdram_cs_o   = command_q[3];
+// assign sdram_ras_o  = command_q[2];
+// assign sdram_cas_o  = command_q[1];
+// assign sdram_we_o   = command_q[0];
+// assign sdram_dqm_o  = dqm_q;
+// assign sdram_ba_o   = bank_q;
+// assign sdram_addr_o = addr_q;
+
+// //-----------------------------------------------------------------
+// // Simulation only
+// //-----------------------------------------------------------------
+// `ifdef verilator
+// reg [79:0] dbg_state;
+
+// always @ *
+// begin
+//     case (state_q)
+//     STATE_INIT        : dbg_state = "INIT";
+//     STATE_DELAY       : dbg_state = "DELAY";
+//     STATE_IDLE        : dbg_state = "IDLE";
+//     STATE_ACTIVATE    : dbg_state = "ACTIVATE";
+//     STATE_READ        : dbg_state = "READ";
+//     STATE_READ_WAIT   : dbg_state = "READ_WAIT";
+//     STATE_WRITE0      : dbg_state = "WRITE0";
+//     STATE_WRITE1      : dbg_state = "WRITE1";
+//     STATE_PRECHARGE   : dbg_state = "PRECHARGE";
+//     STATE_REFRESH     : dbg_state = "REFRESH";
+//     default           : dbg_state = "UNKNOWN";
+//     endcase
+// end
+// `endif
+
+
+// endmodule
+
+
 module sdram_axi_core
 (
     // Inputs
@@ -42,7 +752,7 @@ module sdram_axi_core
     ,input  [  7:0]  inport_len_i
     ,input  [ 31:0]  inport_addr_i
     ,input  [ 31:0]  inport_write_data_i
-    ,input  [ 15:0]  sdram_data_input_i
+    ,input  [ 31:0]  sdram_data_input_i
 
     // Outputs
     ,output          inport_accept_o
@@ -55,10 +765,10 @@ module sdram_axi_core
     ,output          sdram_ras_o
     ,output          sdram_cas_o
     ,output          sdram_we_o
-    ,output [  1:0]  sdram_dqm_o
+    ,output [  3:0]  sdram_dqm_o
     ,output [ 12:0]  sdram_addr_o
     ,output [  1:0]  sdram_ba_o
-    ,output [ 15:0]  sdram_data_output_o
+    ,output [ 31:0]  sdram_data_output_o
     ,output          sdram_data_out_en_o
 );
 
@@ -68,15 +778,15 @@ module sdram_axi_core
 // Key Params
 //-----------------------------------------------------------------
 parameter SDRAM_MHZ              = 50;
-parameter SDRAM_ADDR_W           = 24;
-parameter SDRAM_COL_W            = 9;
+parameter SDRAM_ADDR_W           = 26;
+parameter SDRAM_COL_W            = 11;
 parameter SDRAM_READ_LATENCY     = 2;
 
 //-----------------------------------------------------------------
 // Defines / Local params
 //-----------------------------------------------------------------
 localparam SDRAM_BANK_W          = 2;
-localparam SDRAM_DQM_W           = 2;
+localparam SDRAM_DQM_W           = 4;
 localparam SDRAM_BANKS           = 2 ** SDRAM_BANK_W;
 localparam SDRAM_ROW_W           = SDRAM_ADDR_W - SDRAM_COL_W - SDRAM_BANK_W;
 localparam SDRAM_REFRESH_CNT     = 2 ** SDRAM_ROW_W;
@@ -93,8 +803,8 @@ localparam CMD_PRECHARGE     = 4'b0010;
 localparam CMD_REFRESH       = 4'b0001;
 localparam CMD_LOAD_MODE     = 4'b0000;
 
-// Mode: Burst Length = 4 bytes, CAS=2
-localparam MODE_REG          = {3'b000,1'b0,2'b00,3'b010,1'b0,3'b001};
+// Mode: Burst Length = 2 bytes, CAS=2
+localparam MODE_REG          = {3'b000,1'b0,2'b00,3'b001,1'b0,3'b001};
 
 // SM states
 localparam STATE_W           = 4;
@@ -105,14 +815,13 @@ localparam STATE_ACTIVATE    = 4'd3;
 localparam STATE_READ        = 4'd4;
 localparam STATE_READ_WAIT   = 4'd5;
 localparam STATE_WRITE0      = 4'd6;
-localparam STATE_WRITE1      = 4'd7;
 localparam STATE_PRECHARGE   = 4'd8;
 localparam STATE_REFRESH     = 4'd9;
 
 localparam AUTO_PRECHARGE    = 10;
 localparam ALL_BANKS         = 10;
 
-localparam SDRAM_DATA_W      = 16;
+localparam SDRAM_DATA_W      = 32;
 
 localparam CYCLE_TIME_NS     = 1000 / SDRAM_MHZ;
 
@@ -160,9 +869,6 @@ reg                    cke_q;
 reg [SDRAM_BANK_W-1:0] bank_q;
 
 // Buffer half word during read and write commands
-reg [SDRAM_DATA_W-1:0] data_buffer_q;
-reg [SDRAM_DQM_W-1:0]  dqm_buffer_q;
-
 wire [SDRAM_DATA_W-1:0] sdram_data_in_w;
 
 reg                    refresh_q;
@@ -177,7 +883,7 @@ reg  [STATE_W-1:0]     target_state_q;
 reg  [STATE_W-1:0]     delay_state_q;
 
 // Address bits
-wire [SDRAM_ROW_W-1:0]  addr_col_w  = {{(SDRAM_ROW_W-SDRAM_COL_W){1'b0}}, ram_addr_w[SDRAM_COL_W:2], 1'b0};
+wire [SDRAM_ROW_W-1:0]  addr_col_w  = {{(SDRAM_ROW_W - SDRAM_COL_W + 1){1'b0}}, ram_addr_w[SDRAM_COL_W:2]};
 wire [SDRAM_ROW_W-1:0]  addr_row_w  = ram_addr_w[SDRAM_ADDR_W:SDRAM_COL_W+2+1];
 wire [SDRAM_BANK_W-1:0] addr_bank_w = ram_addr_w[SDRAM_COL_W+2:SDRAM_COL_W+2-1];
 
@@ -283,16 +989,9 @@ begin
     // STATE_WRITE0
     //-----------------------------------------
     STATE_WRITE0 :
-    begin
-        next_state_r = STATE_WRITE1;
-    end
-    //-----------------------------------------
-    // STATE_WRITE1
-    //-----------------------------------------
-    STATE_WRITE1 :
     begin
         next_state_r = STATE_IDLE;
-
+        
         // Another pending write request (with no refresh pending)
         if (!refresh_q && ram_req_w && (ram_wr_w != 4'b0))
         begin
@@ -301,6 +1000,7 @@ begin
                 next_state_r = STATE_WRITE0;
         end
     end
+
     //-----------------------------------------
     // STATE_PRECHARGE
     //-----------------------------------------
@@ -460,19 +1160,12 @@ else if (state_q == STATE_REFRESH)
 // Input sampling
 //-----------------------------------------------------------------
 
-reg [SDRAM_DATA_W-1:0] sample_data0_q;
-always @ (posedge clk_i or posedge rst_i)
-if (rst_i)
-    sample_data0_q <= {SDRAM_DATA_W{1'b0}};
-else
-    sample_data0_q <= sdram_data_in_w;
-
 reg [SDRAM_DATA_W-1:0] sample_data_q;
 always @ (posedge clk_i or posedge rst_i)
 if (rst_i)
     sample_data_q <= {SDRAM_DATA_W{1'b0}};
 else
-    sample_data_q <= sample_data0_q;
+    sample_data_q <= sdram_data_in_w;
 
 //-----------------------------------------------------------------
 // Command Output
@@ -483,13 +1176,12 @@ always @ (posedge clk_i or posedge rst_i)
 if (rst_i)
 begin
     command_q       <= CMD_NOP;
-    data_q          <= 16'b0;
+    data_q          <= 32'b0;
     addr_q          <= {SDRAM_ROW_W{1'b0}};
     bank_q          <= {SDRAM_BANK_W{1'b0}};
     cke_q           <= 1'b0;
     dqm_q           <= {SDRAM_DQM_W{1'b0}};
     data_rd_en_q    <= 1'b1;
-    dqm_buffer_q    <= {SDRAM_DQM_W{1'b0}};
 
     for (idx=0;idx<SDRAM_BANKS;idx=idx+1)
         active_row_q[idx] <= {SDRAM_ROW_W{1'b0}};
@@ -616,33 +1308,16 @@ begin
         command_q       <= CMD_WRITE;
         addr_q          <= addr_col_w;
         bank_q          <= addr_bank_w;
-        data_q          <= ram_write_data_w[15:0];
+        data_q          <= ram_write_data_w;
 
         // Disable auto precharge (auto close of row)
         addr_q[AUTO_PRECHARGE]  <= 1'b0;
 
         // Write mask
-        dqm_q           <= ~ram_wr_w[1:0];
-        dqm_buffer_q    <= ~ram_wr_w[3:2];
+        dqm_q           <= ~ram_wr_w[3:0];
 
         data_rd_en_q    <= 1'b0;
     end
-    //-----------------------------------------
-    // STATE_WRITE1
-    //-----------------------------------------
-    STATE_WRITE1 :
-    begin
-        // Burst continuation
-        command_q   <= CMD_NOP;
-
-        data_q      <= data_buffer_q;
-
-        // Disable auto precharge (auto close of row)
-        addr_q[AUTO_PRECHARGE]  <= 1'b0;
-
-        // Write mask
-        dqm_q       <= dqm_buffer_q;
-    end
     endcase
 end
 
@@ -661,18 +1336,8 @@ else
 // Data Buffer
 //-----------------------------------------------------------------
 
-// Buffer upper 16-bits of write data so write command can be accepted
-// in WRITE0. Also buffer lower 16-bits of read data.
-always @ (posedge clk_i or posedge rst_i)
-if (rst_i)
-    data_buffer_q <= 16'b0;
-else if (state_q == STATE_WRITE0)
-    data_buffer_q <= ram_write_data_w[31:16];
-else if (rd_q[SDRAM_READ_LATENCY+1])
-    data_buffer_q <= sample_data_q;
-
 // Read data output
-assign ram_read_data_w = {sample_data_q, data_buffer_q};
+assign ram_read_data_w = sample_data_q;
 
 //-----------------------------------------------------------------
 // ACK
@@ -684,7 +1349,7 @@ if (rst_i)
     ack_q   <= 1'b0;
 else
 begin
-    if (state_q == STATE_WRITE1)
+    if (state_q == STATE_WRITE0 & ~ack_q)
         ack_q <= 1'b1;
     else if (rd_q[SDRAM_READ_LATENCY+1])
         ack_q <= 1'b1;
@@ -730,7 +1395,6 @@ begin
     STATE_READ        : dbg_state = "READ";
     STATE_READ_WAIT   : dbg_state = "READ_WAIT";
     STATE_WRITE0      : dbg_state = "WRITE0";
-    STATE_WRITE1      : dbg_state = "WRITE1";
     STATE_PRECHARGE   : dbg_state = "PRECHARGE";
     STATE_REFRESH     : dbg_state = "REFRESH";
     default           : dbg_state = "UNKNOWN";
diff --git a/perip/sdram/sdram.v b/perip/sdram/sdram.v
index 3613b231..6c82222f 100644
--- a/perip/sdram/sdram.v
+++ b/perip/sdram/sdram.v
@@ -1,4 +1,10 @@
+import "DPI-C" function void sdram_row_load(input byte bank, input shortint row, output shortint data[], input byte raw, input bit group);
+import "DPI-C" function void sdram_row_store(input byte bank, input shortint row, input shortint data[], input byte raw, input bit group);
+
+
 module sdram(
+  input [7:0]  raw,
+  input        word,
   input        clk,
   input        cke,
   input        cs,
@@ -10,7 +16,92 @@ module sdram(
   input [ 1:0] dqm,
   inout [15:0] dq
 );
+  typedef shortint row_t[512];
+  
+  row_t rows[4];
+  wire [3:0] cmd = {cs, ras, cas, we};
+
+  reg [2:0] burst_length, cas_latency;
+  reg [12:0] row [3:0];
+  reg [3:0] row_act;
+
+  reg rct;
+
+  // mode register set
+  always @(posedge clk) begin
+      if (cke) begin
+        if (cmd == 4'b000) begin
+          burst_length <= a[2:0];
+          cas_latency <= a[6:4];
+        end
+      end
+  end
+
+  // active and precharge
+  always @(posedge clk) begin
+    if (cke) begin
+      if (cmd == 4'b0011) begin // active
+        if (row_act[ba]) begin
+          $fwrite(32'h80000002, "SDRAM ACTIVE ERR: addr:%h  bank:%b\n", a, ba);
+          $fatal;
+        end
+        row[ba] <= a[12:0];
+        row_act[ba] <= 1'b1;
+        sdram_row_load({6'b0, ba}, {3'b0, a[12:0]}, rows[ba], raw, word);
+      end 
+      else if (cmd == 4'b0010) begin // precharge
+        if (a[10]) begin
+          if (row_act[0]) sdram_row_store({6'b0, 2'd0}, {3'b0, row[0]}, rows[0], raw, word);
+          if (row_act[1]) sdram_row_store({6'b0, 2'd1}, {3'b0, row[1]}, rows[1], raw, word);
+          if (row_act[2]) sdram_row_store({6'b0, 2'd2}, {3'b0, row[2]}, rows[2], raw, word);
+          if (row_act[3]) sdram_row_store({6'b0, 2'd3}, {3'b0, row[3]}, rows[3], raw, word);
+          row_act <= 4'b0;
+        end 
+        else begin
+          if (row_act[ba]) sdram_row_store({6'b0, ba}, {3'b0, row[ba]}, rows[ba], raw, word);
+          row_act[ba] <= 1'b0;
+        end
+      end  
+    end
+  end
+
+  // send | recv data
+  assign dq = rct & ~(word ^ wei) ? (rdata & ~wmask) : 16'bz;
+
+  // read
+  reg [15:0] rdata;
+  reg wei, rwait;
+  always @(posedge clk) begin
+    if (cke) begin
+      // read start
+      if (cmd == 4'b0101) begin
+        rdata <= rows[ba][a[8:0]];
+        wei <= a[9];
+        rct <= 1;
+        rwait <= 1'b0;
+      end
+
+      // read end
+      if (rct & ~rwait)
+        rwait <= 1;
+      else if (rct & rwait & cmd != 4'b0101) begin
+        rct <= 0;
+        rwait <= 0;
+      end
+    end
+  end
 
-  assign dq = 16'bz;
+  // write
+  wire [9:0]  waddr = a[9:0];  // {6'b0, count};突发传输 fix it
+  wire [15:0] wmask = {{8{dqm[1]}}, {8{dqm[0]}}};
+  wire [15:0] wdata = (wmask & rows[ba][waddr[8:0]]) | (~wmask & dq);
+  always @(posedge clk) begin
+    if (cke) begin
+      // write start
+      if (cmd == 4'b0100 & ~(word ^ waddr[9])) begin
+        rows[ba][waddr[8:0]] <= wdata;
+      end
+    end
+  end
 
 endmodule
diff --git a/perip/sdram/sdram_top_apb.v b/perip/sdram/sdram_top_apb.v
index 3bc5b93b..e1f0f1b5 100644
--- a/perip/sdram/sdram_top_apb.v
+++ b/perip/sdram/sdram_top_apb.v
@@ -1,3 +1,85 @@
+// module sdram_top_apb (
+//   input         clock,
+//   input         reset,
+//   input  [31:0] in_paddr,
+//   input         in_psel,
+//   input         in_penable,
+//   input  [2:0]  in_pprot,
+//   input         in_pwrite,
+//   input  [31:0] in_pwdata,
+//   input  [3:0]  in_pstrb,
+//   output        in_pready,
+//   output [31:0] in_prdata,
+//   output        in_pslverr,
+
+//   output        sdram_clk,
+//   output        sdram_cke,
+//   output        sdram_cs,
+//   output        sdram_ras,
+//   output        sdram_cas,
+//   output        sdram_we,
+//   output [12:0] sdram_a,
+//   output [ 1:0] sdram_ba,
+//   output [ 1:0] sdram_dqm,
+//   inout  [15:0] sdram_dq
+// );
+
+//   wire sdram_dout_en;
+//   wire [15:0] sdram_dout;
+//   assign sdram_dq = sdram_dout_en ? sdram_dout : 16'bz;
+
+//   typedef enum [1:0] { ST_IDLE, ST_WAIT_ACCEPT, ST_WAIT_ACK } state_t;
+//   reg [1:0] state;
+//   wire req_accept;
+
+//   always @(posedge clock) begin
+//     if (reset) state <= ST_IDLE;
+//     else
+//       case (state)
+//         ST_IDLE: state <= (is_read || is_write ? (req_accept ? ST_WAIT_ACK : ST_WAIT_ACCEPT) : ST_IDLE);
+//         ST_WAIT_ACCEPT: state <= req_accept ? ST_WAIT_ACK : ST_WAIT_ACCEPT;
+//         ST_WAIT_ACK: if (in_pready) state <= ST_IDLE;
+//         default: state <= state;
+//       endcase
+//   end
+
+//   wire is_read  = ((in_psel && !in_penable) || (state == ST_WAIT_ACCEPT)) && !in_pwrite;
+//   wire is_write = ((in_psel && !in_penable) || (state == ST_WAIT_ACCEPT)) &&  in_pwrite;
+//   sdram_axi_core #(
+//     .SDRAM_MHZ(100),
+//     .SDRAM_ADDR_W(24),
+//     .SDRAM_COL_W(9),
+//     .SDRAM_READ_LATENCY(2)
+//   ) u_sdram_ctrl(
+//     .clk_i(clock),
+//     .rst_i(reset),
+//     .inport_wr_i(is_write ? in_pstrb : 4'b0),
+//     .inport_rd_i(is_read),
+//     .inport_len_i(0),
+//     .inport_addr_i(in_paddr),
+//     .inport_write_data_i(in_pwdata),
+//     .inport_accept_o(req_accept),
+//     .inport_ack_o(in_pready),
+//     .inport_error_o(in_pslverr),
+//     .inport_read_data_o(in_prdata),
+
+//     .sdram_clk_o(sdram_clk),
+//     .sdram_cke_o(sdram_cke),
+//     .sdram_cs_o(sdram_cs),
+//     .sdram_ras_o(sdram_ras),
+//     .sdram_cas_o(sdram_cas),
+//     .sdram_we_o(sdram_we),
+//     .sdram_dqm_o(sdram_dqm),
+//     .sdram_addr_o(sdram_a),
+//     .sdram_ba_o(sdram_ba),
+//     .sdram_data_input_i(sdram_dq),
+//     .sdram_data_output_o(sdram_dout),
+//     .sdram_data_out_en_o(sdram_dout_en)
+//   );
+
+// endmodule
+
+
 module sdram_top_apb (
   input         clock,
   input         reset,
@@ -20,13 +102,13 @@ module sdram_top_apb (
   output        sdram_we,
   output [12:0] sdram_a,
   output [ 1:0] sdram_ba,
-  output [ 1:0] sdram_dqm,
-  inout  [15:0] sdram_dq
+  output [ 3:0] sdram_dqm,
+  inout  [31:0] sdram_dq
 );
 
   wire sdram_dout_en;
-  wire [15:0] sdram_dout;
-  assign sdram_dq = sdram_dout_en ? sdram_dout : 16'bz;
+  wire [31:0] sdram_dout;
+  assign sdram_dq = sdram_dout_en ? sdram_dout : 32'bz;
 
   typedef enum [1:0] { ST_IDLE, ST_WAIT_ACCEPT, ST_WAIT_ACK } state_t;
   reg [1:0] state;
@@ -47,9 +129,9 @@ module sdram_top_apb (
   wire is_write = ((in_psel && !in_penable) || (state == ST_WAIT_ACCEPT)) &&  in_pwrite;
   sdram_axi_core #(
     .SDRAM_MHZ(100),
-    .SDRAM_ADDR_W(24),
-    .SDRAM_COL_W(9),
-    .SDRAM_READ_LATENCY(2)
+    .SDRAM_ADDR_W(26),
+    .SDRAM_COL_W(11),
+    .SDRAM_READ_LATENCY(0)
   ) u_sdram_ctrl(
     .clk_i(clock),
     .rst_i(reset),
diff --git a/perip/sdram/sdram_top_axi.v b/perip/sdram/sdram_top_axi.v
index f0fd6fdb..8067df6d 100644
--- a/perip/sdram/sdram_top_axi.v
+++ b/perip/sdram/sdram_top_axi.v
@@ -39,18 +39,18 @@ module sdram_top_axi(
   output        sdram_we,
   output [12:0] sdram_a,
   output [ 1:0] sdram_ba,
-  output [ 1:0] sdram_dqm,
-  inout  [15:0] sdram_dq
+  output [ 3:0] sdram_dqm,
+  inout  [31:0] sdram_dq
 );
 
   wire sdram_dout_en;
-  wire [15:0] sdram_dout;
-  assign sdram_dq = sdram_dout_en ? sdram_dout : 16'bz;
+  wire [31:0] sdram_dout;
+  assign sdram_dq = sdram_dout_en ? sdram_dout : 32'bz;
   sdram_axi #(
     .SDRAM_MHZ(100),
-    .SDRAM_ADDR_W(24),
-    .SDRAM_COL_W(9),
-    .SDRAM_READ_LATENCY(2)
+    .SDRAM_ADDR_W(26),
+    .SDRAM_COL_W(11),
+    .SDRAM_READ_LATENCY(0)
   ) u_sdram_axi(
     .clk_i(clock),
     .rst_i(reset),
diff --git a/perip/spi/rtl/spi_top.v b/perip/spi/rtl/spi_top.v
index 73af8756..e8b8d794 100644
--- a/perip/spi/rtl/spi_top.v
+++ b/perip/spi/rtl/spi_top.v
@@ -48,7 +48,9 @@ module spi_top
   wb_we_i, wb_stb_i, wb_cyc_i, wb_ack_o, wb_err_o, wb_int_o,
 
   // SPI signals
-  ss_pad_o, sclk_pad_o, mosi_pad_o, miso_pad_i
+  ss_pad_o, sclk_pad_o, mosi_pad_o, miso_pad_i,
+
+  output go_bsy
 );
 
   parameter Tp = 1;
@@ -99,6 +101,8 @@ module spi_top
   wire                             neg_edge;         // recognize negedge of sclk
   wire                             last_bit;         // marks last character bit
 
+  assign go_bsy = ctrl[8];
+
   // Address decoder
   assign spi_divider_sel = wb_cyc_i & wb_stb_i & (wb_adr_i[`SPI_OFS_BITS] == `SPI_DEVIDE);
   assign spi_ctrl_sel    = wb_cyc_i & wb_stb_i & (wb_adr_i[`SPI_OFS_BITS] == `SPI_CTRL);
diff --git a/perip/spi/rtl/spi_top_apb.v b/perip/spi/rtl/spi_top_apb.v
index 92d37516..79b92ce5 100644
--- a/perip/spi/rtl/spi_top_apb.v
+++ b/perip/spi/rtl/spi_top_apb.v
@@ -29,44 +29,210 @@ module spi_top_apb #(
 
 `ifdef FAST_FLASH
 
-wire [31:0] data;
-parameter invalid_cmd = 8'h0;
-flash_cmd flash_cmd_i(
-  .clock(clock),
-  .valid(in_psel && !in_penable),
-  .cmd(in_pwrite ? invalid_cmd : 8'h03),
-  .addr({8'b0, in_paddr[23:2], 2'b0}),
-  .data(data)
-);
-assign spi_sck    = 1'b0;
-assign spi_ss     = 8'b0;
-assign spi_mosi   = 1'b1;
-assign spi_irq_out= 1'b0;
-assign in_pslverr = 1'b0;
-assign in_pready  = in_penable && in_psel && !in_pwrite;
-assign in_prdata  = data[31:0];
-
+  wire [31:0] data;
+  parameter invalid_cmd = 8'h0;
+  flash_cmd flash_cmd_i(
+    .clock(clock),
+    .valid(in_psel && !in_penable),
+    .cmd(in_pwrite ? invalid_cmd : 8'h03),
+    .addr({8'b0, in_paddr[23:2], 2'b0}),
+    .data(data)
+  );
+  assign spi_sck    = 1'b0;
+  assign spi_ss     = 8'b0;
+  assign spi_mosi   = 1'b1;
+  assign spi_irq_out= 1'b0;
+  assign in_pslverr = 1'b0;
+  assign in_pready  = in_penable && in_psel && !in_pwrite;
+  assign in_prdata  = data[31:0];
 `else
 
-spi_top u0_spi_top (
-  .wb_clk_i(clock),
-  .wb_rst_i(reset),
-  .wb_adr_i(in_paddr[4:0]),
-  .wb_dat_i(in_pwdata),
-  .wb_dat_o(in_prdata),
-  .wb_sel_i(in_pstrb),
-  .wb_we_i (in_pwrite),
-  .wb_stb_i(in_psel),
-  .wb_cyc_i(in_penable),
-  .wb_ack_o(in_pready),
-  .wb_err_o(in_pslverr),
-  .wb_int_o(spi_irq_out),
-
-  .ss_pad_o(spi_ss),
-  .sclk_pad_o(spi_sck),
-  .mosi_pad_o(spi_mosi),
-  .miso_pad_i(spi_miso)
-);
+  wire is_flash = in_paddr[31:24] == 8'h30;
+  wire flash_ack;
+  reg [4:0] flash_addr;
+  reg [31:0] flash_wdata;
+  reg [31:0] flash_rdata;
+  reg [3:0] flash_strb;
+  reg flash_wen;
+  reg flash_stb;
+  reg flash_cyc;
+  reg flash_err;
+  reg flash_int;
+  
+  wire go_bsy;
+  reg flash_cready;
+  reg flash_cerr;
+
+  reg [6:0] flash_ctrl;
+  always @(posedge clock) begin
+    if (reset) begin
+      flash_addr <= 0; flash_wdata <= 0;
+      flash_strb <= 0; flash_cready <= 0;
+      flash_wen <= 0; flash_stb <= 0;
+      flash_cyc <= 0; flash_ctrl <= 0;
+      flash_cerr <= 0; flash_rdata <= 0;
+    end
+    else begin
+      // 进入 xip 模式
+      // 写入 ctrl 寄存器
+      if (is_flash & ~(|flash_ctrl) & in_psel) begin
+        flash_addr <= 5'h10;
+        flash_wdata <= 32'h00002040;
+        flash_strb <= 4'b1111;
+        flash_wen <= 1'b1;
+        flash_stb <= 1'b1;
+        flash_cyc <= 1'b1;
+        flash_ctrl[0] <= 1'b1;
+      end
+      
+      // 写入 divider 寄存器
+      if (flash_ctrl[0] & flash_ack) begin
+        flash_addr <= 5'h14;
+        flash_wdata <= 32'h00000001;
+        flash_strb <= 4'b1111;
+        flash_wen <= 1'b1;
+        flash_stb <= 1'b1;
+        flash_cyc <= 1'b1;
+        flash_ctrl[0] <= 1'b0;
+        flash_ctrl[1] <= 1'b1;
+      end
+
+      // 写入 ss 寄存器
+      if (flash_ctrl[1] & flash_ack) begin
+        flash_addr <= 5'h18;
+        flash_wdata <= 32'h00000001;
+        flash_strb <= 4'b1111;
+        flash_wen <= 1'b1;
+        flash_stb <= 1'b1;
+        flash_cyc <= 1'b1;
+        flash_ctrl[1] <= 1'b0;
+        flash_ctrl[2] <= 1'b1;
+      end
+
+      // 写入 读取地址=>TX 寄存器
+      if (flash_ctrl[2] & flash_ack) begin
+        flash_addr <= 5'h4;
+        flash_wdata <= {8'h03, in_paddr[23:0]};
+        flash_strb <= 4'b1111;
+        flash_wen <= 1'b1;
+        flash_stb <= 1'b1;
+        flash_cyc <= 1'b1;
+        flash_rdata <= 0;
+        flash_ctrl[2] <= 1'b0;
+        flash_ctrl[3] <= 1'b1;
+      end
+
+      // GO_BSY (ctrl : 8) <= 1
+      if (flash_ctrl[3] & flash_ack) begin
+        flash_addr <= 5'h11;
+        flash_wdata <= 32'h00002100;
+        flash_strb <= 4'b0010;
+        flash_wen <= 1'b1;
+        flash_stb <= 1'b1;
+        flash_cyc <= 1'b1;
+        flash_ctrl[3] <= 0;
+        flash_ctrl[4] <= 1;
+      end
+
+      // 写入完成，开始等待
+      if (flash_ctrl[4] & flash_ack) begin
+        flash_addr <= 0;
+        flash_wdata <= 0;
+        flash_strb <= 0;
+        flash_wen <= 0;
+        flash_stb <= 0;
+        flash_cyc <= 0;
+        flash_ctrl[4] <= 0;
+        flash_ctrl[5] <= 1;
+      end
+
+      // flash 读取完成，开始读取 RX
+      if (flash_ctrl[5] & ~go_bsy) begin
+        flash_addr <= 5'h00;
+        flash_strb <= 4'b0000;
+        flash_wen <= 1'b0;
+        flash_stb <= 1'b1;
+        flash_cyc <= 1'b1;
+        flash_ctrl[5] <= 0;
+        flash_ctrl[6] <= 1;
+      end
+
+      // 读取 flash 结束，返回值
+      if (flash_ctrl[6] & flash_ack) begin
+        flash_addr <= 0;
+        flash_wdata <= 0;
+        flash_strb <= 0;
+        flash_wen <= 0;
+        flash_stb <= 0;
+        flash_cyc <= 0;
+        flash_cready <= 1'b1;
+        flash_rdata <= wb_dat_to;
+        flash_cerr <= flash_err;
+      end
+
+      // 数据读取结束
+      if (in_psel & flash_cready) begin
+        flash_ctrl[6] <= 0;
+        flash_cready <= 1'b0;
+      end 
+    end
+  end
+
+
+  // 定义条件选择的信号
+  wire [4:0] wb_adr_t       = is_flash ? flash_addr : in_paddr[4:0];
+  wire [31:0] wb_dat_ti     = is_flash ? flash_wdata : in_pwdata;
+  
+  wire [31:0] wb_dat_to;
+  assign in_prdata = ~is_flash ? wb_dat_to : {flash_rdata[7:0], flash_rdata[15:8], flash_rdata[23:16], flash_rdata[31:24]};
+
+  wire [3:0] wb_sel_t       = is_flash ? flash_strb : in_pstrb;
+  wire wb_we_t              = is_flash ? flash_wen : in_pwrite;
+  wire wb_stb_t             = is_flash ? flash_stb : in_psel;
+  wire wb_cyc_t             = is_flash ? flash_cyc : in_penable;
+  
+  wire wb_ack_o_t;
+  assign flash_ack = is_flash ? wb_ack_o_t : 1'bz;
+  assign in_pready = ~is_flash ? wb_ack_o_t : flash_cready;
+
+  wire wb_err_o_t;
+  assign flash_err = is_flash ? wb_err_o_t : 1'bz;
+  assign in_pslverr = ~is_flash ? wb_err_o_t : flash_cerr;
+
+  wire wb_int_o_t;
+  assign flash_int = is_flash ? wb_int_o_t : 1'bz;
+  assign spi_irq_out = ~is_flash ? wb_int_o_t : 1'bz;
+
+  spi_top u0_spi_top (
+    .wb_clk_i(clock),
+    .wb_rst_i(reset),
+    .wb_adr_i(wb_adr_t),
+    .wb_dat_i(wb_dat_ti),
+    .wb_dat_o(wb_dat_to),
+    .wb_sel_i(wb_sel_t),
+    .wb_we_i (wb_we_t),
+    .wb_stb_i(wb_stb_t),
+    .wb_cyc_i(wb_cyc_t),
+    .wb_ack_o(wb_ack_o_t),
+    .wb_err_o(wb_err_o_t),
+    .wb_int_o(wb_int_o_t),
+
+    .ss_pad_o(spi_ss),
+    .sclk_pad_o(spi_sck),
+    .mosi_pad_o(spi_mosi),
+    .miso_pad_i(spi_miso),
+
+    .go_bsy (go_bsy)
+  );
+
+  // always @(posedge clock) begin
+  //   if (is_flash) begin
+  //     $display("flash:%b, addr: %h, wdata:%h, rdata:%h", is_flash, wb_adr_t, wb_dat_ti, wb_dat_to);
+  //     $display("char:%b, wen:%b, stb:%b, cyc:%b, ack:%b, go_bsy:%b", wb_sel_t, wb_we_t, wb_stb_t, wb_cyc_t, wb_ack_o_t, go_bsy);
+  //     $display("sel:%b, pready:%b, prdata:%h, flash_ctrl:%b",in_psel, in_pready, in_prdata, flash_ctrl);
+  //     $display("----------------------------------------------------------------------------------------");
+  //   end
+  // end
 
 `endif // FAST_FLASH
 
diff --git a/perip/vga/vga_top_apb.v b/perip/vga/vga_top_apb.v
index 5c74cfbe..975a6af9 100644
--- a/perip/vga/vga_top_apb.v
+++ b/perip/vga/vga_top_apb.v
@@ -1,3 +1,72 @@
+module vga_ctrl(
+    input           pclk,     //25MHz时钟
+    input           reset,    //置位
+    input  [23:0]   vga_data, //上层模块提供的VGA颜色数据
+    output [9:0]    h_addr,   //提供给上层模块的当前扫描像素点坐标
+    output [9:0]    v_addr,
+    output          hsync,    //行同步和列同步信号
+    output          vsync,
+    output          valid,    //消隐信号
+    output [7:0]    vga_r,    //红绿蓝颜色信号
+    output [7:0]    vga_g,
+    output [7:0]    vga_b
+    );
+
+  //640x480分辨率下的VGA参数设置
+  parameter    h_frontporch = 96;
+  parameter    h_active = 144;
+  parameter    h_backporch = 784;
+  parameter    h_total = 800;
+
+  parameter    v_frontporch = 2;
+  parameter    v_active = 35;
+  parameter    v_backporch = 515;
+  parameter    v_total = 525;
+
+  //像素计数值
+  reg [9:0]    x_cnt;
+  reg [9:0]    y_cnt;
+  wire         h_valid;
+  wire         v_valid;
+
+  always @(posedge pclk) //行像素计数
+      if (reset == 1'b1)
+        x_cnt <= 1;
+      else
+      begin
+        if (x_cnt == h_total)
+            x_cnt <= 1;
+        else
+            x_cnt <= x_cnt + 10'd1;
+      end
+
+  always @(posedge pclk)  //列像素计数
+      if (reset == 1'b1)
+        y_cnt <= 1;
+      else
+      begin
+        if (y_cnt == v_total & x_cnt == h_total)
+            y_cnt <= 1;
+        else if (x_cnt == h_total)
+            y_cnt <= y_cnt + 10'd1;
+      end
+  //生成同步信号
+  assign hsync = (x_cnt > h_frontporch);
+  assign vsync = (y_cnt > v_frontporch);
+  //生成消隐信号
+  assign h_valid = (x_cnt > h_active) & (x_cnt <= h_backporch);
+  assign v_valid = (y_cnt > v_active) & (y_cnt <= v_backporch);
+  assign valid = h_valid & v_valid;
+  //计算当前有效像素坐标
+  assign h_addr = h_valid ? (x_cnt - 10'd145) : {10{1'b0}};
+  assign v_addr = v_valid ? (y_cnt - 10'd36) : {10{1'b0}};
+  //设置输出的颜色值
+  assign vga_r = vga_data[23:16];
+  assign vga_g = vga_data[15:8];
+  assign vga_b = vga_data[7:0];
+endmodule
+
+
 module vga_top_apb(
   input         clock,
   input         reset,
@@ -19,5 +88,49 @@ module vga_top_apb(
   output        vga_vsync,
   output        vga_valid
 );
+  reg [23:0] vga_buffer [32'h4B000]; 
+  reg ready;
+
+  wire [9:0] h_addr;
+  wire [9:0] v_addr;
+  
+  assign in_pready = ready;
+
+  always @(posedge clock) begin
+      if (reset) begin
+        ready <= 0;
+      end
+      else if (in_pwrite & in_penable & in_psel) begin
+        vga_buffer[{10'b0, in_paddr[23:2]}] <= in_pwdata[23:0];
+        ready <= 1;
+      end
+      else ready <= 0;
+  end
+
+  wire [31:0] pixel_index = ( {22'b0, v_addr} << 9 ) + ( {22'b0, v_addr} << 7 ) + {22'b0, h_addr};
+  wire [23:0] vga_data = vga_buffer[pixel_index];
 
+  vga_ctrl #(
+    .h_frontporch 	(96   ),
+    .h_active     	(144  ),
+    .h_backporch  	(784  ),
+    .h_total      	(800  ),
+    .v_frontporch 	(2    ),
+    .v_active     	(35   ),
+    .v_backporch  	(515  ),
+    .v_total      	(525  ))
+  u_vga_ctrl(
+    .pclk     	(clock     ),
+    .reset    	(reset     ),
+    .vga_data 	(vga_data  ),
+    .h_addr   	(h_addr    ),
+    .v_addr   	(v_addr    ),
+    .hsync    	(vga_hsync     ),
+    .vsync    	(vga_vsync     ),
+    .valid    	(vga_valid     ),
+    .vga_r    	(vga_r     ),
+    .vga_g    	(vga_g     ),
+    .vga_b    	(vga_b     )
+  );
+  
 endmodule
diff --git a/src/CPU.scala b/src/CPU.scala
index 7559195f..5df78ba4 100644
--- a/src/CPU.scala
+++ b/src/CPU.scala
@@ -13,7 +13,7 @@ object CPUAXI4BundleParameters {
   def apply() = AXI4BundleParameters(addrBits = 32, dataBits = 32, idBits = ChipLinkParam.idBits)
 }
 
-class ysyx_00000000 extends BlackBox {
+class ysyx_25040111 extends BlackBox {
   val io = IO(new Bundle {
     val clock = Input(Clock())
     val reset = Input(Reset())
@@ -35,7 +35,7 @@ class CPU(idBits: Int)(implicit p: Parameters) extends LazyModule {
     val interrupt = IO(Input(Bool()))
     val slave = IO(Flipped(AXI4Bundle(CPUAXI4BundleParameters())))
 
-    val cpu = Module(new ysyx_00000000)
+    val cpu = Module(new ysyx_25040111)
     cpu.io.clock := clock
     cpu.io.reset := reset
     cpu.io.io_interrupt := interrupt
diff --git a/src/SoC.scala b/src/SoC.scala
index 1c65cd87..a316a364 100644
--- a/src/SoC.scala
+++ b/src/SoC.scala
@@ -2,6 +2,7 @@ package ysyx
 
 import chisel3._
 import chisel3.util._
+import chisel3.experimental._
 
 import freechips.rocketchip.diplomacy._
 import org.chipsalliance.cde.config.Parameters
@@ -102,6 +103,29 @@ class ysyxSoCASIC(implicit p: Parameters) extends LazyModule {
 
 class ysyxSoCFPGA(implicit p: Parameters) extends ChipLinkSlave
 
+class SdramDQSplitter extends BlackBox with HasBlackBoxInline {
+  val io = IO(new Bundle {
+    val dq32  = Analog(32.W)
+    val dq_low  = Analog(16.W)
+    val dq_high = Analog(16.W)
+    val cmd = Input(UInt(4.W))
+  })
+
+  // 内联 Verilog 定义（方便集成，不用单独放 .v 文件）
+  setInline("SdramDQSplitter.v",
+    """module SdramDQSplitter (
+      |  inout  [31:0] dq32,
+      |  inout  [15:0] dq_low,
+      |  inout  [15:0] dq_high,
+      |  input  [3:0] cmd
+      |);
+      |  assign dq_low  =  cmd == 4'b0100 ? dq32[15:0]  : 16'hzzzz;
+      |  assign dq_high =  cmd == 4'b0100 ? dq32[31:16] : 16'hzzzz;
+      |  assign dq32[15:0]  = cmd == 4'b0111 ? dq_low : 16'hzzzz;
+      |  assign dq32[31:16] = cmd == 4'b0111 ? dq_high : 16'hzzzz;
+      |endmodule
+      |""".stripMargin)
+}
 
 class ysyxSoCFull(implicit p: Parameters) extends LazyModule {
   val asic = LazyModule(new ysyxSoCASIC)
@@ -142,8 +166,48 @@ class ysyxSoCFull(implicit p: Parameters) extends LazyModule {
 
     val psram = Module(new psram)
     psram.io <> masic.psram
-    val sdram = Module(new sdram)
-    sdram.io <> masic.sdram
+
+    val sdram0 = Module(new sdram)
+    val sdram1 = Module(new sdram)
+    val sdram2 = Module(new sdram)
+    val sdram3 = Module(new sdram)
+
+    // 中间模块：拆分 dq
+    val dqsplit = Module(new SdramDQSplitter)
+
+    // 连接顶层 32 位DQ 到分离模块
+    attach(masic.sdram.dq, dqsplit.io.dq32)
+    dqsplit.io.cmd := Cat(masic.sdram.cs, masic.sdram.ras, masic.sdram.cas, masic.sdram.we)
+
+    // 公共控制信号
+    for (m <- Seq(sdram0, sdram1, sdram2, sdram3)) {
+      m.io.clk := masic.sdram.clk
+      m.io.cke := masic.sdram.cke
+      m.io.cs  := masic.sdram.cs
+      m.io.ras := masic.sdram.ras
+      m.io.cas := masic.sdram.cas
+      m.io.we  := masic.sdram.we
+      m.io.a   := masic.sdram.a
+      m.io.ba  := masic.sdram.ba
+    }
+
+    // dqm 和 dq 对应关系，与原 Verilog 一模一样
+    sdram0.io.dqm := masic.sdram.dqm(1,0)
+    sdram1.io.dqm := masic.sdram.dqm(3,2)
+    sdram2.io.dqm := masic.sdram.dqm(1,0)
+    sdram3.io.dqm := masic.sdram.dqm(3,2)
+
+    // raw / word
+    sdram0.io.raw := 0.U(8.W); sdram0.io.word := false.B
+    sdram1.io.raw := 1.U(8.W); sdram1.io.word := false.B
+    sdram2.io.raw := 0.U(8.W); sdram2.io.word := true.B
+    sdram3.io.raw := 1.U(8.W); sdram3.io.word := true.B
+
+    // attach dq 信号（通过 dqsplit）
+    attach(sdram0.io.dq, dqsplit.io.dq_low)   // _dq_wire[15:0]
+    attach(sdram1.io.dq, dqsplit.io.dq_high)  // _dq_wire[31:16]
+    attach(sdram2.io.dq, dqsplit.io.dq_low)
+    attach(sdram3.io.dq, dqsplit.io.dq_high)
 
     val externalPins = IO(new Bundle{
       val gpio = chiselTypeOf(masic.gpio)
diff --git a/src/Top.scala b/src/Top.scala
index c00378a6..2913155b 100644
--- a/src/Top.scala
+++ b/src/Top.scala
@@ -7,7 +7,7 @@ import freechips.rocketchip.diplomacy.LazyModule
 
 object Config {
   def hasChipLink: Boolean = false
-  def sdramUseAXI: Boolean = false
+  def sdramUseAXI: Boolean = true
 }
 
 class ysyxSoCTop extends Module {
diff --git a/src/device/SDRAM.scala b/src/device/SDRAM.scala
index a823c718..4146c97d 100644
--- a/src/device/SDRAM.scala
+++ b/src/device/SDRAM.scala
@@ -11,6 +11,21 @@ import freechips.rocketchip.diplomacy._
 import freechips.rocketchip.util._
 
 class SDRAMIO extends Bundle {
+  val clk = Output(Bool())
+  val cke = Output(Bool())
+  val cs  = Output(Bool())
+  val ras = Output(Bool())
+  val cas = Output(Bool())
+  val we  = Output(Bool())
+  val a   = Output(UInt(13.W))
+  val ba  = Output(UInt(2.W))
+  val dqm = Output(UInt(4.W))
+  val dq  = Analog(32.W)
+}
+
+class SDRAMT extends Bundle {
+  val raw = Output(UInt(8.W))
+  val word = Output(Bool())
   val clk = Output(Bool())
   val cke = Output(Bool())
   val cs  = Output(Bool())
@@ -42,7 +57,7 @@ class sdram_top_apb extends BlackBox {
 }
 
 class sdram extends BlackBox {
-  val io = IO(Flipped(new SDRAMIO))
+  val io = IO(Flipped(new SDRAMT))
 }
 
 class sdramChisel extends RawModule {
-- 
2.34.1

