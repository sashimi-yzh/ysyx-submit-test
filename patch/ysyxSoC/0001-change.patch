From ef25cde22a0c6f598d1603561657233f76a6e0ee Mon Sep 17 00:00:00 2001
From: "hanfu.xing" <550559524@qq.com>
Date: Sun, 21 Sep 2025 23:01:13 +0800
Subject: [PATCH] change

---
 perip/amba/apb_delayer.v                     | 121 ++++++++
 perip/amba/axi4_delayer.v                    | 274 +++++++++++++++++--
 perip/bitrev/bitrev.v                        |  50 +++-
 perip/flash/flash.v                          |   3 +-
 perip/gpio/gpio_top_apb.v                    | 136 +++++++++
 perip/ps2/ps2_top_apb.v                      |  55 ++++
 perip/psram/efabless/EF_PSRAM_CTRL.v         | 116 +++++++-
 perip/psram/efabless/EF_PSRAM_CTRL_wb.v      |  77 +++++-
 perip/psram/psram.v                          | 132 ++++++++-
 perip/sdram/core_sdram_axi4/sdram_axi.v      |  12 +-
 perip/sdram/core_sdram_axi4/sdram_axi_core.v | 132 +++++----
 perip/sdram/core_sdram_axi4/sdram_axi_pmem.v |  14 +-
 perip/sdram/sdram.v                          | 213 +++++++++++++-
 perip/sdram/sdram_top_apb.v                  |  16 +-
 perip/sdram/sdram_top_axi.v                  |  14 +-
 perip/spi/rtl/spi_top_apb.v                  | 116 +++++++-
 perip/uart16550/rtl/uart_tfifo.v             |   6 +-
 perip/vga/vga_top_apb.v                      | 103 +++++++
 src/CPU.scala                                |   4 +-
 src/SoC.scala                                |   2 +-
 src/Top.scala                                |   2 +-
 21 files changed, 1440 insertions(+), 158 deletions(-)

diff --git a/perip/amba/apb_delayer.v b/perip/amba/apb_delayer.v
index c0d20764..7c6c08f7 100644
--- a/perip/amba/apb_delayer.v
+++ b/perip/amba/apb_delayer.v
@@ -1,3 +1,5 @@
+`define USE_APB_DELAYER
+
 module apb_delayer(
   input         clock,
   input         reset,
@@ -24,6 +26,123 @@ module apb_delayer(
   input         out_pslverr
 );
 
+`ifdef USE_APB_DELAYER
+
+localparam R_S = 32'd167116; // 5.1 * 2**15 = 167116.8 => 167116
+localparam S   = 32'd15;  // 2**15 = 32768
+
+wire enable        = in_psel && !in_penable;
+wire already_ready = out_pready && (state == ST_IDLE);
+
+reg  [31:0]  latency_counter;
+reg  [31:0]  wait_counter;
+reg  [31:0]  wait_send_counter;
+reg          reg_out_pready;
+reg  [31:0]  reg_out_prdata;
+reg          reg_out_pslverr;
+
+enum reg [1:0] { ST_IDLE, ST_WAIT, ST_WAIT_SEND } state, n_state;
+
+//-----------------------------------------------------------------
+// APB Delayer State Machine
+//-----------------------------------------------------------------
+always @(posedge clock or posedge reset) begin
+  if (reset) begin
+    state <= ST_IDLE;
+  end else begin
+    state <= n_state;
+  end
+end
+
+always @(*) begin
+  case (state)
+    //-----------------------------------------
+    // STATE_IDLE
+    //-----------------------------------------
+    ST_IDLE: begin
+      if (already_ready) n_state = ST_IDLE;
+      else if (enable) n_state = ST_WAIT;
+      else n_state = state;
+    end
+    //-----------------------------------------
+    // STATE_WAIT
+    //-----------------------------------------
+    ST_WAIT: begin
+      if (out_pready) n_state = ST_WAIT_SEND;
+      else n_state = state;
+    end
+    //-----------------------------------------
+    // STATE_WAIT_SEND
+    //-----------------------------------------
+    ST_WAIT_SEND: begin
+      if (wait_send_counter == 32'd0) n_state = ST_IDLE;
+      else n_state = state;
+    end
+    default: n_state = ST_IDLE;
+  endcase
+end
+
+//-----------------------------------------------------------------
+// Counter Increment
+//-----------------------------------------------------------------
+always @(posedge clock or posedge reset) begin
+  if (reset) begin
+    latency_counter   <= 32'd0;
+    wait_counter      <= 32'd0;
+    wait_send_counter <= 32'd0;
+  end else begin
+    if (n_state == ST_WAIT || state == ST_WAIT && n_state == ST_WAIT) begin
+      latency_counter   <= latency_counter + 32'd1;
+      wait_counter      <= wait_counter + R_S;
+    end else if (n_state == ST_WAIT_SEND && state == ST_WAIT) begin
+      latency_counter   <= 32'd0;
+      wait_counter      <= 32'd0;
+      wait_send_counter <= (wait_counter >> S) - latency_counter - 32'd1; // 减去设置wait_send_counter那一拍
+    end else if (state == ST_WAIT_SEND && n_state != ST_IDLE) begin
+      wait_send_counter <= wait_send_counter - 32'd1;
+    end else begin
+      latency_counter   <= latency_counter;
+      wait_counter      <= wait_counter;
+      wait_send_counter <= wait_send_counter;
+    end
+  end
+end
+
+//-----------------------------------------------------------------
+// Output
+//-----------------------------------------------------------------
+always @(posedge clock or posedge reset) begin
+  if (reset) begin
+    reg_out_pready  <= 1'b0;
+    reg_out_prdata  <= 32'd0;
+    reg_out_pslverr <= 1'b0;
+  end else if (state == ST_WAIT && n_state == ST_WAIT_SEND) begin
+    reg_out_pready  <= out_pready;
+    reg_out_prdata  <= out_prdata;
+    reg_out_pslverr <= out_pslverr;
+  end else begin
+    reg_out_pready  <= reg_out_pready;
+    reg_out_prdata  <= reg_out_prdata;
+    reg_out_pslverr <= reg_out_pslverr;
+  end
+end
+
+assign out_paddr   = (state == ST_IDLE || state == ST_WAIT) ? in_paddr   : 32'd0;
+assign out_psel    = (state == ST_IDLE || state == ST_WAIT) ? in_psel    :  1'd0;
+assign out_penable = (state == ST_IDLE || state == ST_WAIT) ? in_penable :  1'd0;
+assign out_pprot   = (state == ST_IDLE || state == ST_WAIT) ? in_pprot   :  3'd0;
+assign out_pwrite  = (state == ST_IDLE || state == ST_WAIT) ? in_pwrite  :  1'd0;
+assign out_pwdata  = (state == ST_IDLE || state == ST_WAIT) ? in_pwdata  : 32'd0;
+assign out_pstrb   = (state == ST_IDLE || state == ST_WAIT) ? in_pstrb   :  4'd0;
+assign in_pready   = (already_ready) ? out_pready  :
+                                      (state == ST_WAIT_SEND && n_state == ST_IDLE) ? reg_out_pready  :  1'b0;
+assign in_prdata   = (already_ready) ? out_prdata  :
+                                      (state == ST_WAIT_SEND && n_state == ST_IDLE) ? reg_out_prdata  : 32'd0;
+assign in_pslverr  = (already_ready) ? out_pslverr :
+                                      (state == ST_WAIT_SEND && n_state == ST_IDLE) ? reg_out_pslverr :  1'b0;
+
+`else
+
   assign out_paddr   = in_paddr;
   assign out_psel    = in_psel;
   assign out_penable = in_penable;
@@ -35,4 +154,6 @@ module apb_delayer(
   assign in_prdata   = out_prdata;
   assign in_pslverr  = out_pslverr;
 
+`endif
+
 endmodule
diff --git a/perip/amba/axi4_delayer.v b/perip/amba/axi4_delayer.v
index f692803b..a3bda6af 100644
--- a/perip/amba/axi4_delayer.v
+++ b/perip/amba/axi4_delayer.v
@@ -1,3 +1,5 @@
+`define USE_AXI_DELAYER
+
 module axi4_delayer(
   input         clock,
   input         reset,
@@ -63,34 +65,248 @@ module axi4_delayer(
   input  [1:0]  out_bresp
 );
 
-  assign in_arready = out_arready;
-  assign out_arvalid = in_arvalid;
-  assign out_arid = in_arid;
-  assign out_araddr = in_araddr;
-  assign out_arlen = in_arlen;
-  assign out_arsize = in_arsize;
-  assign out_arburst = in_arburst;
-  assign out_rready = in_rready;
-  assign in_rvalid = out_rvalid;
-  assign in_rid = out_rid;
-  assign in_rdata = out_rdata;
-  assign in_rresp = out_rresp;
-  assign in_rlast = out_rlast;
-  assign in_awready = out_awready;
-  assign out_awvalid = in_awvalid;
-  assign out_awid = in_awid;
-  assign out_awaddr = in_awaddr;
-  assign out_awlen = in_awlen;
-  assign out_awsize = in_awsize;
-  assign out_awburst = in_awburst;
-  assign in_wready = out_wready;
-  assign out_wvalid = in_wvalid;
-  assign out_wdata = in_wdata;
-  assign out_wstrb = in_wstrb;
-  assign out_wlast = in_wlast;
-  assign out_bready = in_bready;
-  assign in_bvalid = out_bvalid;
-  assign in_bid = out_bid;
-  assign in_bresp = out_bresp;
+`ifdef USE_AXI_DELAYER
+
+localparam R_S = 32'd167116; // 5.1 * 2**15 = 167116.8 => 167116
+localparam S   = 32'd15;  // 2**15 = 32768
+
+wire r_handshake;
+
+enum reg [1:0] { ST_IDLE, ST_WAIT, ST_WAIT_SEND } r_state, r_nstate, w_state, w_nstate;
+
+reg [31:0] r_latency_counter;
+reg [31:0] r_wait_counter;
+reg [31:0] r_wait_send_counter;
+reg [31:0] w_latency_counter;
+reg [31:0] w_wait_counter;
+reg [31:0] w_wait_send_counter;
+reg [ 7:0] burst_num;
+
+//==============================================================================
+//  READ LATENCY
+//==============================================================================
+//-----------------------------------------------------------------
+//  AXI Delayer READ State Machine
+//-----------------------------------------------------------------
+always @(posedge clock or posedge reset) begin
+  if (reset) begin
+    r_state <= ST_IDLE;
+  end else begin
+    r_state <= r_nstate;
+  end
+end
+
+always @(*) begin
+  case(r_state)
+    //-----------------------------------------
+    // STATE_IDLE
+    //-----------------------------------------
+    ST_IDLE: begin
+      if (in_arvalid) r_nstate = ST_WAIT;
+      else r_nstate = r_state;
+    end
+    //-----------------------------------------
+    // STATE_WAIT
+    //-----------------------------------------
+    ST_WAIT: begin
+      if (out_rvalid) r_nstate = ST_WAIT_SEND;
+      else r_nstate = r_state;
+    end
+    //-----------------------------------------
+    // STATE_WAIT_SEND
+    //-----------------------------------------
+    ST_WAIT_SEND: begin
+      if (r_wait_send_counter == 0 && burst_num == 1) r_nstate = ST_IDLE;
+      else if (r_wait_send_counter == 0 && burst_num > 1) r_nstate = ST_WAIT;
+      else r_nstate = r_state;
+    end
+    default: begin
+      r_nstate = ST_IDLE;
+    end
+  endcase
+end
+
+//-----------------------------------------------------------------
+//  Counter Increment and REG
+//-----------------------------------------------------------------
+always @(posedge clock or posedge reset) begin
+  if (reset) begin
+    r_latency_counter   <= 32'd0;
+    r_wait_counter      <= 32'd0;
+    r_wait_send_counter <= 32'd0;
+  end else begin
+    if (r_nstate == ST_WAIT) begin
+      r_latency_counter <= r_latency_counter + 32'd1;
+      r_wait_counter <= r_wait_counter + R_S;
+    end else if (r_state == ST_WAIT && r_nstate == ST_WAIT_SEND) begin
+      r_latency_counter   <= 32'd0;
+      r_wait_counter      <= 32'd0;
+      r_wait_send_counter <= (r_wait_counter >> S) - r_latency_counter - 32'd1; // 减去设置wait_send_counter那一拍
+    end else if (r_state == ST_WAIT_SEND && r_nstate == ST_WAIT_SEND) begin
+      r_wait_send_counter <= r_wait_send_counter - 32'd1;
+    end else begin
+      r_latency_counter   <= r_latency_counter;
+      r_wait_counter      <= r_wait_counter;
+      r_wait_send_counter <= r_wait_send_counter;
+    end
+  end
+end
+
+assign r_handshake = in_rvalid && out_rready;
+
+always @(posedge clock or posedge reset) begin
+  if (reset) begin
+    burst_num <= 8'd0;
+  end else begin
+    if (r_state == ST_IDLE && r_nstate == ST_WAIT) begin
+      burst_num <= in_arlen + 8'd1;
+    end else if (r_handshake) begin
+      burst_num <= burst_num - 8'd1;
+    end else begin
+      burst_num <= burst_num;
+    end
+  end
+end
+
+//-----------------------------------------------------------------
+//  READ Output
+//-----------------------------------------------------------------
+assign out_arvalid = in_arvalid;
+assign out_arid    = in_arid;
+assign out_araddr  = in_araddr;
+assign out_arlen   = in_arlen;
+assign out_arsize  = in_arsize;
+assign out_arburst = in_arburst;
+assign in_arready  = out_arready;
+assign out_rready  = (r_state == ST_WAIT_SEND && r_nstate != ST_WAIT_SEND) ? in_rready : 1'b0;
+assign in_rvalid   = (r_state == ST_WAIT_SEND && r_nstate != ST_WAIT_SEND) ? out_rvalid : 1'b0;
+assign in_rid      = out_rid;
+assign in_rdata    = out_rdata;
+assign in_rresp    = out_rresp;
+assign in_rlast    = out_rlast;
+
+//==============================================================================
+//  WRITE LATENCY
+//==============================================================================
+//-----------------------------------------------------------------
+//  AXI Delayer WRITE State Machine
+//-----------------------------------------------------------------
+always @(posedge clock or posedge reset) begin
+  if (reset) begin
+    w_state <= ST_IDLE;
+  end else begin
+    w_state <= w_nstate;
+  end
+end
+
+always @(*) begin
+  case(w_state)
+    //-----------------------------------------
+    // STATE_IDLE
+    //-----------------------------------------
+    ST_IDLE: begin
+      if (in_awvalid) w_nstate = ST_WAIT;
+      else w_nstate = w_state;
+    end
+    //-----------------------------------------
+    // STATE_WAIT
+    //-----------------------------------------
+    ST_WAIT: begin
+      if (out_bvalid) w_nstate = ST_WAIT_SEND;
+      else w_nstate = w_state;
+    end
+    //-----------------------------------------
+    // STATE_WAIT_SEND
+    //-----------------------------------------
+    ST_WAIT_SEND: begin
+      if (w_wait_send_counter == 0) w_nstate = ST_IDLE;
+      else w_nstate = w_state;
+    end
+    default: begin
+      w_nstate = ST_IDLE;
+    end
+  endcase
+end
+
+//-----------------------------------------------------------------
+//  Counter Increment
+//-----------------------------------------------------------------
+always @(posedge clock or posedge reset) begin
+  if (reset) begin
+    w_latency_counter   <= 32'd0;
+    w_wait_counter      <= 32'd0;
+    w_wait_send_counter <= 32'd0;
+  end else begin
+    if (w_nstate == ST_WAIT) begin
+      w_latency_counter <= w_latency_counter + 32'd1;
+      w_wait_counter <= w_wait_counter + R_S;
+    end else if (w_state == ST_WAIT && w_nstate == ST_WAIT_SEND) begin
+      w_latency_counter   <= 32'd0;
+      w_wait_counter      <= 32'd0;
+      w_wait_send_counter <= (w_wait_counter >> S) - w_latency_counter - 32'd1; // 减去设置wait_send_counter那一拍
+    end else if (w_state == ST_WAIT_SEND && w_nstate != ST_IDLE) begin
+      w_wait_send_counter <= w_wait_send_counter - 32'd1;
+    end else begin
+      w_latency_counter   <= w_latency_counter;
+      w_wait_counter      <= w_wait_counter;
+      w_wait_send_counter <= w_wait_send_counter;
+    end
+  end
+end
+
+//-----------------------------------------------------------------
+//  WRITE Output
+//-----------------------------------------------------------------
+assign in_awready  = out_awready;
+assign out_awvalid = in_awvalid;
+assign out_awid    = in_awid;
+assign out_awaddr  = in_awaddr;
+assign out_awlen   = in_awlen;
+assign out_awsize  = in_awsize;
+assign out_awburst = in_awburst;
+assign in_wready   = out_wready;
+assign out_wvalid = in_wvalid;
+assign out_wdata = in_wdata;
+assign out_wstrb = in_wstrb;
+assign out_wlast = in_wlast;
+assign out_bready  = (w_state == ST_WAIT_SEND && w_nstate == ST_IDLE) ? in_bready : 1'b0;
+assign in_bvalid   = (w_state == ST_WAIT_SEND && w_nstate == ST_IDLE) ? out_bvalid : 1'b0;
+assign in_bid      = out_bid;
+assign in_bresp    = out_rresp;
+
+`else
+
+assign in_arready = out_arready;
+assign out_arvalid = in_arvalid;
+assign out_arid = in_arid;
+assign out_araddr = in_araddr;
+assign out_arlen = in_arlen;
+assign out_arsize = in_arsize;
+assign out_arburst = in_arburst;
+assign out_rready = in_rready;
+assign in_rvalid = out_rvalid;
+assign in_rid = out_rid;
+assign in_rdata = out_rdata;
+assign in_rresp = out_rresp;
+assign in_rlast = out_rlast;
+assign in_awready = out_awready;
+assign out_awvalid = in_awvalid;
+assign out_awid = in_awid;
+assign out_awaddr = in_awaddr;
+assign out_awlen = in_awlen;
+assign out_awsize = in_awsize;
+assign out_awburst = in_awburst;
+assign in_wready = out_wready;
+assign out_wvalid = in_wvalid;
+assign out_wdata = in_wdata;
+assign out_wstrb = in_wstrb;
+assign out_wlast = in_wlast;
+assign out_bready = in_bready;
+assign in_bvalid = out_bvalid;
+assign in_bid = out_bid;
+assign in_bresp = out_bresp;
+
+
+`endif
 
 endmodule
diff --git a/perip/bitrev/bitrev.v b/perip/bitrev/bitrev.v
index f1c3b363..fc3cb58b 100644
--- a/perip/bitrev/bitrev.v
+++ b/perip/bitrev/bitrev.v
@@ -4,5 +4,53 @@ module bitrev (
   input  mosi,
   output miso
 );
-  assign miso = 1'b1;
+  wire reset;
+
+  reg [7:0] data_in;
+  reg       state;
+  reg [2:0] cnt;
+
+  parameter IN  = 1'b0;
+  parameter OUT = 1'b1;
+
+  assign reset = ss;
+
+  /** state machine */
+  always @(posedge sck or posedge reset) begin
+    if (reset) state <= IN;
+    else begin
+      case (state)
+        IN: begin 
+          if (cnt == 3'd7) state <= OUT;
+          else state <= IN;
+        end
+        OUT: state <= state;
+        default: state <= state;
+      endcase
+    end
+  end
+
+  always @(posedge sck or posedge reset) begin
+    if (reset) cnt <= 3'd0;
+    else begin
+      case (state)
+        IN: begin 
+          if (cnt == 3'd7) cnt <= 3'd0;
+          else cnt <= cnt + 3'd1;
+        end
+        OUT: begin
+          cnt <= cnt + 3'd1;
+        end
+        default: cnt <= cnt;
+      endcase
+    end
+  end
+
+  always @(posedge sck or posedge reset) begin
+    if (reset) data_in <= 8'h0;
+    else if (state == IN) data_in <= {data_in[6:0], mosi};
+    else data_in <= data_in;
+  end
+  
+  assign miso = ss ? 1'b1 : data_in[cnt];
 endmodule
diff --git a/perip/flash/flash.v b/perip/flash/flash.v
index 480d7092..23d7ba40 100644
--- a/perip/flash/flash.v
+++ b/perip/flash/flash.v
@@ -69,7 +69,8 @@ module flash (
       addr <= { addr[22:0], mosi };
   end
 
-  wire [31:0] data_bswap = {rdata[7:0], rdata[15:8], rdata[23:16], rdata[31:24]};
+  // wire [31:0] data_bswap = {rdata[7:0], rdata[15:8], rdata[23:16], rdata[31:24]};
+  wire [31:0] data_bswap = rdata;
   always@(posedge sck or posedge reset) begin
     if (reset) data <= 32'd0;
     else if (state == data_t) begin
diff --git a/perip/gpio/gpio_top_apb.v b/perip/gpio/gpio_top_apb.v
index ec51ffe5..88dd6dd0 100644
--- a/perip/gpio/gpio_top_apb.v
+++ b/perip/gpio/gpio_top_apb.v
@@ -24,4 +24,140 @@ module gpio_top_apb(
   output [7:0]  gpio_seg_7
 );
 
+wire is_read;
+wire is_write;
+
+assign is_read  = (in_psel && !in_penable) && !in_pwrite;
+assign is_write = (in_psel && !in_penable) && in_pwrite;
+
+reg [1:0] state;
+reg [1:0] n_state;
+
+typedef enum [1:0] { ST_IDLE, ST_READ, ST_WRITE } state_t;
+
+//-----------------------------------------------------------------
+// GPIO State Machine
+//-----------------------------------------------------------------
+always @(*) begin
+  case (state)
+    //-----------------------------------------
+    // STATE_IDLE
+    //-----------------------------------------
+    ST_IDLE: begin
+      if (is_read) n_state = ST_READ;
+      else if (is_write) n_state = ST_WRITE;
+      else n_state = state;
+    end
+    //-----------------------------------------
+    // ST_READ
+    //-----------------------------------------
+    ST_READ: begin
+      n_state = ST_IDLE;
+    end
+    //-----------------------------------------
+    // ST_WRITE
+    //-----------------------------------------
+    ST_WRITE: begin
+      n_state = ST_IDLE;
+    end
+    default: begin
+      n_state = state;
+    end
+  endcase
+end
+
+always @(posedge clock or posedge reset) begin
+  if (reset) state <= ST_IDLE;
+  else state <= n_state;
+end
+
+//-----------------------------------------------------------------
+// Output
+//-----------------------------------------------------------------
+reg [15:0] led;
+reg [ 7:0] seg [0:7];
+reg [31:0] rdata;
+
+assign in_prdata  = rdata;
+assign in_pready  = state == ST_READ || state == ST_WRITE;
+assign in_pslverr = state == ST_READ  && in_paddr != 32'h10002004 ||
+                    state == ST_WRITE && (in_paddr != 32'h10002000 && in_paddr != 32'h10002008);
+
+assign gpio_out   = led;
+assign gpio_seg_0 = seg[0];
+assign gpio_seg_1 = seg[1];
+assign gpio_seg_2 = seg[2];
+assign gpio_seg_3 = seg[3];
+assign gpio_seg_4 = seg[4];
+assign gpio_seg_5 = seg[5];
+assign gpio_seg_6 = seg[6];
+assign gpio_seg_7 = seg[7];
+
+wire [7:0] seg_code [10:0];
+assign seg_code[0]  = 8'b11111100;
+assign seg_code[1]  = 8'b01100000;
+assign seg_code[2]  = 8'b11011010;
+assign seg_code[3]  = 8'b11110010;
+assign seg_code[4]  = 8'b01100110;
+assign seg_code[5]  = 8'b10110110;
+assign seg_code[6]  = 8'b10111110;
+assign seg_code[7]  = 8'b11100000;
+assign seg_code[8]  = 8'b11111110;
+assign seg_code[9]  = 8'b11110110;
+assign seg_code[10] = 8'b00000001;
+
+always @(posedge clock or posedge reset) begin
+  if (reset) begin
+    led    <= 16'd0;
+    seg[0] <= ~seg_code[0];
+    seg[1] <= ~seg_code[0];
+    seg[2] <= ~seg_code[0];
+    seg[3] <= ~seg_code[0];
+    seg[4] <= ~seg_code[0];
+    seg[5] <= ~seg_code[0];
+    seg[6] <= ~seg_code[0];
+    seg[7] <= ~seg_code[0];
+    rdata  <= 32'd0;
+  end else begin
+    case (n_state)
+      //-----------------------------------------
+      // ST_READ
+      //-----------------------------------------
+      ST_READ: begin
+        rdata <= {16'd0, gpio_in};
+      end
+      //-----------------------------------------
+      // ST_WRITE
+      //-----------------------------------------
+      ST_WRITE: begin
+        if (in_paddr[3:0] == 4'h0) begin
+          led[15:8] <= in_pstrb[1] ? in_pwdata[15:8] : led[15:8];
+          led[ 7:0] <= in_pstrb[0] ? in_pwdata[ 7:0] : led[ 7:0];
+        end else if (in_paddr[3:0] == 4'h8) begin
+          seg[0] <= in_pstrb[0] ? ~seg_code[in_pwdata[ 3: 0]] : seg[0];
+          seg[1] <= in_pstrb[0] ? ~seg_code[in_pwdata[ 7: 4]] : seg[1];
+          seg[2] <= in_pstrb[1] ? ~seg_code[in_pwdata[11: 8]] : seg[2];
+          seg[3] <= in_pstrb[1] ? ~seg_code[in_pwdata[15:12]] : seg[3];
+          seg[4] <= in_pstrb[2] ? ~seg_code[in_pwdata[19:16]] : seg[4];
+          seg[5] <= in_pstrb[2] ? ~seg_code[in_pwdata[23:20]] : seg[5];
+          seg[6] <= in_pstrb[3] ? ~seg_code[in_pwdata[27:24]] : seg[6];
+          seg[7] <= in_pstrb[3] ? ~seg_code[in_pwdata[31:28]] : seg[7];
+        end
+      end
+      default: begin
+        rdata  <= rdata;
+        led    <= led;
+        seg[0] <= seg[0];
+        seg[1] <= seg[1];
+        seg[2] <= seg[2];
+        seg[3] <= seg[3];
+        seg[4] <= seg[4];
+        seg[5] <= seg[5];
+        seg[6] <= seg[6];
+        seg[7] <= seg[7];
+      end
+    endcase
+  end
+end
+
 endmodule
diff --git a/perip/ps2/ps2_top_apb.v b/perip/ps2/ps2_top_apb.v
index 080d38fa..16655fa6 100644
--- a/perip/ps2/ps2_top_apb.v
+++ b/perip/ps2/ps2_top_apb.v
@@ -16,4 +16,59 @@ module ps2_top_apb(
   input         ps2_data
 );
 
+localparam fifo_depth = 3;
+
+// internal signal, for test
+reg [9:0] buffer;        // ps2_data bits
+reg [7:0] fifo[2**fifo_depth - 1:0];     // data fifo
+reg [2:0] w_ptr,r_ptr;   // fifo write and read pointers
+reg [3:0] count;  // count ps2_data bits
+// detect falling edge of ps2_clk
+reg [2:0] ps2_clk_sync;
+reg       ready;
+
+always @(posedge clock) begin
+    ps2_clk_sync <=  {ps2_clk_sync[1:0],ps2_clk};
+end
+
+wire sampling = ps2_clk_sync[2] & ~ps2_clk_sync[1];
+wire is_read = (in_psel && !in_penable) && !in_pwrite;
+assign in_pslverr = in_paddr != 32'h10011000;
+
+always @(posedge clock or posedge reset) begin
+    if (reset) begin // reset
+        count <= 0; w_ptr <= 0; r_ptr <= 3'b111; ready <= 0;
+    end
+    else begin
+      if (sampling) begin
+        if (count == 4'd10) begin
+          if ((buffer[0] == 0) &&  // start bit
+              (ps2_data)       &&  // stop bit
+              (^buffer[9:1])) begin      // odd  parity
+              fifo[w_ptr] <= buffer[8:1];  // kbd scan code
+              w_ptr <= w_ptr + 3'd1;
+              ready <= 1'b1;
+          end
+          count <= 0;     // for next
+        end else begin
+          buffer[count] <= ps2_data;  // store ps2_data
+          count <= count + 3'b1;
+        end
+      end
+      else if ( ready ) begin // read to output next data
+        if(is_read == 1'b1) //read next data
+        begin 
+          if(w_ptr==(r_ptr + 3'd1)) //empty
+              ready <= 1'b0;
+          else begin
+            r_ptr <= r_ptr + 3'd1;
+          end
+        end
+      end
+    end
+end
+
+assign in_pready = 1'b1;
+assign in_prdata = ready ? {24'd0, fifo[r_ptr]} : 32'd0;; //always set output data
+
 endmodule
diff --git a/perip/psram/efabless/EF_PSRAM_CTRL.v b/perip/psram/efabless/EF_PSRAM_CTRL.v
index b6e737e9..e6e4480d 100644
--- a/perip/psram/efabless/EF_PSRAM_CTRL.v
+++ b/perip/psram/efabless/EF_PSRAM_CTRL.v
@@ -44,6 +44,7 @@
 module PSRAM_READER (
     input   wire            clk,
     input   wire            rst_n,
+    input   wire            qpi_mode,
     input   wire [23:0]     addr,
     input   wire            rd,
     input   wire [2:0]      size,
@@ -60,7 +61,7 @@ module PSRAM_READER (
     localparam  IDLE = 1'b0,
                 READ = 1'b1;
 
-    wire [7:0]  FINAL_COUNT = 19 + size*2; // was 27: Always read 1 word
+    wire [7:0]  FINAL_COUNT = qpi_mode ? (13 + size*2) : (19 + size*2); // was 27: Always read 1 word
 
     reg         state, nstate;
     reg [7:0]   counter;
@@ -69,6 +70,9 @@ module PSRAM_READER (
 
     wire[7:0]   CMD_EBH = 8'heb;
 
+    wire[3:0]   dout_qspi;
+    wire[3:0]   dout_qpi;
+
     always @*
         case (state)
             IDLE: if(rd) nstate = READ; else nstate = IDLE;
@@ -113,13 +117,13 @@ module PSRAM_READER (
             saddr <= {addr[23:0]};
 
     // Sample with the negedge of sck
-    wire[1:0] byte_index = {counter[7:1] - 8'd10}[1:0];
+    wire[1:0] byte_index = {counter[7:1] - (qpi_mode ? 8'd7 : 8'd10)}[1:0];
     always @ (posedge clk)
-        if(counter >= 20 && counter <= FINAL_COUNT)
+        if((qpi_mode ? counter >= 14 : counter >= 20) && counter <= FINAL_COUNT)
             if(sck)
                 data[byte_index] <= {data[byte_index][3:0], din}; // Optimize!
 
-    assign dout     =   (counter < 8)   ?   {3'b0, CMD_EBH[7 - counter]}:
+    assign dout_qspi =  (counter < 8)   ?   {3'b0, CMD_EBH[7 - counter]}:
                         (counter == 8)  ?   saddr[23:20]        :
                         (counter == 9)  ?   saddr[19:16]        :
                         (counter == 10) ?   saddr[15:12]        :
@@ -127,8 +131,17 @@ module PSRAM_READER (
                         (counter == 12) ?   saddr[7:4]          :
                         (counter == 13) ?   saddr[3:0]          :
                         4'h0;
+    assign dout_qpi =  (counter < 2)    ?   CMD_EBH[(3'd1-counter[2:0])<<2 +: 4]:
+                        (counter == 2)  ?   saddr[23:20]        :
+                        (counter == 3)  ?   saddr[19:16]        :
+                        (counter == 4)  ?   saddr[15:12]        :
+                        (counter == 5)  ?   saddr[11:8]         :
+                        (counter == 6)  ?   saddr[7:4]          :
+                        (counter == 7)  ?   saddr[3:0]          :
+                        4'h0;
+    assign dout     = qpi_mode ? dout_qpi : dout_qspi;
 
-    assign douten   = (counter < 14);
+    assign douten   = qpi_mode ? counter < 8 : (counter < 14);
 
     assign done     = (counter == FINAL_COUNT+1);
 
@@ -145,6 +158,7 @@ endmodule
 module PSRAM_WRITER (
     input   wire            clk,
     input   wire            rst_n,
+    input   wire            qpi_mode,
     input   wire [23:0]     addr,
     input   wire [31: 0]    line,
     input   wire [2:0]      size,
@@ -161,7 +175,7 @@ module PSRAM_WRITER (
     localparam  IDLE = 1'b0,
                 WRITE = 1'b1;
 
-    wire[7:0]        FINAL_COUNT = 13 + size*2;
+    wire[7:0]   FINAL_COUNT = qpi_mode ? (7 + size*2) : (13 + size*2);
 
     reg         state, nstate;
     reg [7:0]   counter;
@@ -170,6 +184,9 @@ module PSRAM_WRITER (
 
     wire[7:0]   CMD_38H = 8'h38;
 
+    wire[3:0]   dout_qspi;
+    wire[3:0]   dout_qpi;
+
     always @*
         case (state)
             IDLE: if(wr) nstate = WRITE; else nstate = IDLE;
@@ -212,7 +229,7 @@ module PSRAM_WRITER (
         else if((state == IDLE) && wr)
             saddr <= addr;
 
-    assign dout     =   (counter < 8)   ?   {3'b0, CMD_38H[7 - counter]}:
+    assign dout_qspi =  (counter < 8)   ?   {3'b0, CMD_38H[7 - counter]}:
                         (counter == 8)  ?   saddr[23:20]        :
                         (counter == 9)  ?   saddr[19:16]        :
                         (counter == 10) ?   saddr[15:12]        :
@@ -227,10 +244,91 @@ module PSRAM_WRITER (
                         (counter == 19) ?   line[19:16]         :
                         (counter == 20) ?   line[31:28]         :
                         line[27:24];
+    assign dout_qpi =  (counter < 2)   ?   CMD_38H[(3'd1-counter[2:0])<<2 +: 4]:
+                        (counter == 2)  ?   saddr[23:20]        :
+                        (counter == 3)  ?   saddr[19:16]        :
+                        (counter == 4) ?   saddr[15:12]        :
+                        (counter == 5) ?   saddr[11:8]         :
+                        (counter == 6) ?   saddr[7:4]          :
+                        (counter == 7) ?   saddr[3:0]          :
+                        (counter == 8) ?   line[7:4]           :
+                        (counter == 9) ?   line[3:0]           :
+                        (counter == 10) ?   line[15:12]         :
+                        (counter == 11) ?   line[11:8]          :
+                        (counter == 12) ?   line[23:20]         :
+                        (counter == 13) ?   line[19:16]         :
+                        (counter == 14) ?   line[31:28]         :
+                        line[27:24];
+    assign dout      = qpi_mode ? dout_qpi : dout_qspi;
+
+    assign douten    = (~ce_n);
+
+    assign done      = (counter == FINAL_COUNT + 1);
+
+
+endmodule
+
+// Using 35H Command to switch QPI mode
+module PSRAM_SWITCH_QPI (
+    input   wire            clk,
+    input   wire            rst_n,
+    input   wire            qpi_en,
+    output  wire            done,
+
+    output  reg             sck,
+    output  reg             ce_n,
+    output  wire [3:0]      dout,
+    output  wire            douten
+);
+
+    localparam  IDLE = 1'b0,
+                QPI  = 1'b1;
+
+    wire[7:0]   CMD_35H = 8'h35;
+
+    reg         state, nstate;
+    reg [3:0]   counter;
+
+    always @*
+        case (state)
+            IDLE: if(qpi_en) nstate = QPI; else nstate = IDLE;
+            QPI: if(done) nstate = IDLE; else nstate = QPI;
+        endcase
+
+    always @ (posedge clk or negedge rst_n)
+        if(!rst_n) state <= IDLE;
+        else state <= nstate;
+
+    // Drive the Serial Clock (sck) @ clk/2
+    always @ (posedge clk or negedge rst_n)
+        if(!rst_n)
+            sck <= 1'b0;
+        else if(~ce_n)
+            sck <= ~ sck;
+        else if(state == IDLE)
+            sck <= 1'b0;
+
+    // ce_n logic
+    always @ (posedge clk or negedge rst_n)
+        if(!rst_n)
+            ce_n <= 1'b1;
+        else if(state == QPI)
+            ce_n <= 1'b0;
+        else
+            ce_n <= 1'b1;
+
+    always @ (posedge clk or negedge rst_n)
+        if(!rst_n)
+            counter <= 4'b0;
+        else if(sck & ~done)
+            counter <= counter + 1'b1;
+        else if(state == IDLE)
+            counter <= 4'b0;
 
-    assign douten   = (~ce_n);
+    assign dout   = (counter == 4'd8) ? 4'd0 : {3'b0, CMD_35H[7 - counter]};
 
-    assign done     = (counter == FINAL_COUNT + 1);
+    assign douten = (~ce_n);
 
+    assign done   = (counter == 4'd9);
 
 endmodule
diff --git a/perip/psram/efabless/EF_PSRAM_CTRL_wb.v b/perip/psram/efabless/EF_PSRAM_CTRL_wb.v
index 7b5296db..b34c91da 100644
--- a/perip/psram/efabless/EF_PSRAM_CTRL_wb.v
+++ b/perip/psram/efabless/EF_PSRAM_CTRL_wb.v
@@ -39,8 +39,9 @@ module EF_PSRAM_CTRL_wb (
     output  wire [3:0]      douten
 );
 
-    localparam  ST_IDLE = 1'b0,
-                ST_WAIT = 1'b1;
+    localparam  ST_IDLE = 2'd0,
+                ST_QPI  = 2'd1,
+                ST_WAIT = 2'd2;
 
     wire        mr_sck;
     wire        mr_ce_n;
@@ -53,6 +54,7 @@ module EF_PSRAM_CTRL_wb (
     wire [3:0]  mw_din;
     wire [3:0]  mw_dout;
     wire        mw_doe;
+    // wire [1:0]  waddr;
 
     // PSRAM Reader and Writer wires
     wire        mr_rd;
@@ -68,8 +70,31 @@ module EF_PSRAM_CTRL_wb (
     wire        wb_re           =   ~we_i & wb_valid;
     //wire[3:0]   wb_byte_sel     =   sel_i & {4{wb_we}};
 
+    // Switching QPI mode
+    wire        qpi_sck;
+    wire        qpi_ce_n;
+    wire [3:0]  qpi_dout;
+    wire        qpi_done;
+    wire        qpi_doe;
+    reg         set_qpi;
+    reg         qpi_mode;
+
+    always @ (posedge clk_i or posedge rst_i)
+        if(rst_i)
+            set_qpi <= 1'b1;
+        else
+            set_qpi <= 1'b0;
+
+    always @ (posedge clk_i or posedge rst_i)
+        if (rst_i)
+            qpi_mode <= 1'b0;
+        else if (state == ST_QPI)
+            qpi_mode <= 1'b1;
+        else
+            qpi_mode <= qpi_mode;
+
     // The FSM
-    reg         state, nstate;
+    reg [1:0]   state, nstate;
     always @ (posedge clk_i or posedge rst_i)
         if(rst_i)
             state <= ST_IDLE;
@@ -79,16 +104,26 @@ module EF_PSRAM_CTRL_wb (
     always @* begin
         case(state)
             ST_IDLE :
-                if(wb_valid)
+                if (set_qpi)
+                    nstate = ST_QPI;
+                else if(wb_valid)
                     nstate = ST_WAIT;
                 else
                     nstate = ST_IDLE;
 
+            ST_QPI :
+                if(qpi_done)
+                    nstate = ST_IDLE;
+                else
+                    nstate = ST_QPI;
+
             ST_WAIT :
                 if((mw_done & wb_we) | (mr_done & wb_re))
                     nstate = ST_IDLE;
                 else
                     nstate = ST_WAIT;
+            default :
+                nstate = ST_IDLE;
         endcase
     end
 
@@ -100,8 +135,6 @@ module EF_PSRAM_CTRL_wb (
                         (sel_i == 4'b1100) ? 2 :
                         (sel_i == 4'b1111) ? 4 : 4;
 
-
-
     wire [7:0]  byte0 = (sel_i[0])          ? dat_i[7:0]   :
                         (sel_i[1] & size==1)? dat_i[15:8]  :
                         (sel_i[2] & size==1)? dat_i[23:16] :
@@ -111,6 +144,11 @@ module EF_PSRAM_CTRL_wb (
 
     wire [7:0]  byte1 = (sel_i[1])          ? dat_i[15:8]  :
                         dat_i[31:24];
+    // wire [2:0]  size  = 4;
+
+    // wire [7:0]  byte0 = dat_i[7:0];
+
+    // wire [7:0]  byte1 = dat_i[15:8];
 
     wire [7:0]  byte2 = dat_i[23:16];
 
@@ -118,21 +156,31 @@ module EF_PSRAM_CTRL_wb (
 
     wire [31:0] wdata = {byte3, byte2, byte1, byte0};
 
-    /*
     wire [1:0]  waddr = (size==1 && sel_i[0]==1) ? 2'b00 :
                         (size==1 && sel_i[1]==1) ? 2'b01 :
                         (size==1 && sel_i[2]==1) ? 2'b10 :
                         (size==1 && sel_i[3]==1) ? 2'b11 :
                         (size==2 && sel_i[2]==1) ? 2'b10 :
                         2'b00;
-                      */
 
     assign mr_rd    = ( (state==ST_IDLE ) & wb_re );
     assign mw_wr    = ( (state==ST_IDLE ) & wb_we );
 
+    PSRAM_SWITCH_QPI QPI_MODE (
+        .clk(clk_i),
+        .rst_n(~rst_i),
+        .qpi_en(state == ST_QPI),
+        .done(qpi_done),
+        .sck(qpi_sck),
+        .ce_n(qpi_ce_n),
+        .dout(qpi_dout),
+        .douten(qpi_doe)
+    );
+
     PSRAM_READER MR (
         .clk(clk_i),
         .rst_n(~rst_i),
+        .qpi_mode(qpi_mode),
         .addr({adr_i[23:2],2'b0}),
         .rd(mr_rd),
         //.size(size), Always read a word
@@ -149,7 +197,8 @@ module EF_PSRAM_CTRL_wb (
     PSRAM_WRITER MW (
         .clk(clk_i),
         .rst_n(~rst_i),
-        .addr({adr_i[23:0]}),
+        .qpi_mode(qpi_mode),
+        .addr({adr_i[23:2],waddr}),
         .wr(mw_wr),
         .size(size),
         .done(mw_done),
@@ -161,12 +210,12 @@ module EF_PSRAM_CTRL_wb (
         .douten(mw_doe)
     );
 
-    assign sck  = wb_we ? mw_sck  : mr_sck;
-    assign ce_n = wb_we ? mw_ce_n : mr_ce_n;
-    assign dout = wb_we ? mw_dout : mr_dout;
-    assign douten  = wb_we ? {4{mw_doe}}  : {4{mr_doe}};
+    assign sck     = (state == ST_QPI) ? qpi_sck  : (wb_we ? mw_sck  : mr_sck );
+    assign ce_n    = (state == ST_QPI) ? qpi_ce_n : (wb_we ? mw_ce_n : mr_ce_n);
+    assign dout    = (state == ST_QPI) ? qpi_dout : (wb_we ? mw_dout : mr_dout);
+    assign douten  = (state == ST_QPI) ? {4{qpi_doe}} : (wb_we ? {4{mw_doe}}  : {4{mr_doe}});
 
     assign mw_din = din;
     assign mr_din = din;
-    assign ack_o = wb_we ? mw_done :mr_done ;
+    assign ack_o = (state == ST_QPI) ? qpi_done : (wb_we ? mw_done :mr_done);
 endmodule
diff --git a/perip/psram/psram.v b/perip/psram/psram.v
index d9bdd882..0928fbfa 100644
--- a/perip/psram/psram.v
+++ b/perip/psram/psram.v
@@ -4,6 +4,136 @@ module psram(
   inout [3:0] dio
 );
 
-  assign dio = 4'bz;
+  wire           reset;
+  wire  [3  :0]  din;
+  wire  [3  :0]  dout;
+  wire           douten;
+  wire           ren;
+  wire  [31 :0]  raddr;
+
+  reg   [2  :0]  state;
+  reg   [7  :0]  counter;
+  reg   [7  :0]  cmd;
+  reg   [23 :0]  addr;
+  reg   [31 :0]  receive_data;
+  reg   [31 :0]  wdata;
+  reg   [31 :0]  rdata;
+  reg   [31 :0]  data;
+  reg            qpi;
+  reg   [2  :0]  len;
+
+  typedef enum [2:0] { cmd_t, addr_t, delay_t, data_t } state_t;
+  parameter READ    = 8'heb;
+  parameter WRITE   = 8'h38;
+  parameter SET_QPI = 8'h35;
+
+  assign reset = ce_n;
+  assign ren   = (state == delay_t) && (counter == 8'd0) && (cmd == READ);
+
+  // Tristate buffer
+  assign dio = douten ? dout : 4'bz;
+  assign din = dio;
+  assign douten = (state == data_t && cmd == READ);
+
+  // Change state
+  always @(posedge sck or posedge reset) begin
+    if (reset) state <= cmd_t;
+    else begin
+      case (state)
+        cmd_t:   state <= (qpi ? counter == 8'd1 : counter == 8'd7) ? addr_t  : state;
+        addr_t:  state <= (counter == 8'd5) ? 
+                          ((cmd == READ) ? delay_t : data_t) : state;
+        delay_t: state <= (counter == 8'd5) ? data_t  : state;
+        data_t:  state <= state;
+        default: state <= cmd_t;
+      endcase
+    end
+  end
+
+  // Increase counter
+  always @(posedge sck or posedge reset) begin
+    if (reset) counter <= 8'd0;
+    else begin
+      case (state)
+        cmd_t:   counter <= (qpi ? counter < 8'd1 : counter < 8'd7) ? counter + 8'd1 : 8'd0;
+        addr_t:  counter <= (counter < 8'd5) ? counter + 8'd1 : 8'd0;
+        delay_t: counter <= (counter < 8'd5) ? counter + 8'd1 : 8'd0;
+        data_t:  counter <= (counter < 8'd8) ? counter + 8'd1 : counter;
+        default: counter <= 8'd0;
+      endcase
+    end
+  end
+
+  // Receive cmd(READ: EBh, WRITE: 38h)
+  always @(posedge sck or posedge reset) begin
+    if (reset) cmd <= 8'd0;
+    else if (qpi) cmd <= (state == cmd_t) ? {cmd[3:0], dio} : cmd;
+    else cmd <= (state == cmd_t) ? {cmd[6:0], dio[0]} : cmd;
+  end
+
+  always @(posedge sck or posedge reset) begin
+    if (reset && !qpi) qpi <= 1'b0;
+    else if (state == addr_t && cmd == SET_QPI) qpi <= 1'b1;
+    else qpi <= qpi;
+  end
+
+  // Receive addr
+  always @(posedge sck or posedge reset) begin
+    if (reset) addr <= 24'd0;
+    else begin
+      addr <= (state == addr_t) ? {addr[19:0], dio} : addr;
+    end
+  end
+
+  // Receive Wdata
+  always @(posedge sck or posedge reset) begin
+    if (reset) receive_data <= 32'd0;
+    else begin
+      receive_data <= (state == data_t && cmd == WRITE) ? {receive_data[27:0], dio} : receive_data;
+    end
+  end
+
+  always @(*) begin
+    case (len)
+      3'd1: wdata = {24'd0, receive_data[7:0]};
+      3'd2: wdata = {16'd0, receive_data[7:0], receive_data[15:8]};
+      3'd4: wdata = {receive_data[7:0], receive_data[15:8], receive_data[23:16], receive_data[31:24]};
+      default: wdata = 32'd0;
+    endcase
+  end
+
+  always @(*) begin
+    case (counter)
+      8'd2: len = 3'd1;
+      8'd4: len = 3'd2;
+      8'd8: len = 3'd4;
+      default: len = 3'd4;
+    endcase
+  end
+  // Read or Write date to PSRAM
+  import "DPI-C" function int psram_read(
+    input  int  raddr
+  );
+  import "DPI-C" function void psram_write(
+    input int  waddr,
+    input int  receive_data,
+    input int  len
+  );
+  always @(posedge sck or posedge reset) begin
+    if (reset) rdata <= 32'd0;
+    else if (ren) rdata <= psram_read({8'd0, addr});
+  end
+  always @(posedge reset) begin
+    if (cmd == WRITE) psram_write({8'd0, addr}, wdata, { 29'd0, len});
+  end
+
+  // Output rdata
+  always @(posedge sck) begin
+    if (state == data_t && cmd == READ) begin
+      data <= counter == 8'd0 ? {rdata[7:0], rdata[15:8], rdata[23:16], rdata[31:24]} : {data[27:0], 4'd0};
+    end
+  end
+
+  assign dout = ce_n ? 4'b1111 : data[31:28];
 
 endmodule
diff --git a/perip/sdram/core_sdram_axi4/sdram_axi.v b/perip/sdram/core_sdram_axi4/sdram_axi.v
index 64641f58..f37f35a2 100644
--- a/perip/sdram/core_sdram_axi4/sdram_axi.v
+++ b/perip/sdram/core_sdram_axi4/sdram_axi.v
@@ -53,7 +53,7 @@ module sdram_axi
     ,input  [  7:0]  inport_arlen_i
     ,input  [  1:0]  inport_arburst_i
     ,input           inport_rready_i
-    ,input  [ 15:0]  sdram_data_input_i
+    ,input  [ 31:0]  sdram_data_input_i
 
     // Outputs
     ,output          inport_awready_o
@@ -73,15 +73,14 @@ module sdram_axi
     ,output          sdram_ras_o
     ,output          sdram_cas_o
     ,output          sdram_we_o
-    ,output [  1:0]  sdram_dqm_o
-    ,output [ 12:0]  sdram_addr_o
+    ,output [  3:0]  sdram_dqm_o
+    ,output [ 13:0]  sdram_addr_o
     ,output [  1:0]  sdram_ba_o
-    ,output [ 15:0]  sdram_data_output_o
+    ,output [ 31:0]  sdram_data_output_o
     ,output          sdram_data_out_en_o
+    ,output [  1:0]  sdram_select_h_o
 );
 
-
-
 //-----------------------------------------------------------------
 // Key Params
 //-----------------------------------------------------------------
@@ -187,6 +186,7 @@ u_core
     ,.sdram_data_output_o(sdram_data_output_o)
     ,.sdram_data_out_en_o(sdram_data_out_en_o)
     ,.sdram_data_input_i(sdram_data_input_i)
+    ,.sdram_select_h_o(sdram_select_h_o)
 );
 
 
diff --git a/perip/sdram/core_sdram_axi4/sdram_axi_core.v b/perip/sdram/core_sdram_axi4/sdram_axi_core.v
index cedbf77b..77e22786 100644
--- a/perip/sdram/core_sdram_axi4/sdram_axi_core.v
+++ b/perip/sdram/core_sdram_axi4/sdram_axi_core.v
@@ -42,7 +42,7 @@ module sdram_axi_core
     ,input  [  7:0]  inport_len_i
     ,input  [ 31:0]  inport_addr_i
     ,input  [ 31:0]  inport_write_data_i
-    ,input  [ 15:0]  sdram_data_input_i
+    ,input  [ 31:0]  sdram_data_input_i
 
     // Outputs
     ,output          inport_accept_o
@@ -55,11 +55,12 @@ module sdram_axi_core
     ,output          sdram_ras_o
     ,output          sdram_cas_o
     ,output          sdram_we_o
-    ,output [  1:0]  sdram_dqm_o
-    ,output [ 12:0]  sdram_addr_o
+    ,output [  3:0]  sdram_dqm_o
+    ,output [ 13:0]  sdram_addr_o
     ,output [  1:0]  sdram_ba_o
-    ,output [ 15:0]  sdram_data_output_o
+    ,output [ 31:0]  sdram_data_output_o
     ,output          sdram_data_out_en_o
+    ,output [  1:0]  sdram_select_h_o
 );
 
 
@@ -68,7 +69,7 @@ module sdram_axi_core
 // Key Params
 //-----------------------------------------------------------------
 parameter SDRAM_MHZ              = 50;
-parameter SDRAM_ADDR_W           = 24;
+parameter SDRAM_ADDR_W           = 25;
 parameter SDRAM_COL_W            = 9;
 parameter SDRAM_READ_LATENCY     = 2;
 
@@ -76,9 +77,10 @@ parameter SDRAM_READ_LATENCY     = 2;
 // Defines / Local params
 //-----------------------------------------------------------------
 localparam SDRAM_BANK_W          = 2;
-localparam SDRAM_DQM_W           = 2;
+localparam SDRAM_DQM_W           = 4;
 localparam SDRAM_BANKS           = 2 ** SDRAM_BANK_W;
-localparam SDRAM_ROW_W           = SDRAM_ADDR_W - SDRAM_COL_W - SDRAM_BANK_W;
+// localparam SDRAM_ROW_W           = SDRAM_ADDR_W - SDRAM_COL_W - SDRAM_BANK_W;
+localparam SDRAM_ROW_W           = 14; // xhf
 localparam SDRAM_REFRESH_CNT     = 2 ** SDRAM_ROW_W;
 localparam SDRAM_START_DELAY     = 100000 / (1000 / SDRAM_MHZ); // 100uS
 localparam SDRAM_REFRESH_CYCLES  = (64000*SDRAM_MHZ) / SDRAM_REFRESH_CNT-1;
@@ -94,7 +96,7 @@ localparam CMD_REFRESH       = 4'b0001;
 localparam CMD_LOAD_MODE     = 4'b0000;
 
 // Mode: Burst Length = 4 bytes, CAS=2
-localparam MODE_REG          = {3'b000,1'b0,2'b00,3'b010,1'b0,3'b001};
+localparam MODE_REG          = {3'b000,1'b0,2'b00,3'b010,1'b0,3'b000};
 
 // SM states
 localparam STATE_W           = 4;
@@ -105,14 +107,14 @@ localparam STATE_ACTIVATE    = 4'd3;
 localparam STATE_READ        = 4'd4;
 localparam STATE_READ_WAIT   = 4'd5;
 localparam STATE_WRITE0      = 4'd6;
-localparam STATE_WRITE1      = 4'd7;
+// localparam STATE_WRITE1      = 4'd7;
 localparam STATE_PRECHARGE   = 4'd8;
 localparam STATE_REFRESH     = 4'd9;
 
 localparam AUTO_PRECHARGE    = 10;
 localparam ALL_BANKS         = 10;
 
-localparam SDRAM_DATA_W      = 16;
+localparam SDRAM_DATA_W      = 32;
 
 localparam CYCLE_TIME_NS     = 1000 / SDRAM_MHZ;
 
@@ -160,8 +162,8 @@ reg                    cke_q;
 reg [SDRAM_BANK_W-1:0] bank_q;
 
 // Buffer half word during read and write commands
-reg [SDRAM_DATA_W-1:0] data_buffer_q;
-reg [SDRAM_DQM_W-1:0]  dqm_buffer_q;
+// reg [SDRAM_DATA_W-1:0] data_buffer_q;
+// reg [SDRAM_DQM_W-1:0]  dqm_buffer_q;
 
 wire [SDRAM_DATA_W-1:0] sdram_data_in_w;
 
@@ -178,9 +180,25 @@ reg  [STATE_W-1:0]     delay_state_q;
 
 // Address bits
 wire [SDRAM_ROW_W-1:0]  addr_col_w  = {{(SDRAM_ROW_W-SDRAM_COL_W){1'b0}}, ram_addr_w[SDRAM_COL_W:2], 1'b0};
-wire [SDRAM_ROW_W-1:0]  addr_row_w  = ram_addr_w[SDRAM_ADDR_W:SDRAM_COL_W+2+1];
+wire [SDRAM_ROW_W-1:0]  addr_row_w  = ram_addr_w[25:12]; // xhf
 wire [SDRAM_BANK_W-1:0] addr_bank_w = ram_addr_w[SDRAM_COL_W+2:SDRAM_COL_W+2-1];
 
+//  64MB select
+reg    [1:0]              select_h_q;
+assign sdram_select_h_o = select_h_q;
+
+always @ (posedge ram_req_w or posedge rst_i) begin
+    if (rst_i) select_h_q <= 2'b11;
+    else if (state_q == STATE_INIT) begin
+        select_h_q <= 2'b11;
+    end
+    else begin
+        if (ram_req_w) select_h_q <= {addr_row_w[SDRAM_ROW_W - 1], ~addr_row_w[SDRAM_ROW_W - 1]};
+        else select_h_q <= select_h_q;
+    end
+end
+
+
 //-----------------------------------------------------------------
 // SDRAM State Machine
 //-----------------------------------------------------------------
@@ -284,23 +302,31 @@ begin
     //-----------------------------------------
     STATE_WRITE0 :
     begin
-        next_state_r = STATE_WRITE1;
+        next_state_r = STATE_IDLE;
+
+        // Another pending write request (with no refresh pending)
+        // if (!refresh_q && ram_req_w && (ram_wr_w != 4'b0))
+        // begin
+        //     // Open row hit
+        //     if (row_open_q[addr_bank_w] && addr_row_w == active_row_q[addr_bank_w])
+        //         next_state_r = STATE_WRITE0;
+        // end
     end
     //-----------------------------------------
     // STATE_WRITE1
     //-----------------------------------------
-    STATE_WRITE1 :
-    begin
-        next_state_r = STATE_IDLE;
+    // STATE_WRITE1 :
+    // begin
+    //     next_state_r = STATE_IDLE;
 
-        // Another pending write request (with no refresh pending)
-        if (!refresh_q && ram_req_w && (ram_wr_w != 4'b0))
-        begin
-            // Open row hit
-            if (row_open_q[addr_bank_w] && addr_row_w == active_row_q[addr_bank_w])
-                next_state_r = STATE_WRITE0;
-        end
-    end
+    //     // Another pending write request (with no refresh pending)
+    //     if (!refresh_q && ram_req_w && (ram_wr_w != 4'b0))
+    //     begin
+    //         // Open row hit
+    //         if (row_open_q[addr_bank_w] && addr_row_w == active_row_q[addr_bank_w])
+    //             next_state_r = STATE_WRITE0;
+    //     end
+    // end
     //-----------------------------------------
     // STATE_PRECHARGE
     //-----------------------------------------
@@ -483,13 +509,13 @@ always @ (posedge clk_i or posedge rst_i)
 if (rst_i)
 begin
     command_q       <= CMD_NOP;
-    data_q          <= 16'b0;
+    data_q          <= {SDRAM_DATA_W{1'b0}};
     addr_q          <= {SDRAM_ROW_W{1'b0}};
     bank_q          <= {SDRAM_BANK_W{1'b0}};
     cke_q           <= 1'b0;
     dqm_q           <= {SDRAM_DQM_W{1'b0}};
     data_rd_en_q    <= 1'b1;
-    dqm_buffer_q    <= {SDRAM_DQM_W{1'b0}};
+    // dqm_buffer_q    <= {SDRAM_DQM_W{1'b0}};
 
     for (idx=0;idx<SDRAM_BANKS;idx=idx+1)
         active_row_q[idx] <= {SDRAM_ROW_W{1'b0}};
@@ -537,7 +563,7 @@ begin
         else if (refresh_timer_q == 10)
         begin
             command_q <= CMD_LOAD_MODE;
-            addr_q    <= MODE_REG;
+            addr_q    <= {1'b0, MODE_REG};
         end
         // Other cycles during init - just NOP
         else
@@ -616,33 +642,34 @@ begin
         command_q       <= CMD_WRITE;
         addr_q          <= addr_col_w;
         bank_q          <= addr_bank_w;
-        data_q          <= ram_write_data_w[15:0];
+        data_q          <= ram_write_data_w;
 
         // Disable auto precharge (auto close of row)
         addr_q[AUTO_PRECHARGE]  <= 1'b0;
 
         // Write mask
-        dqm_q           <= ~ram_wr_w[1:0];
-        dqm_buffer_q    <= ~ram_wr_w[3:2];
+        dqm_q           <= ~ram_wr_w;
+        // dqm_q           <= ~ram_wr_w[1:0];
+        // dqm_buffer_q    <= ~ram_wr_w[3:2];
 
         data_rd_en_q    <= 1'b0;
     end
     //-----------------------------------------
     // STATE_WRITE1
     //-----------------------------------------
-    STATE_WRITE1 :
-    begin
-        // Burst continuation
-        command_q   <= CMD_NOP;
+    // STATE_WRITE1 :
+    // begin
+    //     // Burst continuation
+    //     command_q   <= CMD_NOP;
 
-        data_q      <= data_buffer_q;
+    //     data_q      <= data_buffer_q;
 
-        // Disable auto precharge (auto close of row)
-        addr_q[AUTO_PRECHARGE]  <= 1'b0;
+    //     // Disable auto precharge (auto close of row)
+    //     addr_q[AUTO_PRECHARGE]  <= 1'b0;
 
-        // Write mask
-        dqm_q       <= dqm_buffer_q;
-    end
+    //     // Write mask
+    //     dqm_q       <= dqm_buffer_q;
+    // end
     endcase
 end
 
@@ -663,16 +690,17 @@ else
 
 // Buffer upper 16-bits of write data so write command can be accepted
 // in WRITE0. Also buffer lower 16-bits of read data.
-always @ (posedge clk_i or posedge rst_i)
-if (rst_i)
-    data_buffer_q <= 16'b0;
-else if (state_q == STATE_WRITE0)
-    data_buffer_q <= ram_write_data_w[31:16];
-else if (rd_q[SDRAM_READ_LATENCY+1])
-    data_buffer_q <= sample_data_q;
+// always @ (posedge clk_i or posedge rst_i)
+// if (rst_i)
+//     data_buffer_q <= 16'b0;
+// else if (state_q == STATE_WRITE0)
+//     data_buffer_q <= ram_write_data_w[31:16];
+// else if (rd_q[SDRAM_READ_LATENCY+1])
+//     data_buffer_q <= sample_data_q;
 
 // Read data output
-assign ram_read_data_w = {sample_data_q, data_buffer_q};
+assign ram_read_data_w = sample_data_q;
+// assign ram_read_data_w = {sample_data_q, data_buffer_q};
 
 //-----------------------------------------------------------------
 // ACK
@@ -684,9 +712,9 @@ if (rst_i)
     ack_q   <= 1'b0;
 else
 begin
-    if (state_q == STATE_WRITE1)
+    if (state_q == STATE_WRITE0)
         ack_q <= 1'b1;
-    else if (rd_q[SDRAM_READ_LATENCY+1])
+    else if (rd_q[SDRAM_READ_LATENCY])
         ack_q <= 1'b1;
     else
         ack_q <= 1'b0;
@@ -730,7 +758,7 @@ begin
     STATE_READ        : dbg_state = "READ";
     STATE_READ_WAIT   : dbg_state = "READ_WAIT";
     STATE_WRITE0      : dbg_state = "WRITE0";
-    STATE_WRITE1      : dbg_state = "WRITE1";
+    // STATE_WRITE1      : dbg_state = "WRITE1";
     STATE_PRECHARGE   : dbg_state = "PRECHARGE";
     STATE_REFRESH     : dbg_state = "REFRESH";
     default           : dbg_state = "UNKNOWN";
diff --git a/perip/sdram/core_sdram_axi4/sdram_axi_pmem.v b/perip/sdram/core_sdram_axi4/sdram_axi_pmem.v
index 3d6a5bb4..e8fccd55 100644
--- a/perip/sdram/core_sdram_axi4/sdram_axi_pmem.v
+++ b/perip/sdram/core_sdram_axi4/sdram_axi_pmem.v
@@ -89,7 +89,7 @@ function [31:0] calculate_addr_next;
 
     reg [31:0]   mask;
 begin
-    mask = 0;
+    // mask = 0;
 
     case (axtype)
     2'd0: // AXI4_BURST_FIXED
@@ -99,12 +99,12 @@ begin
     2'd2: // AXI4_BURST_WRAP
     begin
         case (axlen)
-        8'd0:      mask = 32'h03;
-        8'd1:      mask = 32'h07;
-        8'd3:      mask = 32'h0F;
-        8'd7:      mask = 32'h1F;
-        8'd15:     mask = 32'h3F;
-        default:   mask = 32'h3F;
+        8'd0:      mask <= 32'h03;
+        8'd1:      mask <= 32'h07;
+        8'd3:      mask <= 32'h0F;
+        8'd7:      mask <= 32'h1F;
+        8'd15:     mask <= 32'h3F;
+        default:   mask <= 32'h3F;
         endcase
 
         calculate_addr_next = (addr & ~mask) | ((addr + 4) & mask);
diff --git a/perip/sdram/sdram.v b/perip/sdram/sdram.v
index 3613b231..74455162 100644
--- a/perip/sdram/sdram.v
+++ b/perip/sdram/sdram.v
@@ -1,16 +1,207 @@
 module sdram(
-  input        clk,
-  input        cke,
-  input        cs,
-  input        ras,
-  input        cas,
-  input        we,
-  input [12:0] a,
-  input [ 1:0] ba,
-  input [ 1:0] dqm,
-  inout [15:0] dq
+  input         clk,
+  input         cke,
+  input         cs,
+  input         ras,
+  input         cas,
+  input         we,
+  input [13 :0] a,
+  input [1  :0] ba,
+  input [1  :0] dqm,
+  inout [15 :0] dq
 );
 
-  assign dq = 16'bz;
+  wire [2  :0] cmd;
+  wire [31 :0] waddr;
+  wire [31 :0] raddr;
+  wire [3  :0] burst_length_num;
+
+  /** Mode Register */
+  reg  [2  :0] burst_length;
+  reg  [2  :0] cas_latency;
+
+  reg  [3  :0] burst_cnt;
+  reg  [2  :0] read_cnt;
+  reg  [31 :0] read_buffer;
+  reg  [13 :0] row_buffer [0:3];
+  reg  [8  :0] col_addr;
+  reg  [1  :0] bank_addr;
+
+enum reg [2:0] {
+    idle_t,
+    set_reg_t,
+    read_t,
+    write_t
+} state, nstate;
+
+  localparam LOAD_MODE_REGISTER = 3'b000;
+  localparam ACTIVE             = 3'b011;
+  localparam READ               = 3'b101;
+  localparam WRITE              = 3'b100;
+
+  assign cmd  = {ras, cas, we};
+  assign dq   = (state == read_t) ? read_buffer[15:0] : 16'bz;
+  assign waddr = cmd == WRITE ? 
+                 {6'd0, row_buffer[ba], ba, ({1'b0, a[8:0]} << 1)}
+               : {6'd0, row_buffer[bank_addr], bank_addr, ({1'b0, col_addr} << 1)};
+  assign raddr = {6'd0, row_buffer[bank_addr], bank_addr, ({1'b0, col_addr} << 1)};
+  assign burst_length_num = 4'd1 << burst_length;
+
+  /* === State Machine ======================================= */
+  /** switch to nstate */
+  always @(posedge clk) begin
+    if (!cke)     state <= idle_t;
+    else if (!cs) state <= nstate;
+    else          state <= state;
+  end
+
+  /** nstate logic */
+  always @(*) begin
+    if (!cs) begin
+      case (state)
+        idle_t: begin
+          case (cmd)
+            LOAD_MODE_REGISTER: nstate = set_reg_t;
+            READ:               nstate = read_t;
+            WRITE:              nstate = write_t;
+            default:            nstate = idle_t;
+          endcase
+        end
+        set_reg_t: begin
+          nstate = idle_t;
+        end
+        read_t: begin
+          if (read_cnt == cas_latency && burst_cnt == burst_length_num) begin
+            if (cmd == WRITE) nstate = write_t;
+            else if (cmd == READ) nstate = read_t;
+            else nstate = idle_t;
+          end else begin
+            nstate = read_t;
+          end
+        end
+        write_t: begin
+          if (burst_cnt == burst_length_num) begin
+            if (cmd == READ) nstate = read_t;
+            else nstate = idle_t;
+          end else begin
+            nstate = write_t;
+          end
+        end
+        default: nstate = idle_t;
+      endcase
+    end
+  end
+
+  /** set mode register */
+  always @(posedge clk) begin
+    if (!cke) begin
+      burst_length <= 3'b0;
+      cas_latency  <= 3'b0;
+    end else if (cmd == LOAD_MODE_REGISTER) begin
+      burst_length <= a[2:0];
+      cas_latency  <= a[6:4];
+    end else begin
+      burst_length <= burst_length;
+      cas_latency  <= cas_latency;
+    end
+  end
+
+  /** set row_buffer */
+  always @(posedge clk) begin
+    if (!cke) begin
+      row_buffer[0] <= 14'd0;
+      row_buffer[1] <= 14'd0;
+      row_buffer[2] <= 14'd0;
+      row_buffer[3] <= 14'd0;
+    end else if (cmd == ACTIVE) begin
+      row_buffer[ba] <= a;
+    end else begin
+      row_buffer[0] <= row_buffer[0];
+      row_buffer[1] <= row_buffer[1];
+      row_buffer[2] <= row_buffer[2];
+      row_buffer[3] <= row_buffer[3];
+    end
+  end
+
+  /** set bank, col waddr */
+  always @(posedge clk) begin
+    if (!cke) begin
+      bank_addr <= 2'd0;
+      col_addr  <= 9'd0;
+    end else if (cmd == ACTIVE) begin
+      bank_addr <= ba;
+    end else if (cmd == READ || cmd == WRITE) begin
+      bank_addr <= ba;
+      col_addr  <= a[8:0];
+    end else begin
+      bank_addr <= bank_addr;
+      col_addr  <= col_addr;
+    end
+  end
+
+  /** conut read_cnt or burst_cnt */
+  always @(posedge clk) begin
+    if (!cke) begin
+      burst_cnt <= 4'b0;
+    end else if (cmd == READ || state == read_t) begin
+      if (read_cnt == cas_latency && burst_cnt == burst_length_num) begin
+        burst_cnt <= 4'b0;
+      end else if (state == read_t) begin
+        burst_cnt <= burst_cnt + 4'b1;
+      end else begin
+        burst_cnt <= burst_cnt;
+      end
+    end else if (cmd == WRITE || state == write_t) begin
+      if (burst_cnt == burst_length_num) begin
+        burst_cnt <= 4'b0;
+      end else begin
+        burst_cnt <= burst_cnt + 4'b1;
+      end
+    end else begin
+      burst_cnt <= burst_cnt;
+    end
+  end
+
+  always @(posedge clk) begin
+    if (!cke) begin
+      read_cnt  <= 3'b0;
+    end else if (cmd == READ || state == read_t) begin
+      if (read_cnt == cas_latency && burst_cnt == burst_length_num) begin
+        if (cmd == READ) read_cnt <= 3'b1;
+        else read_cnt <= 3'b0;
+      end else begin
+        read_cnt <= read_cnt + 3'b1;
+      end
+    end else begin
+      read_cnt  <= read_cnt;
+    end
+  end
+
+  /* === Read or Write date to SDRAM ========================== */
+  import "DPI-C" function int sdram_read0(
+    input  int  raddr
+  );
+  import "DPI-C" function void sdram_write0(
+    input int  waddr,
+    input int  receive_data,
+    input int  len
+  );
+  
+  always @(posedge clk) begin
+    if (!cke) begin
+      read_buffer <= 32'd0;
+    end else if (state == read_t && burst_cnt != burst_length_num) begin
+        read_buffer <= sdram_read0(raddr);
+    end else if (cmd == WRITE || state == WRITE && burst_cnt != burst_length_num) begin
+      case (dqm)
+        2'b10: sdram_write0(waddr, {24'd0, dq[7 :0]}, 32'd1);
+        2'b01: sdram_write0(waddr + 32'b1, {24'd0, dq[15:8]}, 32'd1);
+        2'b00: sdram_write0(waddr, {16'd0, dq      }, 32'd2);
+        default: ;
+      endcase
+    end else begin
+      read_buffer <= read_buffer;
+    end
+  end
 
 endmodule
diff --git a/perip/sdram/sdram_top_apb.v b/perip/sdram/sdram_top_apb.v
index 3bc5b93b..bc1540ab 100644
--- a/perip/sdram/sdram_top_apb.v
+++ b/perip/sdram/sdram_top_apb.v
@@ -18,15 +18,16 @@ module sdram_top_apb (
   output        sdram_ras,
   output        sdram_cas,
   output        sdram_we,
-  output [12:0] sdram_a,
+  output [13:0] sdram_a,
   output [ 1:0] sdram_ba,
-  output [ 1:0] sdram_dqm,
-  inout  [15:0] sdram_dq
+  output [ 3:0] sdram_dqm,
+  inout  [31:0] sdram_dq,
+  output [ 1:0] sdram_select_h
 );
 
   wire sdram_dout_en;
-  wire [15:0] sdram_dout;
-  assign sdram_dq = sdram_dout_en ? sdram_dout : 16'bz;
+  wire [31:0] sdram_dout;
+  assign sdram_dq = sdram_dout_en ? sdram_dout : 32'bz;
 
   typedef enum [1:0] { ST_IDLE, ST_WAIT_ACCEPT, ST_WAIT_ACK } state_t;
   reg [1:0] state;
@@ -47,7 +48,7 @@ module sdram_top_apb (
   wire is_write = ((in_psel && !in_penable) || (state == ST_WAIT_ACCEPT)) &&  in_pwrite;
   sdram_axi_core #(
     .SDRAM_MHZ(100),
-    .SDRAM_ADDR_W(24),
+    .SDRAM_ADDR_W(25),
     .SDRAM_COL_W(9),
     .SDRAM_READ_LATENCY(2)
   ) u_sdram_ctrl(
@@ -74,7 +75,8 @@ module sdram_top_apb (
     .sdram_ba_o(sdram_ba),
     .sdram_data_input_i(sdram_dq),
     .sdram_data_output_o(sdram_dout),
-    .sdram_data_out_en_o(sdram_dout_en)
+    .sdram_data_out_en_o(sdram_dout_en),
+    .sdram_select_h_o(sdram_select_h)
   );
 
 endmodule
diff --git a/perip/sdram/sdram_top_axi.v b/perip/sdram/sdram_top_axi.v
index f0fd6fdb..5d8e785b 100644
--- a/perip/sdram/sdram_top_axi.v
+++ b/perip/sdram/sdram_top_axi.v
@@ -37,15 +37,16 @@ module sdram_top_axi(
   output        sdram_ras,
   output        sdram_cas,
   output        sdram_we,
-  output [12:0] sdram_a,
+  output [13:0] sdram_a,
   output [ 1:0] sdram_ba,
-  output [ 1:0] sdram_dqm,
-  inout  [15:0] sdram_dq
+  output [ 3:0] sdram_dqm,
+  inout  [31:0] sdram_dq,
+  output [ 1:0] sdram_select_h
 );
 
   wire sdram_dout_en;
-  wire [15:0] sdram_dout;
-  assign sdram_dq = sdram_dout_en ? sdram_dout : 16'bz;
+  wire [31:0] sdram_dout;
+  assign sdram_dq = sdram_dout_en ? sdram_dout : 32'bz;
   sdram_axi #(
     .SDRAM_MHZ(100),
     .SDRAM_ADDR_W(24),
@@ -93,7 +94,8 @@ module sdram_top_axi(
     .sdram_ba_o(sdram_ba),
     .sdram_data_input_i(sdram_dq),
     .sdram_data_output_o(sdram_dout),
-    .sdram_data_out_en_o(sdram_dout_en)
+    .sdram_data_out_en_o(sdram_dout_en),
+    .sdram_select_h_o(sdram_select_h)
   );
 
 endmodule
diff --git a/perip/spi/rtl/spi_top_apb.v b/perip/spi/rtl/spi_top_apb.v
index 92d37516..89445758 100644
--- a/perip/spi/rtl/spi_top_apb.v
+++ b/perip/spi/rtl/spi_top_apb.v
@@ -1,6 +1,6 @@
 // define this macro to enable fast behavior simulation
 // for flash by skipping SPI transfers
-//`define FAST_FLASH
+// `define FAST_FLASH
 
 module spi_top_apb #(
   parameter flash_addr_start = 32'h30000000,
@@ -27,6 +27,98 @@ module spi_top_apb #(
   output                  spi_irq_out
 );
 
+typedef enum [1:0] { IDLE, WRITE, WAIT_COMPLETE, READ_DATA } state_t;
+
+wire [4  :0] xip_paddr;
+wire [31 :0] xip_pwdata;
+wire [3  :0] xip_pstrb;
+wire         xip_pwrite;
+wire         xip_psel;
+wire         xip_penable;
+wire         xip_pready;
+
+wire [4  :0] to_spi_top_paddr;
+wire [31 :0] to_spi_top_pwdata;
+wire [3  :0] to_spi_top_pstrb;
+wire         to_spi_top_pwrite;
+wire         to_spi_top_psel;
+wire         to_spi_top_penable;
+
+wire         in_flash;
+
+reg  [1  :0] state;
+reg  [2  :0] cnt;
+
+// cnt
+// 0: To Tx[31:0]  , write 0
+// 1: To Tx[63:32] , write {8'h03, in_paddr[23:2], 2'b0}
+// 2: To DIVIDER   , write 1
+// 3: To SS        , write 1
+// 4: To CTRL      , write 0x140
+// 5: From CTRL    , read GO_BUSY(CTRL[8]) if 1
+// 6: From Tx[31:0], read memory data
+// 7: To SS        , write 0
+
+assign in_flash    = (in_paddr >= flash_addr_start) && (in_paddr <= flash_addr_end);
+assign xip_paddr   = {5{cnt == 1}} & 5'h4
+                   | {5{cnt == 2}} & 5'h14
+                   | {5{cnt == 3}} & 5'h18
+                   | {5{cnt == 4}} & 5'h10
+                   | {5{cnt == 5}} & 5'h10
+                   | {5{cnt == 6}} & 5'h0
+                   | {5{cnt == 7}} & 5'h18;
+assign xip_pwdata  = {32{cnt == 1}} & {8'h03, in_paddr[23:2], 2'b0}
+                   | {32{cnt == 2}} & 32'h1
+                   | {32{cnt == 3}} & 32'h1
+                   | {32{cnt == 4}} & 32'h1140
+                   | {32{cnt == 7}} & 32'h0;
+assign xip_pstrb   = (state == WRITE) ? 4'hf : 4'h0;
+assign xip_pwrite  = (state == WRITE) ? 1'b1 : 1'h0;
+assign xip_psel    = xip_penable;
+assign xip_penable = !((state == IDLE) || (state == WAIT_COMPLETE));
+
+always @(posedge clock) begin
+  if (reset) begin
+    state <= IDLE;
+    cnt   <= 1;
+  end else begin
+    case (state)
+      IDLE: begin
+        if (in_flash && in_penable) begin
+          cnt   <= 1;
+          state <= WRITE;
+        end
+      end
+      WRITE: begin
+        if (xip_pready) begin
+          if (cnt == 4) begin
+            cnt <= cnt + 1;
+            state <= WAIT_COMPLETE;
+          end else if (cnt == 7) begin
+            cnt   <= 1;
+            state <= IDLE;
+          end else begin
+            cnt <= cnt + 1;
+          end
+        end
+      end
+      WAIT_COMPLETE: begin
+        if (spi_irq_out) begin
+          cnt   <= cnt + 1;
+          state <= READ_DATA;
+        end
+      end
+      READ_DATA: begin
+        if (xip_pready) begin
+          cnt   <= cnt + 1;
+          state <= WRITE;
+        end
+      end
+    endcase
+  end
+end
+
+
 `ifdef FAST_FLASH
 
 wire [31:0] data;
@@ -48,17 +140,25 @@ assign in_prdata  = data[31:0];
 
 `else
 
+assign to_spi_top_paddr   = (state == IDLE) ? in_paddr[4:0] : xip_paddr;
+assign to_spi_top_pwdata  = (state == IDLE) ? in_pwdata : xip_pwdata;
+assign to_spi_top_pstrb   = (state == IDLE) ? in_pstrb : xip_pstrb;
+assign to_spi_top_pwrite  = (state == IDLE) ? in_pwrite : xip_pwrite;
+assign to_spi_top_psel    = (state == IDLE) ? in_psel : xip_psel;
+assign to_spi_top_penable = ((state == IDLE) && !in_flash) ? in_penable : xip_penable;
+assign in_pready          = (state == WRITE || state == WAIT_COMPLETE) ? 1'b0 : xip_pready;
+
 spi_top u0_spi_top (
   .wb_clk_i(clock),
   .wb_rst_i(reset),
-  .wb_adr_i(in_paddr[4:0]),
-  .wb_dat_i(in_pwdata),
+  .wb_adr_i(to_spi_top_paddr),
+  .wb_dat_i(to_spi_top_pwdata),
   .wb_dat_o(in_prdata),
-  .wb_sel_i(in_pstrb),
-  .wb_we_i (in_pwrite),
-  .wb_stb_i(in_psel),
-  .wb_cyc_i(in_penable),
-  .wb_ack_o(in_pready),
+  .wb_sel_i(to_spi_top_pstrb),
+  .wb_we_i (to_spi_top_pwrite),
+  .wb_stb_i(to_spi_top_psel),
+  .wb_cyc_i(to_spi_top_penable),
+  .wb_ack_o(xip_pready),
   .wb_err_o(in_pslverr),
   .wb_int_o(spi_irq_out),
 
diff --git a/perip/uart16550/rtl/uart_tfifo.v b/perip/uart16550/rtl/uart_tfifo.v
index 71329116..7eed245a 100644
--- a/perip/uart16550/rtl/uart_tfifo.v
+++ b/perip/uart16550/rtl/uart_tfifo.v
@@ -211,7 +211,8 @@ begin
             begin
                 top   <= #1 top_plus_1;
                 count <= #1 count + 1'b1;
-                $write("%c", data_in);
+                // $write("%c", data_in);
+                // $fflush();
             end
         2'b01 : if(count>0)
             begin
@@ -221,7 +222,8 @@ begin
         2'b11 : begin
                 bottom <= #1 bottom + 1'b1;
                 top    <= #1 top_plus_1;
-                $write("%c", data_in);
+                // $write("%c", data_in);
+                // $fflush();
                 end
         default: ;
         endcase
diff --git a/perip/vga/vga_top_apb.v b/perip/vga/vga_top_apb.v
index 5c74cfbe..b6ee3818 100644
--- a/perip/vga/vga_top_apb.v
+++ b/perip/vga/vga_top_apb.v
@@ -20,4 +20,107 @@ module vga_top_apb(
   output        vga_valid
 );
 
+parameter vga_base = 32'h21000000;
+
+reg [31:0] buffer [0:307199]; // 640*480
+
+wire is_write = (in_psel && !in_penable) && in_pwrite;
+wire [31:0] waddr = (in_paddr - vga_base) >> 2;
+wire address_valid = (waddr < 307200);
+
+always @(posedge clock) begin
+  if (is_write && address_valid) begin
+    buffer[waddr] <= in_pwdata;
+  end
+end
+
+wire [9:0] h_addr;
+wire [9:0] v_addr;
+wire [31:0] raddr = {22'd0, v_addr} * 640 + {22'd0, h_addr};
+
+assign in_pready = 1'b1;
+assign in_pslverr = !(in_paddr >= vga_base && in_paddr <= vga_base + 307200 * 4);
+
+vga_ctrl vga_ctrl_inst(
+  .pclk(clock),
+  .reset(reset),
+  .vga_data(buffer[raddr][23:0]),
+  .h_addr(h_addr),
+  .v_addr(v_addr),
+  .hsync(vga_hsync),
+  .vsync(vga_vsync),
+  .valid(vga_valid),
+  .vga_r(vga_r),
+  .vga_g(vga_g),
+  .vga_b(vga_b)
+);
+
+endmodule
+
+module vga_ctrl(
+    input           pclk,     //25MHz时钟
+    input           reset,    //置位
+    input  [23:0]   vga_data, //上层模块提供的VGA颜色数据
+    output [9:0]    h_addr,   //提供给上层模块的当前扫描像素点坐标
+    output [9:0]    v_addr,
+    output          hsync,    //行同步和列同步信号
+    output          vsync,
+    output          valid,    //消隐信号
+    output [7:0]    vga_r,    //红绿蓝颜色信号
+    output [7:0]    vga_g,
+    output [7:0]    vga_b
+    );
+
+  //640x480分辨率下的VGA参数设置
+  parameter    h_frontporch = 96;
+  parameter    h_active = 144;
+  parameter    h_backporch = 784;
+  parameter    h_total = 800;
+
+  parameter    v_frontporch = 2;
+  parameter    v_active = 35;
+  parameter    v_backporch = 515;
+  parameter    v_total = 525;
+
+  //像素计数值
+  reg [9:0]    x_cnt;
+  reg [9:0]    y_cnt;
+  wire         h_valid;
+  wire         v_valid;
+
+  always @(posedge reset or posedge pclk) //行像素计数
+      if (reset == 1'b1)
+        x_cnt <= 1;
+      else
+      begin
+        if (x_cnt == h_total)
+            x_cnt <= 1;
+        else
+            x_cnt <= x_cnt + 10'd1;
+      end
+
+  always @(posedge pclk)  //列像素计数
+      if (reset == 1'b1)
+        y_cnt <= 1;
+      else
+      begin
+        if (y_cnt == v_total & x_cnt == h_total)
+            y_cnt <= 1;
+        else if (x_cnt == h_total)
+            y_cnt <= y_cnt + 10'd1;
+      end
+  //生成同步信号
+  assign hsync = (x_cnt > h_frontporch);
+  assign vsync = (y_cnt > v_frontporch);
+  //生成消隐信号
+  assign h_valid = (x_cnt > h_active) & (x_cnt <= h_backporch);
+  assign v_valid = (y_cnt > v_active) & (y_cnt <= v_backporch);
+  assign valid = h_valid & v_valid;
+  //计算当前有效像素坐标
+  assign h_addr = h_valid ? (x_cnt - 10'd145) : {10{1'b0}};
+  assign v_addr = v_valid ? (y_cnt - 10'd36) : {10{1'b0}};
+  //设置输出的颜色值
+  assign vga_r = vga_data[23:16];
+  assign vga_g = vga_data[15:8];
+  assign vga_b = vga_data[7:0];
 endmodule
diff --git a/src/CPU.scala b/src/CPU.scala
index 7559195f..6c38dfbd 100644
--- a/src/CPU.scala
+++ b/src/CPU.scala
@@ -13,7 +13,7 @@ object CPUAXI4BundleParameters {
   def apply() = AXI4BundleParameters(addrBits = 32, dataBits = 32, idBits = ChipLinkParam.idBits)
 }
 
-class ysyx_00000000 extends BlackBox {
+class ysyx_23060170 extends BlackBox {
   val io = IO(new Bundle {
     val clock = Input(Clock())
     val reset = Input(Reset())
@@ -35,7 +35,7 @@ class CPU(idBits: Int)(implicit p: Parameters) extends LazyModule {
     val interrupt = IO(Input(Bool()))
     val slave = IO(Flipped(AXI4Bundle(CPUAXI4BundleParameters())))
 
-    val cpu = Module(new ysyx_00000000)
+    val cpu = Module(new ysyx_23060170)
     cpu.io.clock := clock
     cpu.io.reset := reset
     cpu.io.io_interrupt := interrupt
diff --git a/src/SoC.scala b/src/SoC.scala
index 1c65cd87..4be26359 100644
--- a/src/SoC.scala
+++ b/src/SoC.scala
@@ -48,7 +48,7 @@ class ysyxSoCASIC(implicit p: Parameters) extends LazyModule {
   val lsdram_axi = if ( Config.sdramUseAXI) Some(LazyModule(new AXI4SDRAM(sdramAddressSet))) else None
 
   List(lspi.node, luart.node, lpsram.node, lgpio.node, lkeyboard.node, lvga.node).map(_ := apbxbar)
-  List(apbxbar := APBDelayer() := AXI4ToAPB() := AXI4Buffer(), lmrom.node, sramNode).map(_ := xbar2)
+  List(apbxbar := APBDelayer() := AXI4ToAPB(), lmrom.node, sramNode).map(_ := xbar2)
   xbar2 := AXI4UserYanker(Some(1)) := AXI4Fragmenter() := xbar
   if (Config.sdramUseAXI) lsdram_axi.get.node := ysyx.AXI4Delayer() := xbar
   else                    lsdram_apb.get.node := apbxbar
diff --git a/src/Top.scala b/src/Top.scala
index c00378a6..2913155b 100644
--- a/src/Top.scala
+++ b/src/Top.scala
@@ -7,7 +7,7 @@ import freechips.rocketchip.diplomacy.LazyModule
 
 object Config {
   def hasChipLink: Boolean = false
-  def sdramUseAXI: Boolean = false
+  def sdramUseAXI: Boolean = true
 }
 
 class ysyxSoCTop extends Module {
-- 
2.34.1

