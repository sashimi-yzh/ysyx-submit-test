From f56bf1b1b2f036870d193dca33f4ae68097faa8a Mon Sep 17 00:00:00 2001
From: "wuwenhui.wuwh" <wuwenhui.wuwh@bytedance.com>
Date: Mon, 4 Aug 2025 22:06:12 +0800
Subject: [PATCH 09/23] feat(soc): add sdram bit expand

---
 perip/sdram/core_sdram_axi4/sdram_axi_core.v  | 105 +--
 .../core_sdram_axi4/sdram_axi_core_old.v      | 743 ++++++++++++++++++
 perip/sdram/sdram_top_apb.v                   |  14 +-
 src/SoC.scala                                 |   3 +-
 src/device/SDRAM.scala                        |  68 +-
 5 files changed, 869 insertions(+), 64 deletions(-)
 create mode 100644 perip/sdram/core_sdram_axi4/sdram_axi_core_old.v

diff --git a/perip/sdram/core_sdram_axi4/sdram_axi_core.v b/perip/sdram/core_sdram_axi4/sdram_axi_core.v
index 7441d17..70fc6fd 100644
--- a/perip/sdram/core_sdram_axi4/sdram_axi_core.v
+++ b/perip/sdram/core_sdram_axi4/sdram_axi_core.v
@@ -42,7 +42,7 @@ module sdram_axi_core
     ,input  [  7:0]  inport_len_i
     ,input  [ 31:0]  inport_addr_i
     ,input  [ 31:0]  inport_write_data_i
-    ,input  [ 15:0]  sdram_data_input_i
+    ,input  [ 31:0]  sdram_data_input_i
 
     // Outputs
     ,output          inport_accept_o
@@ -55,10 +55,10 @@ module sdram_axi_core
     ,output          sdram_ras_o
     ,output          sdram_cas_o
     ,output          sdram_we_o
-    ,output [  1:0]  sdram_dqm_o
+    ,output [  3:0]  sdram_dqm_o
     ,output [ 12:0]  sdram_addr_o
     ,output [  1:0]  sdram_ba_o
-    ,output [ 15:0]  sdram_data_output_o
+    ,output [ 31:0]  sdram_data_output_o
     ,output          sdram_data_out_en_o
 );
 
@@ -76,7 +76,7 @@ parameter SDRAM_READ_LATENCY     = 2;
 // Defines / Local params
 //-----------------------------------------------------------------
 localparam SDRAM_BANK_W          = 2;
-localparam SDRAM_DQM_W           = 2;
+localparam SDRAM_DQM_W           = 4;
 localparam SDRAM_BANKS           = 2 ** SDRAM_BANK_W;
 localparam SDRAM_ROW_W           = SDRAM_ADDR_W - SDRAM_COL_W - SDRAM_BANK_W;
 localparam SDRAM_REFRESH_CNT     = 2 ** SDRAM_ROW_W;
@@ -93,8 +93,8 @@ localparam CMD_PRECHARGE     = 4'b0010;
 localparam CMD_REFRESH       = 4'b0001;
 localparam CMD_LOAD_MODE     = 4'b0000;
 
-// Mode: Burst Length = 4 bytes, CAS=2
-localparam MODE_REG          = {3'b000,1'b0,2'b00,3'b010,1'b0,3'b001};
+// Mode: Burst Length = 4 bytes, CAS=1
+localparam MODE_REG          = {3'b000,1'b0,2'b00,3'b001,1'b0,3'b000};
 
 // SM states
 localparam STATE_W           = 4;
@@ -112,7 +112,7 @@ localparam STATE_REFRESH     = 4'd9;
 localparam AUTO_PRECHARGE    = 10;
 localparam ALL_BANKS         = 10;
 
-localparam SDRAM_DATA_W      = 16;
+localparam SDRAM_DATA_W      = 32;
 
 localparam CYCLE_TIME_NS     = 1000 / SDRAM_MHZ;
 
@@ -283,13 +283,6 @@ begin
     // STATE_WRITE0
     //-----------------------------------------
     STATE_WRITE0 :
-    begin
-        next_state_r = STATE_WRITE1;
-    end
-    //-----------------------------------------
-    // STATE_WRITE1
-    //-----------------------------------------
-    STATE_WRITE1 :
     begin
         next_state_r = STATE_IDLE;
 
@@ -302,6 +295,21 @@ begin
         end
     end
     //-----------------------------------------
+    // STATE_WRITE1
+    //-----------------------------------------
+    // STATE_WRITE1 :
+    // begin
+    //     next_state_r = STATE_IDLE;
+
+    //     // Another pending write request (with no refresh pending)
+    //     if (!refresh_q && ram_req_w && (ram_wr_w != 4'b0))
+    //     begin
+    //         // Open row hit
+    //         if (row_open_q[addr_bank_w] && addr_row_w == active_row_q[addr_bank_w])
+    //             next_state_r = STATE_WRITE0;
+    //     end
+    // end
+    //-----------------------------------------
     // STATE_PRECHARGE
     //-----------------------------------------
     STATE_PRECHARGE :
@@ -460,12 +468,12 @@ else if (state_q == STATE_REFRESH)
 // Input sampling
 //-----------------------------------------------------------------
 
-reg [SDRAM_DATA_W-1:0] sample_data0_q;
-always @ (posedge clk_i or posedge rst_i)
-if (rst_i)
-    sample_data0_q <= {SDRAM_DATA_W{1'b0}};
-else
-    sample_data0_q <= sdram_data_in_w;
+// reg [SDRAM_DATA_W-1:0] sample_data0_q;
+// always @ (posedge clk_i or posedge rst_i)
+// if (rst_i)
+//     sample_data0_q <= {SDRAM_DATA_W{1'b0}};
+// else
+//     sample_data0_q <= sdram_data_in_w;
 
 reg [SDRAM_DATA_W-1:0] sample_data_q;
 always @ (posedge clk_i or posedge rst_i)
@@ -484,7 +492,7 @@ always @ (posedge clk_i or posedge rst_i)
 if (rst_i)
 begin
     command_q       <= CMD_NOP;
-    data_q          <= 16'b0;
+    data_q          <= 32'b0;
     addr_q          <= {SDRAM_ROW_W{1'b0}};
     bank_q          <= {SDRAM_BANK_W{1'b0}};
     cke_q           <= 1'b0;
@@ -617,33 +625,32 @@ begin
         command_q       <= CMD_WRITE;
         addr_q          <= addr_col_w;
         bank_q          <= addr_bank_w;
-        data_q          <= ram_write_data_w[15:0];
+        data_q          <= ram_write_data_w;
 
         // Disable auto precharge (auto close of row)
         addr_q[AUTO_PRECHARGE]  <= 1'b0;
 
         // Write mask
-        dqm_q           <= ~ram_wr_w[1:0];
-        dqm_buffer_q    <= ~ram_wr_w[3:2];
+        dqm_q           <= ~ram_wr_w;
 
         data_rd_en_q    <= 1'b0;
     end
-    //-----------------------------------------
-    // STATE_WRITE1
-    //-----------------------------------------
-    STATE_WRITE1 :
-    begin
-        // Burst continuation
-        command_q   <= CMD_NOP;
-
-        data_q      <= data_buffer_q;
-
-        // Disable auto precharge (auto close of row)
-        addr_q[AUTO_PRECHARGE]  <= 1'b0;
-
-        // Write mask
-        dqm_q       <= dqm_buffer_q;
-    end
+    // //-----------------------------------------
+    // // STATE_WRITE1
+    // //-----------------------------------------
+    // STATE_WRITE1 :
+    // begin
+    //     // Burst continuation
+    //     command_q   <= CMD_NOP;
+
+    //     data_q      <= data_buffer_q;
+
+    //     // Disable auto precharge (auto close of row)
+    //     addr_q[AUTO_PRECHARGE]  <= 1'b0;
+
+    //     // Write mask
+    //     dqm_q       <= dqm_buffer_q;
+    // end
     endcase
 end
 
@@ -664,16 +671,16 @@ else
 
 // Buffer upper 16-bits of write data so write command can be accepted
 // in WRITE0. Also buffer lower 16-bits of read data.
-always @ (posedge clk_i or posedge rst_i)
-if (rst_i)
-    data_buffer_q <= 16'b0;
-else if (state_q == STATE_WRITE0)
-    data_buffer_q <= ram_write_data_w[31:16];
-else if (rd_q[SDRAM_READ_LATENCY+1])
-    data_buffer_q <= sample_data_q;
+// always @ (posedge clk_i or posedge rst_i)
+// if (rst_i)
+//     data_buffer_q <= 16'b0;
+// else if (state_q == STATE_WRITE0)
+//     data_buffer_q <= ram_write_data_w[31:16];
+// else if (rd_q[SDRAM_READ_LATENCY+1])
+//     data_buffer_q <= sample_data_q;
 
 // Read data output
-assign ram_read_data_w = {sample_data_q, data_buffer_q};
+assign ram_read_data_w = sample_data_q;
 
 //-----------------------------------------------------------------
 // ACK
@@ -685,7 +692,7 @@ if (rst_i)
     ack_q   <= 1'b0;
 else
 begin
-    if (state_q == STATE_WRITE1)
+    if (state_q == STATE_WRITE0)
         ack_q <= 1'b1;
     else if (rd_q[SDRAM_READ_LATENCY+1])
         ack_q <= 1'b1;
diff --git a/perip/sdram/core_sdram_axi4/sdram_axi_core_old.v b/perip/sdram/core_sdram_axi4/sdram_axi_core_old.v
new file mode 100644
index 0000000..ac14477
--- /dev/null
+++ b/perip/sdram/core_sdram_axi4/sdram_axi_core_old.v
@@ -0,0 +1,743 @@
+// //-----------------------------------------------------------------
+// //                    SDRAM Controller (AXI4)
+// //                           V1.0
+// //                     Ultra-Embedded.com
+// //                     Copyright 2015-2019
+// //
+// //                 Email: admin@ultra-embedded.com
+// //
+// //                         License: GPL
+// // If you would like a version with a more permissive license for
+// // use in closed source commercial applications please contact me
+// // for details.
+// //-----------------------------------------------------------------
+// //
+// // This file is open source HDL; you can redistribute it and/or
+// // modify it under the terms of the GNU General Public License as
+// // published by the Free Software Foundation; either version 2 of
+// // the License, or (at your option) any later version.
+// //
+// // This file is distributed in the hope that it will be useful,
+// // but WITHOUT ANY WARRANTY; without even the implied warranty of
+// // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// // GNU General Public License for more details.
+// //
+// // You should have received a copy of the GNU General Public
+// // License along with this file; if not, write to the Free Software
+// // Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
+// // USA
+// //-----------------------------------------------------------------
+
+// //-----------------------------------------------------------------
+// //                          Generated File
+// //-----------------------------------------------------------------
+
+// module sdram_axi_core_old
+// (
+//     // Inputs
+//      input           clk_i
+//     ,input           rst_i
+//     ,input  [  3:0]  inport_wr_i
+//     ,input           inport_rd_i
+//     ,input  [  7:0]  inport_len_i
+//     ,input  [ 31:0]  inport_addr_i
+//     ,input  [ 31:0]  inport_write_data_i
+//     ,input  [ 15:0]  sdram_data_input_i
+
+//     // Outputs
+//     ,output          inport_accept_o
+//     ,output          inport_ack_o
+//     ,output          inport_error_o
+//     ,output [ 31:0]  inport_read_data_o
+//     ,output          sdram_clk_o
+//     ,output          sdram_cke_o
+//     ,output          sdram_cs_o
+//     ,output          sdram_ras_o
+//     ,output          sdram_cas_o
+//     ,output          sdram_we_o
+//     ,output [  1:0]  sdram_dqm_o
+//     ,output [ 12:0]  sdram_addr_o
+//     ,output [  1:0]  sdram_ba_o
+//     ,output [ 15:0]  sdram_data_output_o
+//     ,output          sdram_data_out_en_o
+// );
+
+
+
+// //-----------------------------------------------------------------
+// // Key Params
+// //-----------------------------------------------------------------
+// parameter SDRAM_MHZ              = 50;
+// parameter SDRAM_ADDR_W           = 24;
+// parameter SDRAM_COL_W            = 9;
+// parameter SDRAM_READ_LATENCY     = 2;
+
+// //-----------------------------------------------------------------
+// // Defines / Local params
+// //-----------------------------------------------------------------
+// localparam SDRAM_BANK_W          = 2;
+// localparam SDRAM_DQM_W           = 2;
+// localparam SDRAM_BANKS           = 2 ** SDRAM_BANK_W;
+// localparam SDRAM_ROW_W           = SDRAM_ADDR_W - SDRAM_COL_W - SDRAM_BANK_W;
+// localparam SDRAM_REFRESH_CNT     = 2 ** SDRAM_ROW_W;
+// localparam SDRAM_START_DELAY     = 50000 / (1000 / SDRAM_MHZ); // 100uS
+// localparam SDRAM_REFRESH_CYCLES  = (64000*SDRAM_MHZ) / SDRAM_REFRESH_CNT-1;
+
+// localparam CMD_W             = 4;
+// localparam CMD_NOP           = 4'b0111;
+// localparam CMD_ACTIVE        = 4'b0011;
+// localparam CMD_READ          = 4'b0101;
+// localparam CMD_WRITE         = 4'b0100;
+// localparam CMD_TERMINATE     = 4'b0110;
+// localparam CMD_PRECHARGE     = 4'b0010;
+// localparam CMD_REFRESH       = 4'b0001;
+// localparam CMD_LOAD_MODE     = 4'b0000;
+
+// // Mode: Burst Length = 4 bytes, CAS=2
+// localparam MODE_REG          = {3'b000,1'b0,2'b00,3'b010,1'b0,3'b001};
+
+// // SM states
+// localparam STATE_W           = 4;
+// localparam STATE_INIT        = 4'd0;
+// localparam STATE_DELAY       = 4'd1;
+// localparam STATE_IDLE        = 4'd2;
+// localparam STATE_ACTIVATE    = 4'd3;
+// localparam STATE_READ        = 4'd4;
+// localparam STATE_READ_WAIT   = 4'd5;
+// localparam STATE_WRITE0      = 4'd6;
+// localparam STATE_WRITE1      = 4'd7;
+// localparam STATE_PRECHARGE   = 4'd8;
+// localparam STATE_REFRESH     = 4'd9;
+
+// localparam AUTO_PRECHARGE    = 10;
+// localparam ALL_BANKS         = 10;
+
+// localparam SDRAM_DATA_W      = 16;
+
+// localparam CYCLE_TIME_NS     = 1000 / SDRAM_MHZ;
+
+// // SDRAM timing
+// localparam SDRAM_TRCD_CYCLES = (20 + (CYCLE_TIME_NS-1)) / CYCLE_TIME_NS;
+// localparam SDRAM_TRP_CYCLES  = (20 + (CYCLE_TIME_NS-1)) / CYCLE_TIME_NS;
+// localparam SDRAM_TRFC_CYCLES = (60 + (CYCLE_TIME_NS-1)) / CYCLE_TIME_NS;
+
+// //-----------------------------------------------------------------
+// // External Interface
+// //-----------------------------------------------------------------
+// wire [ 31:0]  ram_addr_w       = inport_addr_i;
+// wire [  3:0]  ram_wr_w         = inport_wr_i;
+// wire          ram_rd_w         = inport_rd_i;
+// wire          ram_accept_w;
+// wire [ 31:0]  ram_write_data_w = inport_write_data_i;
+// wire [ 31:0]  ram_read_data_w;
+// wire          ram_ack_w;
+
+// wire          ram_req_w = (ram_wr_w != 4'b0) | ram_rd_w;
+
+// assign inport_ack_o       = ram_ack_w;
+// assign inport_read_data_o = ram_read_data_w;
+// assign inport_error_o     = 1'b0;
+// assign inport_accept_o    = ram_accept_w;
+
+// //-----------------------------------------------------------------
+// // Registers / Wires
+// //-----------------------------------------------------------------
+
+// // Xilinx placement pragmas:
+// //synthesis attribute IOB of command_q is "TRUE"
+// //synthesis attribute IOB of addr_q is "TRUE"
+// //synthesis attribute IOB of dqm_q is "TRUE"
+// //synthesis attribute IOB of cke_q is "TRUE"
+// //synthesis attribute IOB of bank_q is "TRUE"
+// //synthesis attribute IOB of data_q is "TRUE"
+
+// reg [CMD_W-1:0]        command_q;
+// reg [SDRAM_ROW_W-1:0]  addr_q;
+// reg [SDRAM_DATA_W-1:0] data_q;
+// reg                    data_rd_en_q;
+// reg [SDRAM_DQM_W-1:0]  dqm_q;
+// reg                    cke_q;
+// reg [SDRAM_BANK_W-1:0] bank_q;
+
+// // Buffer half word during read and write commands
+// reg [SDRAM_DATA_W-1:0] data_buffer_q;
+// reg [SDRAM_DQM_W-1:0]  dqm_buffer_q;
+
+// wire [SDRAM_DATA_W-1:0] sdram_data_in_w;
+
+// reg                    refresh_q;
+
+// reg [SDRAM_BANKS-1:0]  row_open_q;
+// reg [SDRAM_ROW_W-1:0]  active_row_q[0:SDRAM_BANKS-1];
+
+// reg  [STATE_W-1:0]     state_q;
+// reg  [STATE_W-1:0]     next_state_r;
+// reg  [STATE_W-1:0]     target_state_r;
+// reg  [STATE_W-1:0]     target_state_q;
+// reg  [STATE_W-1:0]     delay_state_q;
+
+// // Address bits
+// wire [SDRAM_ROW_W-1:0]  addr_col_w  = {{(SDRAM_ROW_W-SDRAM_COL_W){1'b0}}, ram_addr_w[SDRAM_COL_W:2], 1'b0};
+// wire [SDRAM_ROW_W-1:0]  addr_row_w  = ram_addr_w[SDRAM_ADDR_W:SDRAM_COL_W+2+1];
+// wire [SDRAM_BANK_W-1:0] addr_bank_w = ram_addr_w[SDRAM_COL_W+2:SDRAM_COL_W+2-1];
+
+// //-----------------------------------------------------------------
+// // SDRAM State Machine
+// //-----------------------------------------------------------------
+// always @ *
+// begin
+//     next_state_r   = state_q;
+//     target_state_r = target_state_q;
+
+//     case (state_q)
+//     //-----------------------------------------
+//     // STATE_INIT
+//     //-----------------------------------------
+//     STATE_INIT :
+//     begin
+//         if (refresh_q)
+//             next_state_r = STATE_IDLE;
+//     end
+//     //-----------------------------------------
+//     // STATE_IDLE
+//     //-----------------------------------------
+//     STATE_IDLE :
+//     begin
+//         // Pending refresh
+//         // Note: tRAS (open row time) cannot be exceeded due to periodic
+//         //        auto refreshes.
+//         if (refresh_q)
+//         begin
+//             // Close open rows, then refresh
+//             if (|row_open_q)
+//                 next_state_r = STATE_PRECHARGE;
+//             else
+//                 next_state_r = STATE_REFRESH;
+
+//             target_state_r = STATE_REFRESH;
+//         end
+//         // Access request
+//         else if (ram_req_w)
+//         begin
+//             // Open row hit
+//             if (row_open_q[addr_bank_w] && addr_row_w == active_row_q[addr_bank_w])
+//             begin
+//                 if (!ram_rd_w)
+//                     next_state_r = STATE_WRITE0;
+//                 else
+//                     next_state_r = STATE_READ;
+//             end
+//             // Row miss, close row, open new row
+//             else if (row_open_q[addr_bank_w])
+//             begin
+//                 next_state_r   = STATE_PRECHARGE;
+
+//                 if (!ram_rd_w)
+//                     target_state_r = STATE_WRITE0;
+//                 else
+//                     target_state_r = STATE_READ;
+//             end
+//             // No open row, open row
+//             else
+//             begin
+//                 next_state_r   = STATE_ACTIVATE;
+
+//                 if (!ram_rd_w)
+//                     target_state_r = STATE_WRITE0;
+//                 else
+//                     target_state_r = STATE_READ;
+//             end
+//         end
+//     end
+//     //-----------------------------------------
+//     // STATE_ACTIVATE
+//     //-----------------------------------------
+//     STATE_ACTIVATE :
+//     begin
+//         // Proceed to read or write state
+//         next_state_r = target_state_r;
+//     end
+//     //-----------------------------------------
+//     // STATE_READ
+//     //-----------------------------------------
+//     STATE_READ :
+//     begin
+//         next_state_r = STATE_READ_WAIT;
+//     end
+//     //-----------------------------------------
+//     // STATE_READ_WAIT
+//     //-----------------------------------------
+//     STATE_READ_WAIT :
+//     begin
+//         next_state_r = STATE_IDLE;
+
+//         // Another pending read request (with no refresh pending)
+//         if (!refresh_q && ram_req_w && ram_rd_w)
+//         begin
+//             // Open row hit
+//             if (row_open_q[addr_bank_w] && addr_row_w == active_row_q[addr_bank_w])
+//                 next_state_r = STATE_READ;
+//         end
+//     end
+//     //-----------------------------------------
+//     // STATE_WRITE0
+//     //-----------------------------------------
+//     STATE_WRITE0 :
+//     begin
+//         next_state_r = STATE_WRITE1;
+//     end
+//     //-----------------------------------------
+//     // STATE_WRITE1
+//     //-----------------------------------------
+//     STATE_WRITE1 :
+//     begin
+//         next_state_r = STATE_IDLE;
+
+//         // Another pending write request (with no refresh pending)
+//         if (!refresh_q && ram_req_w && (ram_wr_w != 4'b0))
+//         begin
+//             // Open row hit
+//             if (row_open_q[addr_bank_w] && addr_row_w == active_row_q[addr_bank_w])
+//                 next_state_r = STATE_WRITE0;
+//         end
+//     end
+//     //-----------------------------------------
+//     // STATE_PRECHARGE
+//     //-----------------------------------------
+//     STATE_PRECHARGE :
+//     begin
+//         // Closing row to perform refresh
+//         if (target_state_r == STATE_REFRESH)
+//             next_state_r = STATE_REFRESH;
+//         // Must be closing row to open another
+//         else
+//             next_state_r = STATE_ACTIVATE;
+//     end
+//     //-----------------------------------------
+//     // STATE_REFRESH
+//     //-----------------------------------------
+//     STATE_REFRESH :
+//     begin
+//         next_state_r = STATE_IDLE;
+//     end
+//     //-----------------------------------------
+//     // STATE_DELAY
+//     //-----------------------------------------
+//     STATE_DELAY :
+//     begin
+//         next_state_r = delay_state_q;
+//     end
+//     default:
+//         ;
+//    endcase
+// end
+
+// //-----------------------------------------------------------------
+// // Delays
+// //-----------------------------------------------------------------
+// localparam DELAY_W = 4;
+
+// reg [DELAY_W-1:0] delay_q;
+// reg [DELAY_W-1:0] delay_r;
+
+// /* verilator lint_off WIDTH */
+
+// always @ *
+// begin
+//     case (state_q)
+//     //-----------------------------------------
+//     // STATE_ACTIVATE
+//     //-----------------------------------------
+//     STATE_ACTIVATE :
+//     begin
+//         // tRCD (ACTIVATE -> READ / WRITE)
+//         delay_r = SDRAM_TRCD_CYCLES;
+//     end
+//     //-----------------------------------------
+//     // STATE_READ_WAIT
+//     //-----------------------------------------
+//     STATE_READ_WAIT :
+//     begin
+//         delay_r = SDRAM_READ_LATENCY;
+
+//         // Another pending read request (with no refresh pending)
+//         if (!refresh_q && ram_req_w && ram_rd_w)
+//         begin
+//             // Open row hit
+//             if (row_open_q[addr_bank_w] && addr_row_w == active_row_q[addr_bank_w])
+//                 delay_r = 4'd0;
+//         end
+//     end
+//     //-----------------------------------------
+//     // STATE_PRECHARGE
+//     //-----------------------------------------
+//     STATE_PRECHARGE :
+//     begin
+//         // tRP (PRECHARGE -> ACTIVATE)
+//         delay_r = SDRAM_TRP_CYCLES;
+//     end
+//     //-----------------------------------------
+//     // STATE_REFRESH
+//     //-----------------------------------------
+//     STATE_REFRESH :
+//     begin
+//         // tRFC
+//         delay_r = SDRAM_TRFC_CYCLES;
+//     end
+//     //-----------------------------------------
+//     // STATE_DELAY
+//     //-----------------------------------------
+//     STATE_DELAY:
+//     begin
+//         delay_r = delay_q - 4'd1;
+//     end
+//     //-----------------------------------------
+//     // Others
+//     //-----------------------------------------
+//     default:
+//     begin
+//         delay_r = {DELAY_W{1'b0}};
+//     end
+//     endcase
+// end
+// /* verilator lint_on WIDTH */
+
+// // Record target state
+// always @ (posedge clk_i or posedge rst_i)
+// if (rst_i)
+//     target_state_q   <= STATE_IDLE;
+// else
+//     target_state_q   <= target_state_r;
+
+// // Record delayed state
+// always @ (posedge clk_i or posedge rst_i)
+// if (rst_i)
+//     delay_state_q   <= STATE_IDLE;
+// // On entering into delay state, record intended next state
+// else if (state_q != STATE_DELAY && delay_r != {DELAY_W{1'b0}})
+//     delay_state_q   <= next_state_r;
+
+// // Update actual state
+// always @ (posedge clk_i or posedge rst_i)
+// if (rst_i)
+//     state_q   <= STATE_INIT;
+// // Delaying...
+// else if (delay_r != {DELAY_W{1'b0}})
+//     state_q   <= STATE_DELAY;
+// else
+//     state_q   <= next_state_r;
+
+// // Update delay flops
+// always @ (posedge clk_i or posedge rst_i)
+// if (rst_i)
+//     delay_q   <= {DELAY_W{1'b0}};
+// else
+//     delay_q   <= delay_r;
+
+// //-----------------------------------------------------------------
+// // Refresh counter
+// //-----------------------------------------------------------------
+// localparam REFRESH_CNT_W = 17;
+
+// reg [REFRESH_CNT_W-1:0] refresh_timer_q;
+// always @ (posedge clk_i or posedge rst_i)
+// if (rst_i)
+//     refresh_timer_q <= SDRAM_START_DELAY + 100;
+// else if (refresh_timer_q == {REFRESH_CNT_W{1'b0}})
+//     refresh_timer_q <= SDRAM_REFRESH_CYCLES;
+// else
+//     refresh_timer_q <= refresh_timer_q - 1;
+
+// always @ (posedge clk_i or posedge rst_i)
+// if (rst_i)
+//     refresh_q <= 1'b0;
+// else if (refresh_timer_q == {REFRESH_CNT_W{1'b0}})
+//     refresh_q <= 1'b1;
+// else if (state_q == STATE_REFRESH)
+//     refresh_q <= 1'b0;
+
+// //-----------------------------------------------------------------
+// // Input sampling
+// //-----------------------------------------------------------------
+
+// reg [SDRAM_DATA_W-1:0] sample_data0_q;
+// always @ (posedge clk_i or posedge rst_i)
+// if (rst_i)
+//     sample_data0_q <= {SDRAM_DATA_W{1'b0}};
+// else
+//     sample_data0_q <= sdram_data_in_w;
+
+// reg [SDRAM_DATA_W-1:0] sample_data_q;
+// always @ (posedge clk_i or posedge rst_i)
+// if (rst_i)
+//     sample_data_q <= {SDRAM_DATA_W{1'b0}};
+// else
+//     // sample_data_q <= sample_data0_q;
+//     sample_data_q <= sdram_data_in_w;
+
+// //-----------------------------------------------------------------
+// // Command Output
+// //-----------------------------------------------------------------
+// integer idx;
+
+// always @ (posedge clk_i or posedge rst_i)
+// if (rst_i)
+// begin
+//     command_q       <= CMD_NOP;
+//     data_q          <= 16'b0;
+//     addr_q          <= {SDRAM_ROW_W{1'b0}};
+//     bank_q          <= {SDRAM_BANK_W{1'b0}};
+//     cke_q           <= 1'b0;
+//     dqm_q           <= {SDRAM_DQM_W{1'b0}};
+//     data_rd_en_q    <= 1'b1;
+//     dqm_buffer_q    <= {SDRAM_DQM_W{1'b0}};
+
+//     for (idx=0;idx<SDRAM_BANKS;idx=idx+1)
+//         active_row_q[idx] <= {SDRAM_ROW_W{1'b0}};
+
+//     row_open_q      <= {SDRAM_BANKS{1'b0}};
+// end
+// else
+// begin
+//     case (state_q)
+//     //-----------------------------------------
+//     // STATE_IDLE / Default (delays)
+//     //-----------------------------------------
+//     default:
+//     begin
+//         // Default
+//         command_q    <= CMD_NOP;
+//         addr_q       <= {SDRAM_ROW_W{1'b0}};
+//         bank_q       <= {SDRAM_BANK_W{1'b0}};
+//         data_rd_en_q <= 1'b1;
+//     end
+//     //-----------------------------------------
+//     // STATE_INIT
+//     //-----------------------------------------
+//     STATE_INIT:
+//     begin
+//         // Assert CKE
+//         if (refresh_timer_q == 50)
+//         begin
+//             // Assert CKE after 100uS
+//             cke_q <= 1'b1;
+//         end
+//         // PRECHARGE
+//         else if (refresh_timer_q == 40)
+//         begin
+//             // Precharge all banks
+//             command_q           <= CMD_PRECHARGE;
+//             addr_q[ALL_BANKS]   <= 1'b1;
+//         end
+//         // 2 x REFRESH (with at least tREF wait)
+//         else if (refresh_timer_q == 20 || refresh_timer_q == 30)
+//         begin
+//             command_q <= CMD_REFRESH;
+//         end
+//         // Load mode register
+//         else if (refresh_timer_q == 10)
+//         begin
+//             command_q <= CMD_LOAD_MODE;
+//             addr_q    <= MODE_REG;
+//         end
+//         // Other cycles during init - just NOP
+//         else
+//         begin
+//             command_q   <= CMD_NOP;
+//             addr_q      <= {SDRAM_ROW_W{1'b0}};
+//             bank_q      <= {SDRAM_BANK_W{1'b0}};
+//         end
+//     end
+//     //-----------------------------------------
+//     // STATE_ACTIVATE
+//     //-----------------------------------------
+//     STATE_ACTIVATE :
+//     begin
+//         // Select a row and activate it
+//         command_q     <= CMD_ACTIVE;
+//         addr_q        <= addr_row_w;
+//         bank_q        <= addr_bank_w;
+
+//         active_row_q[addr_bank_w]  <= addr_row_w;
+//         row_open_q[addr_bank_w]    <= 1'b1;
+//     end
+//     //-----------------------------------------
+//     // STATE_PRECHARGE
+//     //-----------------------------------------
+//     STATE_PRECHARGE :
+//     begin
+//         // Precharge due to refresh, close all banks
+//         if (target_state_r == STATE_REFRESH)
+//         begin
+//             // Precharge all banks
+//             command_q           <= CMD_PRECHARGE;
+//             addr_q[ALL_BANKS]   <= 1'b1;
+//             row_open_q          <= {SDRAM_BANKS{1'b0}};
+//         end
+//         else
+//         begin
+//             // Precharge specific banks
+//             command_q           <= CMD_PRECHARGE;
+//             addr_q[ALL_BANKS]   <= 1'b0;
+//             bank_q              <= addr_bank_w;
+
+//             row_open_q[addr_bank_w] <= 1'b0;
+//         end
+//     end
+//     //-----------------------------------------
+//     // STATE_REFRESH
+//     //-----------------------------------------
+//     STATE_REFRESH :
+//     begin
+//         // Auto refresh
+//         command_q   <= CMD_REFRESH;
+//         addr_q      <= {SDRAM_ROW_W{1'b0}};
+//         bank_q      <= {SDRAM_BANK_W{1'b0}};
+//     end
+//     //-----------------------------------------
+//     // STATE_READ
+//     //-----------------------------------------
+//     STATE_READ :
+//     begin
+//         command_q   <= CMD_READ;
+//         addr_q      <= addr_col_w;
+//         bank_q      <= addr_bank_w;
+
+//         // Disable auto precharge (auto close of row)
+//         addr_q[AUTO_PRECHARGE]  <= 1'b0;
+
+//         // Read mask (all bytes in burst)
+//         dqm_q       <= {SDRAM_DQM_W{1'b0}};
+//     end
+//     //-----------------------------------------
+//     // STATE_WRITE0
+//     //-----------------------------------------
+//     STATE_WRITE0 :
+//     begin
+//         command_q       <= CMD_WRITE;
+//         addr_q          <= addr_col_w;
+//         bank_q          <= addr_bank_w;
+//         data_q          <= ram_write_data_w[15:0];
+
+//         // Disable auto precharge (auto close of row)
+//         addr_q[AUTO_PRECHARGE]  <= 1'b0;
+
+//         // Write mask
+//         dqm_q           <= ~ram_wr_w[1:0];
+//         dqm_buffer_q    <= ~ram_wr_w[3:2];
+
+//         data_rd_en_q    <= 1'b0;
+//     end
+//     //-----------------------------------------
+//     // STATE_WRITE1
+//     //-----------------------------------------
+//     STATE_WRITE1 :
+//     begin
+//         // Burst continuation
+//         command_q   <= CMD_NOP;
+
+//         data_q      <= data_buffer_q;
+
+//         // Disable auto precharge (auto close of row)
+//         addr_q[AUTO_PRECHARGE]  <= 1'b0;
+
+//         // Write mask
+//         dqm_q       <= dqm_buffer_q;
+//     end
+//     endcase
+// end
+
+// //-----------------------------------------------------------------
+// // Record read events
+// //-----------------------------------------------------------------
+// reg [SDRAM_READ_LATENCY+1:0]  rd_q;
+
+// always @ (posedge clk_i or posedge rst_i)
+// if (rst_i)
+//     rd_q    <= {(SDRAM_READ_LATENCY+2){1'b0}};
+// else
+//     rd_q    <= {rd_q[SDRAM_READ_LATENCY:0], (state_q == STATE_READ)};
+
+// //-----------------------------------------------------------------
+// // Data Buffer
+// //-----------------------------------------------------------------
+
+// // Buffer upper 16-bits of write data so write command can be accepted
+// // in WRITE0. Also buffer lower 16-bits of read data.
+// always @ (posedge clk_i or posedge rst_i)
+// if (rst_i)
+//     data_buffer_q <= 16'b0;
+// else if (state_q == STATE_WRITE0)
+//     data_buffer_q <= ram_write_data_w[31:16];
+// else if (rd_q[SDRAM_READ_LATENCY+1])
+//     data_buffer_q <= sample_data_q;
+
+// // Read data output
+// assign ram_read_data_w = {sample_data_q, data_buffer_q};
+
+// //-----------------------------------------------------------------
+// // ACK
+// //-----------------------------------------------------------------
+// reg ack_q;
+
+// always @ (posedge clk_i or posedge rst_i)
+// if (rst_i)
+//     ack_q   <= 1'b0;
+// else
+// begin
+//     if (state_q == STATE_WRITE1)
+//         ack_q <= 1'b1;
+//     else if (rd_q[SDRAM_READ_LATENCY+1])
+//         ack_q <= 1'b1;
+//     else
+//         ack_q <= 1'b0;
+// end
+
+// assign ram_ack_w = ack_q;
+
+// // Accept command in READ or WRITE0 states
+// assign ram_accept_w = (state_q == STATE_READ || state_q == STATE_WRITE0);
+
+// //-----------------------------------------------------------------
+// // SDRAM I/O
+// //-----------------------------------------------------------------
+// assign sdram_clk_o           = ~clk_i;
+// assign sdram_data_out_en_o   = ~data_rd_en_q;
+// assign sdram_data_output_o   =  data_q;
+// assign sdram_data_in_w       = sdram_data_input_i;
+
+// assign sdram_cke_o  = cke_q;
+// assign sdram_cs_o   = command_q[3];
+// assign sdram_ras_o  = command_q[2];
+// assign sdram_cas_o  = command_q[1];
+// assign sdram_we_o   = command_q[0];
+// assign sdram_dqm_o  = dqm_q;
+// assign sdram_ba_o   = bank_q;
+// assign sdram_addr_o = addr_q;
+
+// //-----------------------------------------------------------------
+// // Simulation only
+// //-----------------------------------------------------------------
+// `ifdef verilator
+// reg [79:0] dbg_state;
+
+// always @ *
+// begin
+//     case (state_q)
+//     STATE_INIT        : dbg_state = "INIT";
+//     STATE_DELAY       : dbg_state = "DELAY";
+//     STATE_IDLE        : dbg_state = "IDLE";
+//     STATE_ACTIVATE    : dbg_state = "ACTIVATE";
+//     STATE_READ        : dbg_state = "READ";
+//     STATE_READ_WAIT   : dbg_state = "READ_WAIT";
+//     STATE_WRITE0      : dbg_state = "WRITE0";
+//     STATE_WRITE1      : dbg_state = "WRITE1";
+//     STATE_PRECHARGE   : dbg_state = "PRECHARGE";
+//     STATE_REFRESH     : dbg_state = "REFRESH";
+//     default           : dbg_state = "UNKNOWN";
+//     endcase
+// end
+// `endif
+
+
+// endmodule
diff --git a/perip/sdram/sdram_top_apb.v b/perip/sdram/sdram_top_apb.v
index 3bc5b93..1e10e6e 100644
--- a/perip/sdram/sdram_top_apb.v
+++ b/perip/sdram/sdram_top_apb.v
@@ -20,13 +20,17 @@ module sdram_top_apb (
   output        sdram_we,
   output [12:0] sdram_a,
   output [ 1:0] sdram_ba,
-  output [ 1:0] sdram_dqm,
-  inout  [15:0] sdram_dq
+  output [ 3:0] sdram_dqm,
+  inout  [15:0] sdram_dq_0,
+  inout  [15:0] sdram_dq_1
 );
 
   wire sdram_dout_en;
-  wire [15:0] sdram_dout;
-  assign sdram_dq = sdram_dout_en ? sdram_dout : 16'bz;
+  wire [31:0] sdram_dout;
+  wire [31:0] sdram_dq;
+  assign sdram_dq_0 = sdram_dout_en ? sdram_dout[15:0]  : 16'bz;
+  assign sdram_dq_1 = sdram_dout_en ? sdram_dout[31:16] : 16'bz;
+  assign sdram_dq   = {sdram_dq_1,sdram_dq_0};
 
   typedef enum [1:0] { ST_IDLE, ST_WAIT_ACCEPT, ST_WAIT_ACK } state_t;
   reg [1:0] state;
@@ -49,7 +53,7 @@ module sdram_top_apb (
     .SDRAM_MHZ(100),
     .SDRAM_ADDR_W(24),
     .SDRAM_COL_W(9),
-    .SDRAM_READ_LATENCY(2)
+    .SDRAM_READ_LATENCY(0)
   ) u_sdram_ctrl(
     .clk_i(clock),
     .rst_i(reset),
diff --git a/src/SoC.scala b/src/SoC.scala
index 92e4ab8..3de9cea 100644
--- a/src/SoC.scala
+++ b/src/SoC.scala
@@ -155,7 +155,8 @@ class ysyxSoCFull(implicit p: Parameters) extends LazyModule {
 
     val psram = Module(new psramChisel)
     psram.io <> masic.psram
-    val sdram = Module(new sdramChisel)
+    val sdram = Module(new sdramPad)
+
     sdram.io <> masic.sdram
 
     val externalPins = IO(new Bundle{
diff --git a/src/device/SDRAM.scala b/src/device/SDRAM.scala
index 3fc5fa2..7382541 100644
--- a/src/device/SDRAM.scala
+++ b/src/device/SDRAM.scala
@@ -22,15 +22,30 @@ class SDRAMIO extends Bundle {
   val a   = Output(UInt(13.W))
   val ba  = Output(UInt(2.W))
   val dqm = Output(UInt(2.W))
+  val b   = Output(Bool())
   val dq  = Analog(16.W)
 }
 
+class SDRAMPadIO extends Bundle {
+  val clk = Output(Bool())
+  val cke = Output(Bool())
+  val cs  = Output(Bool())
+  val ras = Output(Bool())
+  val cas = Output(Bool())
+  val we  = Output(Bool())
+  val a   = Output(UInt(13.W))
+  val ba  = Output(UInt(2.W))
+  val dqm = Output(UInt(4.W))
+  val dq = Vec(2,Analog(16.W))
+}
+
 class sdramPmemIO extends Bundle {
   val clock       = Input(Bool())
   val reset       = Input(Bool())
   val row         = Input(UInt(13.W))
   val col         = Input(UInt(9.W))
   val ba          = Input(UInt(2.W))
+  val b           = Input(Bool())
   val wen         = Input(Bool())
   val ren         = Input(Bool())
   val dqm         = Input(UInt(2.W))
@@ -38,12 +53,13 @@ class sdramPmemIO extends Bundle {
   val rdata       = Output(UInt(16.W))
 }
 
+
 class sdram_top_axi extends BlackBox {
   val io = IO(new Bundle {
     val clock = Input(Clock())
     val reset = Input(Bool())
     val in = Flipped(new AXI4Bundle(AXI4BundleParameters(addrBits = 32, dataBits = 32, idBits = 4)))
-    val sdram = new SDRAMIO
+    val sdram = new SDRAMPadIO
   })
 }
 
@@ -52,7 +68,7 @@ class sdram_top_apb extends BlackBox {
     val clock = Input(Clock())
     val reset = Input(Bool())
     val in = Flipped(new APBBundle(APBBundleParameters(addrBits = 32, dataBits = 32)))
-    val sdram = new SDRAMIO
+    val sdram = new SDRAMPadIO
   })
 }
 
@@ -65,6 +81,7 @@ class sdramPmem extends BlackBox with HasBlackBoxInline {
       |  input                reset,
       |  input                wen,
       |  input                ren,
+      |  input                b,
       |  input       [12:0]   row,
       |  input       [8:0]    col,
       |  input       [1:0]    ba,
@@ -72,15 +89,17 @@ class sdramPmem extends BlackBox with HasBlackBoxInline {
       |  input       [15:0]   wdata,
       |  output reg  [15:0]   rdata
       |);
-      |import "DPI-C" function void sdram_read (input int row, input int col, input int ba, input int dqm , output int data);
-      |import "DPI-C" function void sdram_write(input int row, input int col, input int ba, input int dqm , input int data);
+      |import "DPI-C" function void sdram_read (input int bit_ext, input int row, input int col, input int ba, input int dqm , output int data);
+      |import "DPI-C" function void sdram_write(input int bit_ext, input int row, input int col, input int ba, input int dqm , input int data);
       |  wire [31:0] row_ext ;
       |  wire [31:0] col_ext; 
       |  wire [31:0] ba_ext; 
       |  wire [31:0] dqm_ext;
       |  wire [31:0] wdata_ext; 
+      |  wire [31:0] bit_ext;
       |  reg [31:0] rdata_ext;
       |  
+      |  assign bit_ext   = {31'd0,b};
       |  assign row_ext   = {19'd0,row};
       |  assign col_ext   = {23'd0,col};
       |  assign ba_ext    = {30'd0,ba};
@@ -89,14 +108,14 @@ class sdramPmem extends BlackBox with HasBlackBoxInline {
       |  assign rdata     = rdata_ext[15:0];
       |  always @(*) begin
       |    if (ren ) 
-      |      sdram_read(row_ext,col_ext,ba_ext,dqm_ext, rdata_ext);
+      |      sdram_read(bit_ext,row_ext,col_ext,ba_ext,dqm_ext, rdata_ext);
       |    else
       |      rdata_ext = 32'd0;
       |  end
       |  // always @(posedge clock) begin
       |  always @(negedge clock) begin
       |   if (wen)
-      |      sdram_write(row_ext,col_ext,ba_ext,dqm_ext, wdata_ext);
+      |      sdram_write(bit_ext,row_ext,col_ext,ba_ext,dqm_ext, wdata_ext);
       |  end
       |endmodule
     """.stripMargin)
@@ -106,6 +125,37 @@ class sdram extends BlackBox {
   val io = IO(Flipped(new SDRAMIO))
 }
 
+class sdramPad extends RawModule{
+  val io = IO(Flipped(new SDRAMPadIO))
+  
+  val sdram0 = Module(new sdramChisel)
+  val sdram1 = Module(new sdramChisel)
+
+  sdram0.io.clk  := io.clk  
+  sdram0.io.cke  := io.cke  
+  sdram0.io.cs   := io.cs    
+  sdram0.io.ras  := io.ras  
+  sdram0.io.cas  := io.cas  
+  sdram0.io.we   := io.we    
+  sdram0.io.a    := io.a    
+  sdram0.io.ba   := io.ba    
+  sdram0.io.b    := 0.U 
+  sdram0.io.dqm  := io.dqm(1,0)  
+  sdram0.io.dq   <> io.dq(0)
+
+  sdram1.io.clk  := io.clk  
+  sdram1.io.cke  := io.cke  
+  sdram1.io.cs   := io.cs    
+  sdram1.io.ras  := io.ras  
+  sdram1.io.cas  := io.cas  
+  sdram1.io.we   := io.we    
+  sdram1.io.a    := io.a    
+  sdram1.io.ba   := io.ba   
+  sdram1.io.b   := 1.U 
+  sdram1.io.dqm  := io.dqm(3,2) 
+  sdram1.io.dq   <> io.dq(1)
+}
+
 class sdramChisel (read_max_length:Int = 4) extends RawModule {
   val io = IO(Flipped(new SDRAMIO))
   val dout = Wire(UInt(16.W))
@@ -184,7 +234,7 @@ class sdramChisel (read_max_length:Int = 4) extends RawModule {
   read_bl_vec       :=  Mux(state === s_read || is_read, VecInit(read_bl  +:read_bl_vec.init     )  ,  VecInit(Seq.fill(read_max_length)(0.U(3.W))))
   read_bl           :=  Mux(is_read, burst_length, 
                             Mux(read_bl_vec(0) === 0.U, 0.U,read_bl_vec(0)-1.U)) 
-
+  pmem.io.b       := io.b
   pmem.io.row     := row
   pmem.io.col     := col + offset
   pmem.io.ba      := ba
@@ -264,7 +314,7 @@ class AXI4SDRAM(address: Seq[AddressSet])(implicit p: Parameters) extends LazyMo
   lazy val module = new Impl
   class Impl extends LazyModuleImp(this) {
     val (in, _) = node.in(0)
-    val sdram_bundle = IO(new SDRAMIO)
+    val sdram_bundle = IO(new SDRAMPadIO)
 
     val msdram = Module(new sdram_top_axi)
     msdram.io.clock := clock
@@ -286,7 +336,7 @@ class APBSDRAM(address: Seq[AddressSet])(implicit p: Parameters) extends LazyMod
   lazy val module = new Impl
   class Impl extends LazyModuleImp(this) {
     val (in, _) = node.in(0)
-    val sdram_bundle = IO(new SDRAMIO)
+    val sdram_bundle = IO(new SDRAMPadIO)
 
     val msdram = Module(new sdram_top_apb)
     msdram.io.clock := clock
-- 
2.43.0

