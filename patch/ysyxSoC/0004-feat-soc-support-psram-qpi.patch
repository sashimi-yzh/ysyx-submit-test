From b5016c094aa2e1d5c58167574dd38bca35bede7e Mon Sep 17 00:00:00 2001
From: "wuwenhui.wuwh" <wuwenhui.wuwh@bytedance.com>
Date: Wed, 30 Jul 2025 21:29:34 +0800
Subject: [PATCH 04/23] feat(soc): support psram qpi

---
 perip/psram/efabless/EF_PSRAM_CTRL.v    |  50 ++++++++--
 perip/psram/efabless/EF_PSRAM_CTRL_wb.v | 119 ++++++++++++++++++++++--
 src/device/Const.scala                  |  38 ++++++++
 src/device/PSRAM.scala                  |  13 ++-
 4 files changed, 197 insertions(+), 23 deletions(-)
 create mode 100644 src/device/Const.scala

diff --git a/perip/psram/efabless/EF_PSRAM_CTRL.v b/perip/psram/efabless/EF_PSRAM_CTRL.v
index b6e737e..d68fc9c 100644
--- a/perip/psram/efabless/EF_PSRAM_CTRL.v
+++ b/perip/psram/efabless/EF_PSRAM_CTRL.v
@@ -44,6 +44,7 @@
 module PSRAM_READER (
     input   wire            clk,
     input   wire            rst_n,
+    input   wire            is_qpi,
     input   wire [23:0]     addr,
     input   wire            rd,
     input   wire [2:0]      size,
@@ -60,13 +61,14 @@ module PSRAM_READER (
     localparam  IDLE = 1'b0,
                 READ = 1'b1;
 
-    wire [7:0]  FINAL_COUNT = 19 + size*2; // was 27: Always read 1 word
+    wire [7:0]  cmd_add_count;
+    wire [7:0]  FINAL_COUNT = cmd_add_count + size*2; // was 27: Always read 1 word
 
     reg         state, nstate;
     reg [7:0]   counter;
     reg [23:0]  saddr;
     reg [7:0]   data [3:0];
-
+    reg [3:0]   qpi_dout,noqpi_dout;
     wire[7:0]   CMD_EBH = 8'heb;
 
     always @*
@@ -115,11 +117,11 @@ module PSRAM_READER (
     // Sample with the negedge of sck
     wire[1:0] byte_index = {counter[7:1] - 8'd10}[1:0];
     always @ (posedge clk)
-        if(counter >= 20 && counter <= FINAL_COUNT)
+        if(counter >= (cmd_add_count+1) && counter <= FINAL_COUNT)
             if(sck)
                 data[byte_index] <= {data[byte_index][3:0], din}; // Optimize!
 
-    assign dout     =   (counter < 8)   ?   {3'b0, CMD_EBH[7 - counter]}:
+    assign noqpi_dout     =   (counter < 8)   ?   {3'b0, CMD_EBH[7 - counter]}:
                         (counter == 8)  ?   saddr[23:20]        :
                         (counter == 9)  ?   saddr[19:16]        :
                         (counter == 10) ?   saddr[15:12]        :
@@ -128,9 +130,20 @@ module PSRAM_READER (
                         (counter == 13) ?   saddr[3:0]          :
                         4'h0;
 
-    assign douten   = (counter < 14);
+    assign qpi_dout     =   (counter ==0)   ? CMD_EBH[7:4] :
+                            (counter == 1)  ? CMD_EBH[3:0] :
+                        (counter == 2)  ?   saddr[23:20]        :
+                        (counter == 3)  ?   saddr[19:16]        :
+                        (counter == 4) ?   saddr[15:12]        :
+                        (counter == 5) ?   saddr[11:8]         :
+                        (counter == 6) ?   saddr[7:4]          :
+                        (counter == 7) ?   saddr[3:0]          :
+                        4'h0;
+    assign dout     = is_qpi ? qpi_dout : noqpi_dout;
+    assign douten   = is_qpi ? (counter < 8):(counter < 14);
 
     assign done     = (counter == FINAL_COUNT+1);
+    assign cmd_add_count =  (is_qpi) ? 8'd13 : 8'd19 ;
 
     generate
         genvar i;
@@ -145,6 +158,7 @@ endmodule
 module PSRAM_WRITER (
     input   wire            clk,
     input   wire            rst_n,
+    input   wire            is_qpi,
     input   wire [23:0]     addr,
     input   wire [31: 0]    line,
     input   wire [2:0]      size,
@@ -161,12 +175,14 @@ module PSRAM_WRITER (
     localparam  IDLE = 1'b0,
                 WRITE = 1'b1;
 
-    wire[7:0]        FINAL_COUNT = 13 + size*2;
+    wire [7:0]  cmd_add_count;
+    wire [7:0]  FINAL_COUNT = cmd_add_count + size*2; // was 27: Always read 1 word
 
     reg         state, nstate;
     reg [7:0]   counter;
     reg [23:0]  saddr;
     //reg [7:0]   data [3:0];
+    reg [3:0]   qpi_dout,noqpi_dout;
 
     wire[7:0]   CMD_38H = 8'h38;
 
@@ -212,7 +228,7 @@ module PSRAM_WRITER (
         else if((state == IDLE) && wr)
             saddr <= addr;
 
-    assign dout     =   (counter < 8)   ?   {3'b0, CMD_38H[7 - counter]}:
+    assign noqpi_dout     =   (counter < 8)   ?   {3'b0, CMD_38H[7 - counter]}:
                         (counter == 8)  ?   saddr[23:20]        :
                         (counter == 9)  ?   saddr[19:16]        :
                         (counter == 10) ?   saddr[15:12]        :
@@ -228,9 +244,27 @@ module PSRAM_WRITER (
                         (counter == 20) ?   line[31:28]         :
                         line[27:24];
 
+    assign qpi_dout     =   (counter == 0)  ?   CMD_38H[7 :4] :
+                        (counter == 1)  ?   CMD_38H[3 :0]       :
+                        (counter == 2)  ?   saddr[23:20]        :
+                        (counter == 3)  ?   saddr[19:16]        :
+                        (counter == 4) ?   saddr[15:12]        :
+                        (counter == 5) ?   saddr[11:8]         :
+                        (counter == 6) ?   saddr[7:4]          :
+                        (counter == 7) ?   saddr[3:0]          :
+                        (counter == 8) ?   line[7:4]           :
+                        (counter == 9) ?   line[3:0]           :
+                        (counter == 10) ?   line[15:12]         :
+                        (counter == 11) ?   line[11:8]          :
+                        (counter == 12) ?   line[23:20]         :
+                        (counter == 13) ?   line[19:16]         :
+                        (counter == 14) ?   line[31:28]         :
+                        line[27:24];
+
+    assign dout     = is_qpi ?  qpi_dout : noqpi_dout;
     assign douten   = (~ce_n);
 
     assign done     = (counter == FINAL_COUNT + 1);
-
+    assign cmd_add_count = (is_qpi)? 8'd7 : 8'd13;
 
 endmodule
diff --git a/perip/psram/efabless/EF_PSRAM_CTRL_wb.v b/perip/psram/efabless/EF_PSRAM_CTRL_wb.v
index 7b5296d..21d161c 100644
--- a/perip/psram/efabless/EF_PSRAM_CTRL_wb.v
+++ b/perip/psram/efabless/EF_PSRAM_CTRL_wb.v
@@ -39,9 +39,10 @@ module EF_PSRAM_CTRL_wb (
     output  wire [3:0]      douten
 );
 
-    localparam  ST_IDLE = 1'b0,
-                ST_WAIT = 1'b1;
-
+    localparam  [1:0]   ST_IDLE = 2'b00,
+                        ST_WAIT = 2'b01,
+                        QPI_INIT = 2'b10;
+    
     wire        mr_sck;
     wire        mr_ce_n;
     wire [3:0]  mr_din;
@@ -54,12 +55,19 @@ module EF_PSRAM_CTRL_wb (
     wire [3:0]  mw_dout;
     wire        mw_doe;
 
+    wire        qpi_sck;
+    wire        qpi_ce_n;
+    wire [3:0]  qpi_dout;
+    wire        qpi_doe;
+
     // PSRAM Reader and Writer wires
     wire        mr_rd;
     wire        mr_done;
     wire        mw_wr;
     wire        mw_done;
-
+    wire        qpi_init;
+    wire        qpi_init_done;
+    wire        is_qpi_init;
     //wire        doe;
 
     // WB Control Signals
@@ -69,10 +77,12 @@ module EF_PSRAM_CTRL_wb (
     //wire[3:0]   wb_byte_sel     =   sel_i & {4{wb_we}};
 
     // The FSM
-    reg         state, nstate;
+    reg    [1:0]    state, nstate;
+    reg             is_qpi;
     always @ (posedge clk_i or posedge rst_i)
         if(rst_i)
             state <= ST_IDLE;
+            // state <= QPI_INIT;
         else
             state <= nstate;
 
@@ -89,6 +99,17 @@ module EF_PSRAM_CTRL_wb (
                     nstate = ST_IDLE;
                 else
                     nstate = ST_WAIT;
+            QPI_INIT:
+                if(qpi_init_done) begin
+                    nstate = ST_IDLE;
+                    is_qpi = 1'b1;
+                end
+                else
+                    nstate = QPI_INIT;
+            default: begin
+                is_qpi = 1'b0;
+                nstate = ST_IDLE;
+            end
         endcase
     end
 
@@ -129,10 +150,12 @@ module EF_PSRAM_CTRL_wb (
 
     assign mr_rd    = ( (state==ST_IDLE ) & wb_re );
     assign mw_wr    = ( (state==ST_IDLE ) & wb_we );
+    assign qpi_init = (state == QPI_INIT);
 
     PSRAM_READER MR (
         .clk(clk_i),
         .rst_n(~rst_i),
+        .is_qpi(is_qpi),
         .addr({adr_i[23:2],2'b0}),
         .rd(mr_rd),
         //.size(size), Always read a word
@@ -149,6 +172,7 @@ module EF_PSRAM_CTRL_wb (
     PSRAM_WRITER MW (
         .clk(clk_i),
         .rst_n(~rst_i),
+        .is_qpi(is_qpi),
         .addr({adr_i[23:0]}),
         .wr(mw_wr),
         .size(size),
@@ -161,12 +185,87 @@ module EF_PSRAM_CTRL_wb (
         .douten(mw_doe)
     );
 
-    assign sck  = wb_we ? mw_sck  : mr_sck;
-    assign ce_n = wb_we ? mw_ce_n : mr_ce_n;
-    assign dout = wb_we ? mw_dout : mr_dout;
-    assign douten  = wb_we ? {4{mw_doe}}  : {4{mr_doe}};
+    PSRAM_QPI_INIT qpi (
+        .clk(clk_i),
+        .rst_n(~rst_i),
+        .qpi_init(qpi_init),
+        .done(qpi_init_done),
+        .sck(qpi_sck),
+        .ce_n(qpi_ce_n),
+        .dout(qpi_dout),
+        .douten(qpi_doe)
+    );
+    assign is_qpi_init = (state == QPI_INIT);
+    assign sck      = is_qpi_init? qpi_sck : (wb_we ? mw_sck  : mr_sck);
+    assign ce_n     = is_qpi_init? qpi_ce_n : (wb_we ? mw_ce_n : mr_ce_n);
+    assign dout     = is_qpi_init? qpi_dout : (wb_we ? mw_dout : mr_dout);
+    assign douten   = is_qpi_init? {4{qpi_doe}} : (wb_we ? {4{mw_doe}}  : {4{mr_doe}});
 
     assign mw_din = din;
     assign mr_din = din;
-    assign ack_o = wb_we ? mw_done :mr_done ;
+    assign ack_o = is_qpi_init? qpi_init_done : ( wb_we ? mw_done :mr_done );
+
 endmodule
+
+
+module PSRAM_QPI_INIT (
+    input   wire        clk,
+    input   wire        rst_n,
+    input   wire        qpi_init,
+    output  reg         done,
+    output  reg         sck,
+    output  reg         ce_n,
+    output  reg [3:0]   dout,
+    output              douten
+);
+
+    localparam  IDLE = 1'b0,
+                INIT = 1'b1;
+
+    reg state, nstate;
+    
+    reg [3:0]   counter;
+
+    wire[7:0]  CMD_35H = 8'h35; // Command to enter QPI mode
+
+    always @*
+        case (state)
+            IDLE: if(qpi_init) nstate = INIT; else nstate = IDLE;
+            INIT: if(done) nstate = IDLE; else nstate = INIT;
+        endcase
+
+    always @ (posedge clk or negedge rst_n)
+        if(!rst_n) state <= IDLE;
+        else state <= nstate;
+
+    // Drive the Serial Clock (sck) @ clk/2
+    always @ (posedge clk or negedge rst_n)
+        if(!rst_n)
+            sck <= 1'b0;
+        else if(~ce_n)
+            sck <= ~ sck;
+        else if(state == IDLE)
+            sck <= 1'b0;
+
+    // ce_n logic
+    always @ (posedge clk or negedge rst_n)
+        if(!rst_n)
+            ce_n <= 1'b1;
+        else if(state == INIT)
+            ce_n <= 1'b0;
+        else
+            ce_n <= 1'b1;
+
+    always @ (posedge clk or negedge rst_n)
+        if(!rst_n)
+            counter <= 4'b0;
+        else if(sck & ~done)
+            counter <= counter + 1'b1;
+        else if(state == IDLE)
+            counter <= 4'b0;
+
+    assign dout     = (counter <= 8)   ?   {3'b0, CMD_35H[7 - counter]} : 4'hf;
+    assign douten   = (~ce_n);
+    assign done     = (counter == 9 );
+
+endmodule
\ No newline at end of file
diff --git a/src/device/Const.scala b/src/device/Const.scala
new file mode 100644
index 0000000..6531cfb
--- /dev/null
+++ b/src/device/Const.scala
@@ -0,0 +1,38 @@
+package ysyx
+import chisel3._
+import chisel3.util._
+
+trait AddrConst {
+  val SRAM_BASE     =     0x0f000000.asUInt(32.W)
+  val SRAM_SIZE     =     0x2000.asUInt(32.W)        // 8KB
+  val MROM_BASE     =     0x20000000.asUInt(32.W)
+  val MROM_SIZE     =     0x1000.asUInt(32.W)        // 4KB
+  val FLASH_BASE    =     0x30000000.asUInt(32.W)
+  val FLASH_SIZE    =     0x10000000.asUInt(32.W)
+  val SPI_BASE      =     0x10001000.asUInt(32.W)
+  val SPI_SIZE      =     0x1000.asUInt(32.W)     // 4KB
+  val SPI_CTRL      =     0x10.asUInt(32.W)        
+  val SPI_TX1       =     0x04.asUInt(32.W)
+  val SPI_RX0       =     0x00.asUInt(32.W)
+  val SPI_TX0       =     0x00.asUInt(32.W)
+  val SPI_SS        =     0x18.asUInt(32.W)   
+  val SPI_SS_FLASH  =     0x01.asUInt(8.W)     
+  // val PSRAM_BASE    =     0x80000000.asUInt(32.W)
+  // val PSRAM_SIZE    =     0x20000000.asUInt(32.W)
+}
+
+trait CmdConst {
+  val SPI_CMD_X           =     0x00.asUInt(8.W)   // write command
+  val SPI_CMD_READ        =     0x03.asUInt(8.W)   // read command
+  val SPI_CMD_QUAD_READ   =     0xeb.asUInt(8.W)   // quad read command
+  val SPI_CMD_QUAD_WRITE  =     0x38.asUInt(8.W)
+  val SPI_CMD_QPI_ENTER   =     0x35.asUInt(8.W)
+  val SPI_CMD_QPI_EXIT    =     0xf5.asUInt(8.W)
+  val SPI_CMD_SET_BURST   =     0xc0.asUInt(8.W)
+}
+
+object Constants extends
+   AddrConst with 
+    CmdConst 
+{
+}
\ No newline at end of file
diff --git a/src/device/PSRAM.scala b/src/device/PSRAM.scala
index fc5c681..de241f2 100644
--- a/src/device/PSRAM.scala
+++ b/src/device/PSRAM.scala
@@ -92,7 +92,7 @@ class psram_array extends BlackBox with HasBlackBoxInline {
       |
       |  reg wen_reg;
       |  reg [31:0] wdata_reg;
-      |  always @(*) begin
+      |  always @(negedge clock) begin
       |    if (ren ) 
       |      psram_read(addr_ext,length_ext, rdata);
       |    else
@@ -122,7 +122,7 @@ class psramChisel extends RawModule {
 
   val s_cmd :: s_addr :: s_wait :: s_data  :: Nil = Enum(4)
   val state               =   SCKRegInit(s_cmd,io.sck,reset)
-  val counter             =   RegSynRetInit(0.U(5.W),io.sck,reset) // counter for cmd, addr, data, wait cycle
+  val counter             =   SCKRegInit(0.U(5.W),io.sck,reset) // counter for cmd, addr, data, wait cycle
   val length              = Mux(state === s_data,(counter+1.U) >> 1.U,4.U) // length of the data to be read or written, 0 means no data
   val psram_array         = Module(new psram_array)
   psram_array.io.reset   := reset
@@ -142,20 +142,23 @@ class psramChisel extends RawModule {
   val wait_cycle    =   SCKRegInit(6.U(5.W),io.sck,reset)        // wait cycle
   val ren           =   (state === s_wait) && (counter === wait_cycle) // when wait cycle is over, ren is high
   val wen           =   wen_reg && ((counter === data_cycle) || reset)  // wen is high when data cycle is over
+  val is_quad_cmd = (cmd === SPI_CMD_QPI_ENTER) || (cmd === SPI_CMD_QPI_EXIT) 
   
   // when read psram dout is valid, dout_en is high 
   wen_reg          := (cmd === SPI_CMD_QUAD_WRITE) && (state === s_data)
-  is_qpi    :=  Mux( cmd === SPI_CMD_QPI_ENTER || cmd === SPI_CMD_QPI_EXIT, cmd === SPI_CMD_QPI_ENTER, is_qpi) // exit qpi mode
+  is_qpi    :=  Mux( is_quad_cmd, cmd === SPI_CMD_QPI_ENTER, is_qpi) // exit qpi mode
   dout      :=  Mux(state === s_data, dout_data(31,28), 0xf.U) // dout is 4 bits
   dout_en   :=  (cmd === SPI_CMD_QUAD_READ) &&  (state === s_data)
-  cmd       :=  Mux(state === s_cmd,Cat(cmd(6,0),din(0)),cmd) // command
+  cmd       :=  Mux(state === s_cmd,Mux(is_qpi,Cat(cmd(3,0),din(3,0)),Cat(cmd(6,0),din(0))),cmd) // command
   addr      :=  Mux(state === s_addr,Cat(addr(19,0),din(3,0)),addr)
   din_data  :=  Mux(state === s_data,Cat(din_data(27,0),din(3,0)),din_data)
   dout_data :=  Mux(state === s_data ,Cat(dout_data(27,0),0.U(4.W)),Mux(ren,psram_array.io.rdata,dout_data)) // dout_data is 32 bits
+  
 
   switch(state) {
     is (s_cmd)  { counter := Mux(!io.ce_n,Mux(counter < cmd_cycle, counter + 1.U,0.U),0.U)  
-                  state := Mux(counter < cmd_cycle,  s_cmd, s_addr) } 
+                  state := Mux(counter < cmd_cycle,  s_cmd, 
+                            Mux(is_quad_cmd,s_cmd,s_addr)) } 
     is (s_addr) { counter := Mux(counter < addr_cycle, counter + 1.U,0.U)
                   state := Mux(counter < addr_cycle, s_addr, 
                   Mux(cmd === SPI_CMD_QUAD_READ,  s_wait, s_data)) }
-- 
2.43.0

