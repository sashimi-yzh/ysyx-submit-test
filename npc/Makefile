MODULE = ysyxSoCFull

# PLATFORM = npc
# ISA = riscv32e

# 寻找所有Verilog源文件
RTL_SOURCES := $(shell find $(NPC_HOME)/rtl -type f -name "*.v")
# 寻找所有Verilog头文件
VINC_PATH := $(NPC_HOME)/rtl/perip/uart16550/rtl $(NPC_HOME)/rtl/perip/spi/rtl $(NPC_HOME)/rtl/include
# 寻找所有C源文件 （不包含main）
C_SOURCES = $(wildcard $(NPC_HOME)/src/*.c $(NPC_HOME)/src/**/*.c)
# 寻找所有H头文件
H_SOURCES = $(wildcard $(NPC_HOME)/include/* $(NPC_HOME)/include/ )

# 包含目录
INC_PATH := $(H_SOURCES)
INCFLAGS = $(addprefix -I, $(INC_PATH))
CXXFLAGS += $(INCFLAGS)
LDLIBS += -lreadline

# llvm disasm
C_SOURCES += $(NPC_HOME)/src/utils/disasm.cc
CXXFLAGS += -I/usr/lib/llvm-14/include -std=c++14 -fno-exceptions -D_GNU_SOURCE -D__STDC_CONSTANT_MACROS -D__STDC_LIMIT_MACROS -fPIE
LDLIBS += -lLLVM-14

# pc trace
NPC_ARGS += -l $(NPC_HOME)/pc_trace_log.txt

VERILATOR_CFLAGS += --timescale "1ns/1ns" --no-timing --trace-fst --autoflush
ifeq ($(PLATFORM),ysyxsoc)
VERILATOR_CFLAGS += +define+ysyx_23060299_verilator_env
#VERILATOR_CFLAGS += +define+ysyx_23060299_PO 
else ifeq ($(PLATFORM),npc)
VERILATOR_CFLAGS += +define+ysyx_23060299_verilator_env +define+ysyx_23060299_NPC
endif

sim: waveform.fst

verilate: .stamp.verilate

build: obj_dir/V$(MODULE)
	obj_dir/V$(MODULE) $(ARGS) $(NPC_ARGS) $(IMG)

waves: waveform.fst
	@echo
	@echo "### WAVES ###"
	gtkwave waveform.fst

waveform.fst: ./obj_dir/V$(MODULE)
	@echo
	@echo "### SIMULATING ###"
	@./obj_dir/V$(MODULE) $(ARGS) $(NPC_ARGS) $(IMG)

./obj_dir/V$(MODULE): .stamp.verilate
	@echo
	@echo "### BUILDING SIM ###"
	make -C obj_dir -f V$(MODULE).mk V$(MODULE)

.stamp.verilate:
	@echo $(PLATFORM)
	@echo "### VERILATING ###"
	@echo $(OBJCACHE)
	@echo $(CXX)
	@echo $(CXXFLAGS)
	@echo $(CPPFLAGS)
	@echo $(OPT_FAST)
	@echo $(C_SOURCES)
	verilator $(VERILATOR_CFLAGS) -cc $(RTL_SOURCES) --top $(MODULE)	\
	$(addprefix -I, $(VINC_PATH))	\
	--exe $(C_SOURCES) $(NPC_HOME)/src/tb_$(MODULE).cpp	\
	$(addprefix -CFLAGS , $(CXXFLAGS))	\
	$(addprefix -LDFLAGS , $(LDLIBS))	

lint: $(RTL_SOURCES)
	verilator --lint-only $(RTL_SOURCES)
	
STUDENT_ID ?= ysyx_23060299
CELLS ?= /home/ysyx/Desktop/ysyx/yosys-sta/nangate45/sim/cells.v
NETLIST ?= /home/ysyx/Desktop/ysyx/yosys-sta/result/ysyx_23060299-500MHz/ysyx_23060299.netlist.syn.v

# RTL 源文件目录
RTL_CORE_DIR := rtl/core
RTL_BUS_DIR := rtl/bus
RTL_INCLUDE_DIR := rtl/include

# 查找所有 .v 和 .sv 文件
VERILOG_SRCS := $(wildcard $(RTL_CORE_DIR)/*.v $(RTL_BUS_DIR)/*.v) 
HEADER_FILES := $(wildcard $(RTL_INCLUDE_DIR)/*.v $(RTL_INCLUDE_DIR)/*.sv)

# 输出目录
BUILD_DIR := build
IBIN = $(BUILD_DIR)/iverilog_sim
IBIN_NETLIST = $(BUILD_DIR)/iverilog_sim_netlist

# 生成最终的 Verilog 文件
verilog: $(BUILD_DIR)/$(STUDENT_ID).v

$(BUILD_DIR)/$(STUDENT_ID).v: $(VERILOG_SRCS) $(HEADER_FILES)
	@mkdir -p $(BUILD_DIR)
	@echo "// ======== Auto-generated by Makefile ========" > $@
	@echo "// Merged from NPC RTL sources" >> $@
	@echo "// Date: $(shell date)" >> $@
	@echo "" >> $@
	# 先插入头文件
	@for header in $(HEADER_FILES); do \
		echo "// ======== Include: $$(basename $$header) ========" >> $@; \
		cat $$header | grep -v '^\s*`include' >> $@; \
		echo "" >> $@; \
	done
	# 然后插入核心模块文件
	@for src in $(VERILOG_SRCS); do \
		echo "// ======== Module: $$(basename $$src) ========" >> $@; \
		cat $$src | grep -v '^\s*`include' >> $@; \
		echo "" >> $@; \
	done
	@echo "Generated $@"

# 仿真目标（使用iverilog）
sim-iverilog: $(BUILD_DIR)/$(STUDENT_ID).v
	@python3 ./utils/bin_to_hex.py $(IMG) $(BUILD_DIR)/memory.hex
	iverilog -g2012 $(BUILD_DIR)/$(STUDENT_ID).v ./iverilog/tb/tb_$(STUDENT_ID).v -o $(IBIN) -s tb_$(STUDENT_ID) -DMEM_FILE=\"$(BUILD_DIR)/memory.hex\"
	@vvp -n $(IBIN) -fst

# 网表仿真目标
sim-iverilog-netlist: $(BUILD_DIR)/$(STUDENT_ID).v
	@python3 ./utils/bin_to_hex.py $(IMG) $(BUILD_DIR)/memory.hex
	iverilog -g2012 $(CELLS) $(NETLIST) ./iverilog/tb/tb_$(STUDENT_ID).v -o $(IBIN_NETLIST) -s tb_$(STUDENT_ID) -DMEM_FILE=\"$(BUILD_DIR)/memory.hex\" -DNETLIST
	@vvp -n $(IBIN_NETLIST) -fst


clean:
	rm -rf ./obj_dir
	rm -rf waveform.fst
	rm -rf ./build/

.PHONY: clean lint waves build sim verilate verilog
